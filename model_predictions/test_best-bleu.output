@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null)); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("").length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testCreateIfAbsentKeyPresent() throws ConcurrentException { [EOL]     final String key = "testKey"; [EOL]     final Integer value = 42; [EOL]     final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); [EOL]     map.put(key, value); [EOL]     assertEquals("Wrong result", value, ConcurrentUtils.createIfAbsent(map, key, new ConstantInitializer<Integer>(value))); [EOL]     assertEquals("Wrong value in map", value, map.get(key)); [EOL] }
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1, 2); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(1, 1, 2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL
@Test [EOL] public void testToLongString() { [EOL]     assertTrue("toLong(String) 1 failed", NumberUtils.toLong("12345") == 12345L); [EOL]     assertTrue("toLong(String) 2 failed", NumberUtils.toLong("abc") == 0L); [EOL]     assertTrue("toLong(empty) failed", NumberUtils.toLong("") == 0L); [EOL]     assertTrue("toLong(null) failed", NumberUtils.toLong(null) == 0L); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(7, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(5, StringUtils.indexOfDifference("i am a ", "i am a ")); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(ef); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf.format(cal)); [EOL]     } finally { [EOL]         out.close(); [EOL]     } [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf2.format(cal)); [EOL]     }
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testReplaceAll_char_char() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll('x', 'y'); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll('a', 'd'); [EOL]     assertEquals("dbcbccba", sb.toString()); [EOL]     sb.replaceAll('b', 'e'); [EOL]     assertEquals("decbccba", sb.toString()); [EOL]     sb.replaceAll('c', 'f'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL]     sb.replaceAll('d', 'd'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testLeftString() { [EOL]     final StrBuilder sb = new StrBuilder("left"); [EOL]     assertEquals("left", sb.leftString(5)); [EOL]     assertEquals("left", sb.leftString(-5)); [EOL]     assertEquals("left", sb.leftString(0)); [EOL]     assertEquals("left", sb.leftString(15)); [EOL] }
@Test [EOL] public void testReplaceFirst_String_String() { [EOL]     final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceFirst((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceFirst("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testCharArrayHiddenByObject() { [EOL]     final char[] array1 = new char[2]; [EOL]     array1[0] = 5; [EOL]     array1[1] = 6; [EOL]     final char[] array2 = new char[2]; [EOL]     array2[0] = 5; [EOL]     array2[1] = 6; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1][1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void test_getPackageCanonicalName_Object() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils(), "<null>")); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Inner(), "<null>")); [EOL]     assertEquals("<null>", ClassUtils.getPackageCanonicalName(null, "<null>")); [EOL] }
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testAppendln_PrimitiveNumber() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     sb.appendln(0); [EOL]     assertEquals("0" + SEP, sb.toString()); [EOL]     sb.appendln(1L); [EOL]     assertEquals("01" + SEP, sb.toString()); [EOL]     sb.appendln(2.3f); [EOL]     assertEquals("012.3" + SEP, sb.toString()); [EOL]     sb.appendln(4.5d); [EOL]     assertEquals("012.34.5" + SEP, sb.toString()); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnCharacters = StringUtils.splitPreserveAllTokens("abstemiously", "."); [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens("abstemiously de fg", null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleChars = StringUtils.splitPreserveAllTokens("abstemiouslyaeiouyabstemiously", "."); [EOL]     assert
@Test [EOL] public void testConstructors() { [EOL]     assertEquals((short) 0, new MutableShort().shortValue()); [EOL]     assertEquals((short) 1, new MutableShort((short) 1).shortValue()); [EOL]     assertEquals((short) 2, new MutableShort(Short.valueOf((short) 2)).shortValue()); [EOL]     assertEquals((short) 3, new MutableShort(new MutableShort((short) 3)).shortValue()); [EOL]     assertEquals((short) 2, new MutableShort("2").shortValue()); [EOL]     try { [EOL]         new MutableShort((Number) null); [EOL]         fail(); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testEscapeSurrogatePairs() throws Exception { [EOL]     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]     assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]     assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array2)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array2.hashCode())); [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array3)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array3.hashCode())); [EOL]     assertFalse(Arrays.equals(array1, array2)); [EOL]     assertFalse(Arrays.equals(array1, array3)); [EOL]     assertFalse(Arrays.equals(array2, array1)); [EOL]     assertFalse(Arrays.equals(array2, array2)); [EOL]     assertFalse(Arrays.equals(array3, array3)); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void test_setExcludeFieldNames() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test [EOL] public void testRemoveEndIgnoreCase() { [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, null)); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "")); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "a")); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", null), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", ""), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", "a"), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com.", ".com"), "www.domain.com."); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ".com"), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ""), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", null), "domain.com"); [EOL] }
@Test [EOL] public void test_getShortCanonicalName_Object() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortCanonicalName(new ClassUtils(), "<null>")); [EOL]     assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName(new Inner(), "<null>")); [EOL]     assertEquals("String", ClassUtils.getShortCanonicalName("hello", "<null>")); [EOL]     assertEquals("<null>", ClassUtils.getShortCanonicalName(null, "<null>")); [EOL] }
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(+1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(-4, 5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testSystemPropertiesLookup() { [EOL]     assertEquals(null, StrLookup.systemPropertiesLookup().lookup(null)); [EOL]     assertEquals(null, StrLookup.systemPropertiesLookup().lookup("")); [EOL]     assertEquals(null, StrLookup.systemPropertiesLookup().lookup("any")); [EOL] }
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementIntArray() { [EOL]     int[] array; [EOL]     array = ArrayUtils.removeElement((int[]) null, 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1 }, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2, 1 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2, 1 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL] }
@Test [EOL] public void testIsRegistered() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     o2.setA(6); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, null)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(null, o2)); [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY); [EOL]     final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy"); [EOL]     assertEquals(format1, format2); [EOL]     assertEquals(format1.hashCode(), format2.hashCode()); [EOL]     assertFalse(format1.equals(new Object())); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testIsAccessible() { [EOL]     assertTrue(ObjectUtils.isAccessible(Byte.MAX_VALUE)); [EOL]     assertTrue(ObjectUtils.isAccessible(Byte.MIN_VALUE)); [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MAX_VALUE + 1); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MAX_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MIN_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MAX_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MIN_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MAX_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testIndexOfIgnoreCase_StringInt() { [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", -1)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 1)); [EOL]     assertEquals(0, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 2)); [EOL]     assertEquals(2, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 3)); [EOL]     assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 4)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 5)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 6)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 7)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 8)); [EOL]     assertEquals(1, StringUtils.indexOfIgnoreCase("aab", "AB", 1)); [EOL]     assertEquals(5, StringUtils.indexOfIgnoreCase("aabaabaa", "", 5)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("ab", "AAB", 0)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aab", "AAB", 1)); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testNullToEmptyShortObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Short[]) null)); [EOL]     final Short[] original = new Short[] { 1, 2 }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Short[] empty = new Short[] {}; [EOL]     final Short[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testIsRegistered() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     o2.setA(6); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, null)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(null, o2)); [EOL] }
@Test [EOL] public void testNullToEmptyByteObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null)); [EOL]     final Byte[] original = new Byte[] { 2, 3 }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Byte[] empty = new Byte[] {}; [EOL]     final Byte[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testMidStringIntInt() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(1, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(0, 1)); [EOL]     assertEquals("", sb.midString(1, 2)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(4, 1)); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, 1)); [EOL]     assertEquals("", sb.midString(5, 4)); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testIsAlphaSpace() { [EOL]     assertFalse(StringUtils.isAlphaSpace(null)); [EOL]     assertTrue(StringUtils.isAlphaSpace("")); [EOL]     assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]     assertFalse(StringUtils.isAlphaSpace("a")); [EOL]     assertFalse(StringUtils.isAlphaSpace("A")); [EOL]     assertFalse(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isAlphaSpace("ham kso")); [EOL]     assertTrue(StringUtils.isAlphaSpace("1")); [EOL]     assertTrue(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isAlphaSpace("_")); [EOL]     assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testReflectionStatics() { [EOL]     final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testTSV() { [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE)); [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray())); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testBasicQuotedTrimmed1() { [EOL]     final String input = "a: 'b' :"; [EOL]     final StrTokenizer tok = new StrTokenizer(input, ':', '\''); [EOL]     tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]     tok.setIgnoreEmptyTokens(false); [EOL]     tok.setEmptyTokenAsNull(true); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertEquals(null, tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testAppendln_String_Object() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final String str) { [EOL]             count[0]++; [EOL]             return super.append(str); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln("foo", "bar"); [EOL]     assertEquals("foo" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testAsReader() throws Exception { [EOL]     final StrBuilder sb = new StrBuilder("some text"); [EOL]     Reader reader = sb.asReader(); [EOL]     assertTrue(reader.ready()); [EOL]     final char[] buf = new char[40]; [EOL]     assertEquals(9, reader.read(buf)); [EOL]     assertEquals("some text", new String(buf, 0, 9)); [EOL]     assertEquals(-1, reader.read()); [EOL]     assertFalse(reader.ready()); [EOL]     assertEquals(0, reader.skip(2)); [EOL]     assertEquals(0, reader.skip(-1)); [EOL]     assertTrue(reader.markSupported()); [EOL]     reader = sb.asReader(); [EOL]     assertEquals('s', reader.read()); [EOL]     reader.mark(-1); [EOL]     char[] array = new char[3]; [EOL]     assertEquals(3, reader.read(array, 0, 3)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('m', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     reader.reset(); [EOL]     assertEquals(1, reader.read(array, 1, 1)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('o', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     assertEquals(2, reader.skip(2)); [EOL]     assertEquals(' ', reader.read()); [EOL]     assertTrue(reader.ready()); [EOL]     reader.close(); [EOL]     assertTrue(reader.ready()); [EOL]     reader = sb.asReader(); [EOL]     array = new char[3]; [EOL]     try { [EOL]         reader.read(array, -1, 0); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex) { [EOL]     } [EOL]     try { [EOL]         reader.read(array, 0, -1); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testNullToEmptyLongObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Long[]) null)); [EOL]     final Long[] original = new Long[] { 1L, 2L }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Long[] empty = new Long[] {}; [EOL]     final Long[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test(expected = ClassCastException.class) [EOL] public void testReflectionCompareEx2() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final Object o2 = new Object(); [EOL]     CompareToBuilder.reflectionCompare(o1, o2); [EOL] }
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testNotBlankMsgBlankStringShouldThrow() { [EOL]     final String string = " \n \t \r \n "; [EOL]     try { [EOL]         Validate.notBlank(string, "Message"); [EOL]         fail("Expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]         assertEquals("Message", e.getMessage()); [EOL]     } [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testSetByteBoolean() { [EOL]     assertEquals(bf_multi.setByte((byte) 0), bf_multi.setByteBoolean((byte) 0, true)); [EOL]     assertEquals(bf_single.setByte((byte) 0), bf_single.setByteBoolean((byte) 0, true)); [EOL]     assertEquals(bf_zero.setByte((byte) 0), bf_zero.setByteBoolean((byte) 0, true)); [EOL]     assertEquals(bf_multi.clearByte((byte) 0), bf_multi.setByteBoolean((byte) 0, false)); [EOL]     assertEquals(bf_single.clearByte((byte) 0), bf_single.setByteBoolean((byte) 0, true)); [EOL]     assertEquals(bf_zero.clearByte((byte) 0), bf_zero.setByteBoolean((byte) 0, false)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void test_getPackageName_Class() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class)); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getPackageName((Class<?>) null)); [EOL]     assertEquals("", ClassUtils.getPackageName(Map.Entry[].class)); [EOL] }
@Test [EOL] public void testToIntValue_CharacterInt() { [EOL]     assertTrue(CharUtils.toIntValue(new Character('0'), 0) == 0); [EOL]     assertTrue(CharUtils.toIntValue(new Character('1'), 0) == 1); [EOL]     assertTrue(CharUtils.toIntValue(new Character('2'), 0) == 2); [EOL]     assertTrue(CharUtils.toIntValue(new Character('3'), 0) == 3); [EOL]     assertTrue(CharUtils.toIntValue(new Character('4'), 0) == 4); [EOL]     assertTrue(CharUtils.toIntValue(new Character('5'), 0) == 5); [EOL]     assertTrue(CharUtils.toIntValue(new Character('6'), 0) == 6); [EOL] }
@Test [EOL] public void testGetSetNullText() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals(null, sb.getNullText()); [EOL]     sb.setNullText("null"); [EOL]     assertEquals("null", sb.getNullText()); [EOL]     sb.setNullText(""); [EOL]     assertEquals(null, sb.getNullText()); [EOL]     sb.setNullText((String) null); [EOL]     assertEquals(null, sb.getNullText()); [EOL] }
@Test [EOL] public void testSetDate() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.setDate(base, Calendar.DATE); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.setDate(base, Calendar.DATE); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     try { [EOL]         result = DateUtils.setDate(base, Calendar.DATE); [EOL]         fail("DateUtils.setDate did not throw an expected IllegalArguementException."); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testExclusiveBetween_withMessage() { [EOL]     Validate.exclusiveBetween("a", "c", "b"); [EOL]     Validate.exclusiveBetween(0, 2, 1); [EOL]     Validate.exclusiveBetween(0, 2, 2); [EOL]     try { [EOL]         Validate.exclusiveBetween(0, 5, 6); [EOL]         fail("Expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]         assertEquals("The value 6 is not in the specified inclusive range of 0 to 5", e.getMessage()); [EOL]     } [EOL] }
@Test [EOL] public void testDecrement() { [EOL]     final MutableFloat mutNum = new MutableFloat(1); [EOL]     mutNum.decrement(); [EOL]     assertEquals(0, mutNum.intValue()); [EOL]     assertEquals(0L, mutNum.longValue()); [EOL] }
@Test [EOL] public void testIsBeforeRange() { [EOL]     assertFalse(intRange.isBeforeRange(null)); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 9))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(15, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(21, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(25, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(21, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(25, 25))); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testToUnicodeEscaped_Character() { [EOL]     assertEquals(null, CharUtils.unicodeEscaped(null)); [EOL]     assertEquals("\\u0041", CharUtils.unicodeEscaped(CHARACTER_A)); [EOL] }
@Test [EOL] public void testSplitByWholeStringPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparatorPreserveAllTokens(null, ".")); [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparatorPreserveAllTokens(null, ".", 3)); [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparatorPreserveAllTokens(null, ".", 4)); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparatorPreserveAllTokens(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparatorPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = { "ab", ":", "cd", ":", "ef" }; [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = { "ab", ":", "cd", ":", "ef" }; [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = { "ab
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0, new MutableInt().intValue()); [EOL]     assertEquals(1, new MutableInt(1).intValue()); [EOL]     assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); [EOL]     assertEquals(3, new MutableInt(new MutableInt(3)).intValue()); [EOL]     assertEquals(2, new MutableInt("2").intValue()); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableLong mutNumA = new MutableLong(0); [EOL]     final MutableLong mutNumB = new MutableLong(0); [EOL]     final MutableLong mutNumC = new MutableLong(1); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals(Long.valueOf(0))); [EOL]     assertFalse(mutNumA.equals("0")); [EOL] }
@Test [EOL] public void test_generateBitVector() { [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class), 0L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 1L), 1L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 2L), 2L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 3L), 3L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 4L), 4L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 5L), 5L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 6L), 6L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 7L), 7L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 8L), 8L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 9L), 9L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 10L), 10L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 11L), 11L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 12L), 12L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 13L), 13L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 14L), 14L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 15L), 15L); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void test_generateBitVector() { [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class), 0L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 1L), 1L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 2L), 2L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 3L), 3L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 4L), 4L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 5L), 5L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 6L), 6L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 7L), 7L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 8L), 8L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 9L), 9L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 10L), 10L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 11L), 11L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 12L), 12L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 13L), 13L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 14L), 14L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 15L), 15L); [EOL] }
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.normalizeUpperBounds(TreeSet.class.getTypeParameters()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testToShortStringI() { [EOL]     assertTrue("toShort(String,short) 1 failed", NumberUtils.toShort("12345", (short) 5) == 12345); [EOL]     assertTrue("toShort(String,short) 2 failed", NumberUtils.toShort("1234.5", (short) 5) == 5); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void testContainsAny_StringWithSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000)); [EOL]     assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001)); [EOL]     assertFalse(StringUtils.containsAny(CharU20000, CharU20000)); [EOL]     assertFalse(StringUtils.containsAny(CharU20000, CharU20001)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testDoubleArrayHiddenByObject() { [EOL]     final double[] array1 = new double[2]; [EOL]     array1[0] = 5; [EOL]     array1[1] = 6; [EOL]     final double[] array2 = new double[2]; [EOL]     array2[0] = 5; [EOL]     array2[1] = 6; [EOL]     final double[] array3 = new double[3]; [EOL]     array3[0] = 5; [EOL]     array3[1] = 6; [EOL]     array3[2] = 7; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj3).isEquals()); [EOL]     array1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj3).isEquals()); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     assertTrue("Wrong number of initializers", mi1.getInitializerCount() == 2); [EOL]     assertTrue("Wrong number of initializers", mi2.getInitializerCount() == 1); [EOL]     assertTrue("Wrong number of initializers", mi1.getInitializerCount() == 2); [EOL]     assertTrue("Wrong number of
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]     final Type[] types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(types.length == 2); [EOL]     Assert.assertEquals(treeSetTypeVar, types[0]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[1]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[2]); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[1]; [EOL]     Assert.assertTrue(types.length == 3); [EOL]     Assert.assertEquals(treeSetTypeVar, types[3]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[4]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[5]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[6]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[7]); [EOL]     Assert.assertEquals(types[8], types[9]); [EOL]     Assert.assertEquals(types[10], types[11]); [EOL]     Assert.assertEquals(types[12], types[13]); [EOL]     Assert.assertEquals(types[13], types[14]); [EOL]     Assert.assertEquals(types[14], types[15]); [EOL]     Assert.assertEquals(types[15], types[16]); [EOL]     Assert.assertEquals(types[16], types[17]); [EOL]     Assert.assertEquals(types[17], types[18]); [EOL]     Assert.assertEquals(types[18], types[19]); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementLongArray() { [EOL]     long[] array; [EOL]     array = ArrayUtils.removeElements((long[]) null, (long) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]     assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new long[] { 1 }, (long) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]     assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1); [EOL]     assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]     assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1); [EOL]     assertTrue(Arrays.equals(new long[] { 2, 1 }, array)); [EOL]     assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((long[]) null, (long) 1, (long) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1, (long) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]     assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1, (long) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]     assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testOSMatchesName() { [EOL]     String osName = null; [EOL]     String osVersion = null; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     osName = ""; [EOL]     osVersion = ""; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     osName = "Windows 95"; [EOL]     osVersion = "1.0"; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     osName = "Windows 95"; [EOL]     osVersion = "1.1"; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     osName = "Windows 98"; [EOL]     osVersion = "1.0"; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void test_setExcludeFieldNames() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testToFloat() { [EOL]     assertEquals(Float.valueOf(0f), new MutableFloat(0f).toFloat()); [EOL]     assertEquals(Float.valueOf(123f), new MutableFloat(123f).toFloat()); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0f, new MutableFloat().floatValue(), 0.0001f); [EOL]     assertEquals(1f, new MutableFloat(1f).floatValue(), 0.0001f); [EOL]     assertEquals(2f, new MutableFloat(Float.valueOf(2f)).floatValue(), 0.0001f); [EOL]     assertEquals(3f, new MutableFloat(new MutableFloat(3f)).floatValue(), 0.0001f); [EOL]     assertEquals(2f, new MutableFloat("2.0").floatValue(), 0.0001f); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(null, new MutableObject<String>().getValue()); [EOL]     final Integer i = Integer.valueOf(6); [EOL]     assertSame(i, new MutableObject<Integer>(i).getValue()); [EOL]     assertSame("HI", new MutableObject<String>("HI").getValue()); [EOL]     assertSame(null, new MutableObject<Object>(null).getValue()); [EOL] }
@Test [EOL] public void testMin() { [EOL]     final Calendar calendar = Calendar.getInstance(); [EOL]     final Date nonNullComparable1 = calendar.getTime(); [EOL]     final Date nonNullComparable2 = calendar.getTime(); [EOL]     final String[] nullAray = null; [EOL]     calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1); [EOL]     final Date minComparable = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable2); [EOL]     assertNull(ObjectUtils.min((String) null)); [EOL]     assertNull(ObjectUtils.min(nullAray)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(null, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(nonNullComparable1, null)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(nonNullComparable1, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(nonNullComparable1, nonNullComparable2)); [EOL]     assertSame(nonNullComparable2, ObjectUtils.min(nonNullComparable2, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(nonNullComparable1, minComparable)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(minComparable, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(null, nonNullComparable1, null, nonNullComparable1)); [EOL]     assertNull(ObjectUtils.min((String) null, (String) null)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testCharSetMatcher_String() { [EOL]     final StrMatcher matcher = StrMatcher.charSetMatcher("ace".toCharArray()); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 4)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(new char[0])); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testIsSameDay_Date() { [EOL]     Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); [EOL]     Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); [EOL]     assertTrue(DateUtils.isSameDay(date1, date2)); [EOL]     date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime(); [EOL]     assertFalse(DateUtils.isSameDay(date1, date2)); [EOL]     date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime(); [EOL]     assertTrue(DateUtils.isSameDay(date1, date2)); [EOL]     date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime(); [EOL]     assertFalse(DateUtils.isSameDay(date1, date2)); [EOL]     try { [EOL]         DateUtils.isSameDay((Date) null, (Date) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testEquivalence() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testGetMultipleTimes() throws ConcurrentException { [EOL]     final ConcurrentInitializer<Object> initializer = createInitializer(); [EOL]     final Object obj = initializer.get(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertEquals("Got different object at " + i, obj, initializer.get()); [EOL]     } [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testGetAccessibleConstructorFromDescription() throws Exception { [EOL]     assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class, ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]     assertNull(ConstructorUtils.getAccessibleConstructor(PrivateClass.class, ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     try { [EOL]         ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE); [EOL]         fail("should throw NoSuchMethodException"); [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     try { [EOL]         ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE); [EOL]         fail("should throw NoSuchMethodException"); [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     try { [EOL]         ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE); [EOL]         fail("should throw NoSuchMethodException"); [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     try { [EOL]         ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE); [EOL]         fail("should throw NoSuchMethodException"); [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     try { [EOL]         ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE); [EOL]         fail("should throw NoSuchMethodException"); [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testInvokeExactConstructor() throws Exception { [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class, (Object[]) null).toString()); [EOL]     assertEquals("()", ConstructorUtils.invokeExactConstructor(TestBean.class).toString()); [EOL]     assertEquals("(String)", ConstructorUtils.invokeExactConstructor(TestBean.class, "").toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, new Object()).toString()); [EOL]     assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE).toString()); [EOL]     assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]     assertEquals("(int)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE).toString()); [EOL]     assertEquals("(double)", ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.DOUBLE_ONE).toString()); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DateParser h = getInstance("yyyy-MM-dd hh a mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser K = getInstance("yyyy-MM-dd KK a mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser k = getInstance("yyyy-MM-dd kk:mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser H = getInstance("yyyy-MM-dd HH:mm:ss", NEW_YORK, Locale.US); [EOL]     cal.set(2010, 7, 1, 0, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 12 AM 33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 0 AM 33:20")); [EOL]     assertEquals(cal.getTime(), k.parse("2010-08-01 00:33:20")); [EOL]     assertEquals(cal.getTime(), H.parse("2010-08-01 00:33:20")); [EOL]     cal.set(2010, 7, 1, 3, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 3 AM 33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 03:33:20")); [EOL]     assertEquals(cal.getTime(), k.parse("2010-08-01 03:33:20")); [EOL]     assertEquals(cal.getTime(), H.parse("2010-08-01 03:33:20")); [EOL]     cal.set(2010, 7, 1, 15, 33, 20); [EOL]     assertEquals(
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     final DateParser h = getInstance("yyyy-MM-dd hh a mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser K = getInstance("yyyy-MM-dd KK a mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser k = getInstance("yyyy-MM-dd kk:mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser H = getInstance("yyyy-MM-dd HH:mm:ss", NEW_YORK, Locale.US); [EOL]     cal.set(2010, 7, 1, 0, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 12 AM 33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 0 AM 33:20")); [EOL]     assertEquals(cal.getTime(), k.parse("2010-08-01 00:33:20")); [EOL]     assertEquals(cal.getTime(), H.parse("2010-08-01 00:33:20")); [EOL]     cal.set(2010, 7, 1, 3, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 3 AM 33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 03:33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 03:33:20")); [EOL]     assertEquals(cal.getTime(), k.parse("2010-08-01 03:33:20")); [EOL]     cal.set(2010, 7, 1, 15, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 3 PM 33:20")
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     final DateParser h = getInstance("yyyy-MM-dd hh a mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser K = getInstance("yyyy-MM-dd KK a mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser k = getInstance("yyyy-MM-dd kk:mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser H = getInstance("yyyy-MM-dd HH:mm:ss", NEW_YORK, Locale.US); [EOL]     cal.set(2010, 7, 1, 0, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 12 AM 33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 0 AM 33:20")); [EOL]     assertEquals(cal.getTime(), k.parse("2010-08-01 00:33:20")); [EOL]     assertEquals(cal.getTime(), H.parse("2010-08-01 00:33:20")); [EOL]     cal.set(2010, 7, 1, 3, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 3 AM 33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 03:33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 03:33:20")); [EOL]     assertEquals(cal.getTime(), k.parse("2010-08-01 03:33:20")); [EOL]     cal.set(2010, 7, 1, 15, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 3 PM 33:20")
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawComponentType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawComponentType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawType_ParameterizedType() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getRawType(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testBooleanHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testBooleanArrayHiddenByObject() { [EOL]     final boolean[] array1 = new boolean[2]; [EOL]     array1[0] = true; [EOL]     array1[1] = false; [EOL]     final boolean[] array2 = new boolean[2]; [EOL]     array2[0] = true; [EOL]     array2[1] = false; [EOL]     final boolean[] array3 = new boolean[3]; [EOL]     array3[0] = true; [EOL]     array3[1] = false; [EOL]     array3[2] = true; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = true; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("c", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null)); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("").length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testReverseDelimited_String() { [EOL]     assertEquals(null, StringUtils.reverseDelimited(null)); [EOL]     assertEquals("", StringUtils.reverseDelimited("")); [EOL]     assertEquals("", StringUtils.reverseDelimited("  ")); [EOL]     assertEquals("i", StringUtils.reverseDelimited("I")); [EOL]     assertEquals("BJL", StringUtils.reverseDelimited("Ben John Lee")); [EOL]     assertEquals("BJ", StringUtils.reverseDelimited("Ben J.Lee")); [EOL]     assertEquals("iah1", StringUtils.reverseDelimited("i am here 123")); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("c", res[1]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(0, res.length); [EOL]     assertEquals("a", res[0]); [EOL]
@Test [EOL] public void testReverseDelimited_String() { [EOL]     assertEquals(null, StringUtils.reverseDelimited(null)); [EOL]     assertEquals("", StringUtils.reverseDelimited("")); [EOL]     assertEquals("", StringUtils.reverseDelimited("  ")); [EOL]     assertEquals("i", StringUtils.reverseDelimited("I")); [EOL]     assertEquals("BJL", StringUtils.reverseDelimited("Ben John Lee")); [EOL]     assertEquals("BJ", StringUtils.reverseDelimited("Ben J.Lee")); [EOL]     assertEquals("iah1", StringUtils.reverseDelimited("i am here 123")); [EOL] }
@Test [EOL] public void testSplit_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.split(null, '.')); [EOL]     assertArrayEquals(null, StringUtils.split(null, '.')); [EOL]     assertEquals(0, StringUtils.split("", '.').length); [EOL]     final String stringToSplit = "a.b. c"; [EOL]     final String[] split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(3, split.length); [EOL]     assertEquals("a", split[0]); [EOL]     assertEquals("b", split[1]); [EOL]     assertEquals(" c", split[2]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(2, split.length); [EOL]     assertEquals("a", split[0]); [EOL]     assertEquals("b", split[1]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(1, split.length); [EOL]     assertEquals("", split[0]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(0, split.length); [EOL]     final String stringToSplit = "a.b.. c"; [EOL]     final String[] split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(2, split.length); [EOL]     assertEquals("a", split[0]); [EOL]     assertEquals("b", split[1]); [EOL]     assertEquals("c", split[2]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(1, split.length); [EOL]     assertEquals("a", split[0]); [EOL]     assertEquals("c", split[1]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(2, split.length); [EOL]     assertEquals("a", split[0]); [EOL]     assertEquals("c", split[1]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assert
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null)); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("").length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testSplit_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.split(null, '.')); [EOL]     assertArrayEquals(null, StringUtils.split(null, '.')); [EOL]     assertEquals(0, StringUtils.split("", '.').length); [EOL]     final String stringToSplit = "foo:bar:baz"; [EOL]     final String[] split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(3, split.length); [EOL]     assertEquals("foo", split[0]); [EOL]     assertEquals("bar", split[1]); [EOL]     assertEquals("baz", split[2]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(2, split.length); [EOL]     assertEquals("", split[0]); [EOL]     assertEquals("", split[1]); [EOL]     assertEquals("", split[2]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(1, split.length); [EOL]     assertEquals("", split[0]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(1, split.length); [EOL]     assertEquals("", split[0]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(1, split.length); [EOL]     assertEquals("", split[0]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(1, split.length); [EOL]     assertEquals("", split[0]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(1, split.length); [EOL]     assertEquals("", split[0]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals("", split[0]); [EOL]     split = StringUtils.split(stringToSplit, '.'); [EOL]     assertEquals(1, split.length); [EOL]     assertEquals("", split[0]); [EOL
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("c", res[1]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(0, res.length); [EOL]     assertEquals("a", res[0]); [EOL]
@Test [EOL] public void testReverseDelimited_String() { [EOL]     assertEquals(null, StringUtils.reverseDelimited(null)); [EOL]     assertEquals("", StringUtils.reverseDelimited("")); [EOL]     assertEquals("", StringUtils.reverseDelimited("  ")); [EOL]     assertEquals("i", StringUtils.reverseDelimited("I")); [EOL]     assertEquals("i", StringUtils.reverseDelimited("i")); [EOL]     assertEquals("BJL", StringUtils.reverseDelimited("Ben John Lee")); [EOL]     assertEquals("BJ", StringUtils.reverseDelimited("Ben J.Lee")); [EOL]     assertEquals("iah1", StringUtils.reverseDelimited("i am here 123")); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("c", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("c", res[2]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("c", res[2]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null)); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("").length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null)); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("").length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testReverseDelimited_String() { [EOL]     assertEquals(null, StringUtils.reverseDelimited(null)); [EOL]     assertEquals("", StringUtils.reverseDelimited("")); [EOL]     assertEquals("", StringUtils.reverseDelimited("  ")); [EOL]     assertEquals("i", StringUtils.reverseDelimited("I")); [EOL]     assertEquals("BJL", StringUtils.reverseDelimited("Ben John Lee")); [EOL]     assertEquals("BJ", StringUtils.reverseDelimited("Ben J.Lee")); [EOL]     assertEquals("iah1", StringUtils.reverseDelimited("i am here 123")); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("c", res[2]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("c", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null)); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("").length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testReverseDelimited_StringChar() { [EOL]     assertEquals(null, StringUtils.reverseDelimited(null, ',')); [EOL]     assertEquals("1;2", StringUtils.reverseDelimited("1;2", SEPARATOR_CHAR)); [EOL]     assertEquals("2", StringUtils.reverseDelimited("2", SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.reverseDelimited("", SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.reverseDelimited("", SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.reverseDelimited("", SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.reverseDelimited(FOOBAR, SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.reverseDelimited(FOOBAR, SEPARATOR_CHAR)); [EOL]     assertEquals(FOO, StringUtils.reverseDelimited(FOOBAR, SEPARATOR_CHAR)); [EOL]     assertEquals(BAR, StringUtils.reverseDelimited(FOOBAR, SEPARATOR_CHAR)); [EOL]     assertEquals(FOOBAR, StringUtils.reverseDelimited(FOOBAR, '/')); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null)); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("").length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("c", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg", '.'))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg", '.'))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("c", res[2]); [EOL]
@Test [EOL] public void testReverseDelimited_String() { [EOL]     assertEquals(null, StringUtils.reverseDelimited(null)); [EOL]     assertEquals("", StringUtils.reverseDelimited("")); [EOL]     assertEquals("", StringUtils.reverseDelimited("  ")); [EOL]     assertEquals("i", StringUtils.reverseDelimited("I")); [EOL]     assertEquals("BJL", StringUtils.reverseDelimited("Ben John Lee")); [EOL]     assertEquals("BJ", StringUtils.reverseDelimited("Ben J.Lee")); [EOL]     assertEquals("iah1", StringUtils.reverseDelimited("i am here 123")); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab de fg", '.'))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", "fg" }, StringUtils.splitPreserveAllTokens("ab   de fg", '.'))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitPreserveAllTokens("ab:cd:ef"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitPreserveAllTokens("number5"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitPreserveAllTokens("fooBar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitPreserveAllTokens("foo200Bar"))); [EOL]     assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitPreserveAllTokens("ASFRules"))); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("c", res[2]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("c", res[1]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(0, res.length); [EOL]     assertEquals("a", res[0]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("c", res[2]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringChar() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); [EOL]     String str = "a.b. c"; [EOL]     String[] res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(" c", res[2]); [EOL]     str = "a.b.. c"; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("", res[0]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(2, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("", res[1]); [EOL]     assertEquals("", res[2]); [EOL]     str = ".a.."; [EOL]     res = StringUtils.splitPreserveAllTokens(str, '.'); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals("c", res[2]); [EOL]
@Test [EOL] public void testCreateIfAbsentKeyPresent() throws ConcurrentException { [EOL]     final String key = "testKey"; [EOL]     final Integer value = 42; [EOL]     final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); [EOL]     map.put(key, value); [EOL]     assertEquals("Wrong result", value, ConcurrentUtils.createIfAbsent(map, key, new ConstantInitializer<Integer>(value))); [EOL]     assertEquals("Wrong value in map", value, map.get(key)); [EOL] }
@Test [EOL] public void testCreateIfAbsentKeyPresent() throws ConcurrentException { [EOL]     final String key = "testKey"; [EOL]     final Integer value = 42; [EOL]     final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); [EOL]     map.put(key, value); [EOL]     assertEquals("Wrong result", value, ConcurrentUtils.createIfAbsent(map, key, new ConstantInitializer<Integer>(value))); [EOL]     assertEquals("Wrong value in map", value, map.get(key)); [EOL] }
@Test [EOL] public void testCreateIfAbsentKeyPresent() throws ConcurrentException { [EOL]     final String key = "testKey"; [EOL]     final Integer value = 42; [EOL]     final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); [EOL]     map.put(key, value); [EOL]     assertEquals("Wrong result", value, ConcurrentUtils.createIfAbsent(map, key, new ConstantInitializer<Integer>(value))); [EOL]     assertEquals("Wrong value in map", value, map.get(key)); [EOL] }
@Test [EOL] public void testCreateIfAbsentKeyPresent() throws ConcurrentException { [EOL]     final String key = "testKey"; [EOL]     final Integer value = 42; [EOL]     final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); [EOL]     map.put(key, value); [EOL]     assertEquals("Wrong result", value, ConcurrentUtils.createIfAbsent(map, key, new ConstantInitializer<Integer>(value))); [EOL]     assertEquals("Wrong value in map", value, map.get(key)); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final Fraction f1 = Fraction.getFraction(3, 5); [EOL]     Fraction f2 = Fraction.getFraction(3, 5); [EOL]     assertTrue(f1.hashCode() == f2.hashCode()); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertTrue(f1.hashCode() != f2.hashCode()); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertTrue(f1.hashCode() != f2.hashCode()); [EOL] }
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1, 2); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(1, 1, 2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1, 2); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(1, 1, 2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1, 2); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(1, 1, 2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final Fraction f1 = Fraction.getFraction(3, 5); [EOL]     Fraction f2 = Fraction.getFraction(3, 5); [EOL]     assertTrue(f1.hashCode() == f2.hashCode()); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertTrue(f1.hashCode() != f2.hashCode()); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertTrue(f1.hashCode() != f2.hashCode()); [EOL] }
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1, 2); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(1, 1, 2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL
@Test [EOL] public void testHashCode() { [EOL]     final Fraction f1 = Fraction.getFraction(3, 5); [EOL]     Fraction f2 = Fraction.getFraction(3, 5); [EOL]     assertTrue(f1.hashCode() == f2.hashCode()); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertTrue(f1.hashCode() != f2.hashCode()); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertTrue(f1.hashCode() != f2.hashCode()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL] }
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 2, 2); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f =
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1, 2); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(1, 1, 2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1, 2); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(1, 1, 2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, -10); [EOL]     assertEquals("-2/5", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, -10); [EOL]     assertEquals("-2/5", f.toProperString()); [EOL] }
@Test [EOL] public void testFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0, 0, 2); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(2, 0, 2); [EOL]     assertEquals(4, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(0, 2, 2); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1, -6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1, 6, -10); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(0, 5); [EOL]     assertEquals("0", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-6, -10); [EOL]     assertEquals("-6/10", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(0, 5); [EOL]     assertEquals("0", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-6, -10); [EOL]     assertEquals("-6/10", f.toProperString()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final Fraction f1 = Fraction.getFraction(3, 5); [EOL]     Fraction f2 = Fraction.getFraction(3, 5); [EOL]     assertTrue(f1.hashCode() == f2.hashCode()); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertTrue(f1.hashCode() != f2.hashCode()); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertTrue(f1.hashCode() != f2.hashCode()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(0, 5); [EOL]     assertEquals("0/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(-2, 5); [EOL]     assertEquals("-2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, -10); [EOL]     assertEquals("-6/10", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(0, 5); [EOL]     assertEquals("0", f.toProperString()); [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 7); [EOL]     assertEquals("2/7", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-6, -10); [EOL]     assertEquals("-6/10", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(0, 5); [EOL]     assertEquals("0", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-6, -10); [EOL]     assertEquals("-6/10", f.toProperString()); [EOL] }
@Test [EOL] public void testToProperString() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(3, 5); [EOL]     assertEquals("3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, 10); [EOL]     assertEquals("6/10", f.toProperString()); [EOL]     f = Fraction.getFraction(-3, 5); [EOL]     assertEquals("-3/5", f.toProperString()); [EOL]     f = Fraction.getFraction(2, 5); [EOL]     assertEquals("2/5", f.toProperString()); [EOL]     f = Fraction.getFraction(6, -10); [EOL]     assertEquals("-2/5", f.toProperString()); [EOL] }
@Test [EOL] public void testToLongStringI() { [EOL]     assertTrue("toLong(String,long) 1 failed", NumberUtils.toLong("12345", 5L) == 12345L); [EOL]     assertTrue("toLong(String,long) 2 failed", NumberUtils.toLong("1234.5", 5L) == 5L); [EOL] }
@Test [EOL] public void testToLongStringI() { [EOL]     assertTrue("toLong(String,long) 1 failed", NumberUtils.toLong("12345", 5L) == 12345L); [EOL]     assertTrue("toLong(String,long) 2 failed", NumberUtils.toLong("1234.5", 5L) == 5L); [EOL] }
@Test [EOL] public void testToLongStringI() { [EOL]     assertTrue("toLong(String,long) 1 failed", NumberUtils.toLong("12345", 5L) == 12345L); [EOL]     assertTrue("toLong(String,long) 2 failed", NumberUtils.toLong("1234.5", 5L) == 5L); [EOL] }
@Test [EOL] public void testToLongStringI() { [EOL]     assertTrue("toLong(String,long) 1 failed", NumberUtils.toLong("12345", 5L) == 12345L); [EOL]     assertTrue("toLong(String,long) 2 failed", NumberUtils.toLong("1234.5", 5L) == 5L); [EOL] }
@Test [EOL] public void testToLongStringI() { [EOL]     assertTrue("toLong(String,long) 1 failed", NumberUtils.toLong("12345", 5L) == 12345L); [EOL]     assertTrue("toLong(String,long) 2 failed", NumberUtils.toLong("1234.5", 5L) == 5L); [EOL] }
@Test [EOL] public void testToLongStringI() { [EOL]     assertTrue("toLong(String,long) 1 failed", NumberUtils.toLong("12345", 5L) == 12345L); [EOL]     assertTrue("toLong(String,long) 2 failed", NumberUtils.toLong("1234.5", 5L) == 5L); [EOL] }
@Test [EOL] public void testToLongString() { [EOL]     assertTrue("toLong(String) 1 failed", NumberUtils.toLong("12345") == 12345L); [EOL]     assertTrue("toLong(String) 2 failed", NumberUtils.toLong("abc") == 0); [EOL]     assertTrue("toLong(empty) failed", NumberUtils.toLong("") == 0); [EOL]     assertTrue("toLong(null) failed", NumberUtils.toLong(null) == 0); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("i am a ", "i am a")); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("i am a ", "i am a")); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(7, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(5, StringUtils.indexOfDifference("i am a ", "i am a ")); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("i am a ", "i am a")); [EOL] }
@Test [EOL] public void testDifference_StringString() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(null, "")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference("", "a")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(BAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL] }
@Test [EOL] public void testDifference() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(FOO, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOO, new String(new char[] { 'f', 'o', 'o' }))); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference("", "")); [EOL]     assertEquals("", StringUtils.difference(FOO, BAR)); [EOL]     assertEquals("", StringUtils.difference(FOO, null)); [EOL]     assertEquals("", StringUtils.difference(null, FOO)); [EOL]     assertEquals("", StringUtils.difference(FOO, FOOBAR)); [EOL]     assertEquals("", StringUtils.difference(FOOBAR, FOO)); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(7, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(5, StringUtils.indexOfDifference("i am a ", "i am a ")); [EOL] }
@Test [EOL] public void testDifference() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(FOO, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOO, new String(new char[] { 'f', 'o', 'o' }))); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference("", "")); [EOL]     assertEquals("", StringUtils.difference(FOO, BAR)); [EOL]     assertEquals("", StringUtils.difference(FOO, null)); [EOL]     assertEquals("", StringUtils.difference(FOO, FOO)); [EOL] }
@Test [EOL] public void testDifference_StringString() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(null, "")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference("", "a")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(BAR, StringUtils.difference(FOOBAR, BAR)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(7, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(5, StringUtils.indexOfDifference("i am a ", "i am a ")); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(7, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(5, StringUtils.indexOfDifference("i am a ", "i am a ")); [EOL] }
@Test [EOL] public void testDifference_StringString() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(null, "")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference("", "a")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(BAR, StringUtils.difference(FOOBAR, BAR)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL] }
@Test [EOL] public void testDifference_StringString() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(null, "")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference("", "a")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(BAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL] }
@Test [EOL] public void testDifference() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(FOO, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOO, new String(new char[] { 'f', 'o', 'o' }))); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference("", "")); [EOL]     assertEquals("", StringUtils.difference(FOO, BAR)); [EOL]     assertEquals("", StringUtils.difference(FOO, null)); [EOL]     assertEquals("", StringUtils.difference(null, FOO)); [EOL]     assertEquals("", StringUtils.difference(FOO, FOOBAR)); [EOL]     assertEquals("", StringUtils.difference(FOOBAR, FOO)); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(7, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(5, StringUtils.indexOfDifference("i am a ", "i am a ")); [EOL] }
@Test [EOL] public void testDifference_StringString() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(null, "")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference("", "a")); [EOL]     assertEquals("", StringUtils.difference("", null)); [EOL]     assertEquals("", StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(BAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOOBAR, StringUtils.difference(FOOBAR, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOOBAR, FOO)); [EOL] }
@Test [EOL] public void testDifference() { [EOL]     assertEquals(null, StringUtils.difference(null, null)); [EOL]     assertEquals(null, StringUtils.difference(FOO, FOO)); [EOL]     assertEquals(FOO, StringUtils.difference(FOO, FOO)); [EOL]     assertEquals("", StringUtils.difference("", "")); [EOL]     assertEquals("", StringUtils.difference("", "abc")); [EOL]     assertEquals("", StringUtils.difference(FOO, BAR)); [EOL]     assertEquals("", StringUtils.difference(FOO, null)); [EOL]     assertEquals("", StringUtils.difference(null, FOO)); [EOL]     assertEquals("", StringUtils.difference("", "")); [EOL]     assertEquals("", StringUtils.difference(FOO, FOO)); [EOL] }
@Test [EOL] public void testDifferenceAt_StringString() { [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference(null, "")); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", null)); [EOL]     assertEquals(-1, StringUtils.indexOfDifference("", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("a", "")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "a")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abc", "ab")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("abcde", "abxyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("abcde", "xyz")); [EOL]     assertEquals(2, StringUtils.indexOfDifference("xyz", "abcde")); [EOL]     assertEquals(0, StringUtils.indexOfDifference("i am a ", "i am a")); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(ef); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf.format(cal)); [EOL]     } finally { [EOL]         out.close(); [EOL]     } [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf2.format(cal)); [EOL]     }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testSpecialCharacters() { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(emp); [EOL]     out.close(); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf.format(cal)); [EOL]     } finally { [EOL]         out.close(); [EOL]     } [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf2.format(cal)); [EOL]     }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(ef); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf.format(cal)); [EOL]     } finally { [EOL]         out.close(); [EOL]     } [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf2.format(cal)); [EOL]     }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Object obj = new Object(); [EOL]     assertTrue(new ExtendedMessageFormat("abc").equals(new ExtendedMessageFormat("abc"))); [EOL]     assertTrue(!new ExtendedMessageFormat("abc").equals(new Object())); [EOL]     obj.setString("abc"); [EOL]     assertTrue(!new ExtendedMessageFormat("abc").equals(new Object())); [EOL]     obj.setStringValue("ABC"); [EOL]     assertTrue(new ExtendedMessageFormat("abc").equals(new ExtendedMessageFormat("abc"))); [EOL]     obj.setStringValue("ABC"); [EOL]     assertTrue(new ExtendedMessageFormat("abc").equals(new ExtendedMessageFormat("abc"))); [EOL]     obj.setStringValue(null); [EOL]     assertFalse(new ExtendedMessageFormat("abc").equals(new Object())); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(ef); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf.format(cal)); [EOL]     } finally { [EOL]         out.close(); [EOL]     } [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf2.format(cal)); [EOL]     }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(ef); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf.format(cal)); [EOL]     } finally { [EOL]         out.close(); [EOL]     } [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf2.format(cal)); [EOL]     }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(emf); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", new String(baos.toByteArray())); [EOL]     out.close(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", new String(baos.toByteArray())); [EOL]     }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSpecialCharacters() { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(ef); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf.format(cal)); [EOL]     } finally { [EOL]         out.close(); [EOL]     } [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf2.format(cal)); [EOL]     }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSpecialCharacters() { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSpecialCharacters() { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(ef); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf.format(cal)); [EOL]     } finally { [EOL]         out.close(); [EOL]     } [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", emf2.format(cal)); [EOL]     }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat("DOB: {1,date,short} Salary: {2,number,currency}", registry); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(emf); [EOL]     final ExtendedMessageFormat emf2 = (ExtendedMessageFormat) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", new String(baos.toByteArray())); [EOL]     out.close(); [EOL]     assertEquals("DOB: {1,date,short} Salary: {2,number,currency}", new String(baos.toByteArray())); [EOL]     }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testSpecialCharacters() { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] }
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] }
@Test [EOL] public void testSpecialCharacters() { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testDeleteIntInt() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.delete(1, 2); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000); [EOL]     assertEquals("", sb.toString()); [EOL]     try { [EOL]         sb.delete(1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.delete(-1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb = new StrBuilder("anything"); [EOL]     try { [EOL]         sb.delete(2, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReplace_StrMatcher_String_int_int() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.replace(StrMatcher.charMatcher('a'), null, 0, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), "x", 0, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), null, 1, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "y", -1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", 0, 1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 0, 1, 2); [EOL]     fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", -1, 1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", 1, -1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 4, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 3, 1); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(
@Test [EOL] public void testNoneMatcher() { [EOL]     final StrMatcher matcher = StrMatcher.noneMatcher(); [EOL]     assertSame(matcher, StrMatcher.noneMatcher()); [EOL]     assertEquals(0, matcher.isMatch(BUFFER1, 11)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER1, 12)); [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testReplace_StrMatcher_String_int_int() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.replace(StrMatcher.charMatcher('a'), null, 0, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), "x", 0, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), null, 1, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "y", -1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", 0, 1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 0, 1, 2); [EOL]     fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", -1, 1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", 1, -1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 4, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 3, 1); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(
@Test [EOL] public void testNoneMatcher() { [EOL]     final StrMatcher matcher = StrMatcher.noneMatcher(); [EOL]     assertSame(matcher, StrMatcher.noneMatcher()); [EOL]     assertEquals(0, matcher.isMatch(BUFFER1, 11)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER1, 12)); [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "any
@Test [EOL] public void testDeleteIntInt() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.delete(1, 2); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000); [EOL]     assertEquals("", sb.toString()); [EOL]     try { [EOL]         sb.delete(1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.delete(-1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb = new StrBuilder("anything"); [EOL]     try { [EOL]         sb.delete(2, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testCharMatcher_char() { [EOL]     final StrMatcher matcher = StrMatcher.charMatcher('a'); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testDeleteIntInt() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.delete(1, 2); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000); [EOL]     assertEquals("", sb.toString()); [EOL]     try { [EOL]         sb.delete(1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.delete(-1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb = new StrBuilder("anything"); [EOL]     try { [EOL]         sb.delete(2, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testDeleteIntInt() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.delete(1, 2); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000); [EOL]     assertEquals("", sb.toString()); [EOL]     try { [EOL]         sb.delete(1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.delete(-1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb = new StrBuilder("anything"); [EOL]     try { [EOL]         sb.delete(2, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testCharMatcher_char() { [EOL]     final StrMatcher matcher = StrMatcher.charMatcher('a'); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testReplace_StrMatcher_String_int_int() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.replace(StrMatcher.charMatcher('a'), null, 0, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), "x", 0, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), null, 1, 2); [EOL]     assertEquals("abc", sb.toString()); [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "y", -1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", 0, 1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 0, 1, 2); [EOL]     fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", -1, 1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.replace(StrMatcher.charMatcher('a'), "z", 4, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 3, 1); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(StrMatcher.charMatcher('a'), "z", 2, 1); [EOL]     assertEquals("abc", sb.toString()); [EOL]     sb.replace(Str
@Test [EOL] public void testReplaceFirst_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst((StrMatcher) null, null); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "any
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testReplaceFirst_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst((StrMatcher) null, null); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcba", sb.
@Test [EOL] public void testDeleteIntInt() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.delete(1, 2); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000); [EOL]     assertEquals("", sb.toString()); [EOL]     try { [EOL]         sb.delete(1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.delete(-1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb = new StrBuilder("anything"); [EOL]     try { [EOL]         sb.delete(2, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReplaceAll_StrMatcher_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((StrMatcher) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((StrMatcher) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "anything"); [EOL]     sb.replaceAll(StrMatcher.noneMatcher(), "
@Test [EOL] public void testReplaceAll_char_char() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll('x', 'y'); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll('a', 'd'); [EOL]     assertEquals("dbcbccba", sb.toString()); [EOL]     sb.replaceAll('b', 'e'); [EOL]     assertEquals("decbccba", sb.toString()); [EOL]     sb.replaceAll('c', 'f'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL]     sb.replaceAll('d', 'd'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_char_char() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll('x', 'y'); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll('a', 'd'); [EOL]     assertEquals("dbcbccba", sb.toString()); [EOL]     sb.replaceAll('b', 'e'); [EOL]     assertEquals("decbccba", sb.toString()); [EOL]     sb.replaceAll('c', 'f'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL]     sb.replaceAll('d', 'd'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_char_char() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll('x', 'y'); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll('a', 'd'); [EOL]     assertEquals("dbcbccba", sb.toString()); [EOL]     sb.replaceAll('b', 'e'); [EOL]     assertEquals("decbccba", sb.toString()); [EOL]     sb.replaceAll('c', 'f'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL]     sb.replaceAll('d', 'd'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_char_char() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll('x', 'y'); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll('a', 'd'); [EOL]     assertEquals("dbcbccba", sb.toString()); [EOL]     sb.replaceAll('b', 'e'); [EOL]     assertEquals("decbccba", sb.toString()); [EOL]     sb.replaceAll('c', 'f'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL]     sb.replaceAll('d', 'd'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_char_char() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll('x', 'y'); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll('a', 'd'); [EOL]     assertEquals("dbcbccba", sb.toString()); [EOL]     sb.replaceAll('b', 'e'); [EOL]     assertEquals("decbccba", sb.toString()); [EOL]     sb.replaceAll('c', 'f'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL]     sb.replaceAll('d', 'd'); [EOL]     assertEquals("defbccba", sb.toString()); [EOL] }
@Test [EOL] public void testDaylight() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T16:33:20", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testDaylight() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T16:33:20", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DatePrinter printer1 = getInstance(YYYY_MM_DD); [EOL]     final DatePrinter printer2 = getInstance(YYYY_MM_DD); [EOL]     assertEquals(printer1, printer2); [EOL]     assertEquals(printer1.hashCode(), printer2.hashCode()); [EOL]     assertFalse(printer1.equals(new Object())); [EOL] }
@Test [EOL] public void test_Equality_Hash() { [EOL]     final DatePrinter printer1 = getInstance(YYYY_MM_DD); [EOL]     final DatePrinter printer2 = getInstance(YYYY_MM_DD); [EOL]     assertEquals(printer1, printer2); [EOL]     assertEquals(printer1.hashCode(), printer2.hashCode()); [EOL]     assertFalse(printer1.equals(new Object())); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DatePrinter printer1 = getInstance(YYYY_MM_DD); [EOL]     final DatePrinter printer2 = getInstance(YYYY_MM_DD); [EOL]     assertEquals(printer1, printer2); [EOL]     assertEquals(printer1.hashCode(), printer2.hashCode()); [EOL]     assertFalse(printer1.equals(new Object())); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DatePrinter printer1 = getInstance(YYYY_MM_DD); [EOL]     final DatePrinter printer2 = getInstance(YYYY_MM_DD); [EOL]     assertEquals(printer1, printer2); [EOL]     assertEquals(printer1.hashCode(), printer2.hashCode()); [EOL]     assertFalse(printer1.equals(new Object())); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testDaylight() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T16:33:20", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DatePrinter printer1 = getInstance(YYYY_MM_DD); [EOL]     final DatePrinter printer2 = getInstance(YYYY_MM_DD); [EOL]     assertEquals(printer1, printer2); [EOL]     assertEquals(printer1.hashCode(), printer2.hashCode()); [EOL]     assertFalse(printer1.equals(new Object())); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DatePrinter printer1 = getInstance(YYYY_MM_DD); [EOL]     final DatePrinter printer2 = getInstance(YYYY_MM_DD); [EOL]     assertEquals(printer1, printer2); [EOL]     assertEquals(printer1.hashCode(), printer2.hashCode()); [EOL]     assertFalse(printer1.equals(new Object())); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testDaylight() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T16:33:20", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DatePrinter printer1 = getInstance(YYYY_MM_DD); [EOL]     final DatePrinter printer2 = getInstance(YYYY_MM_DD); [EOL]     assertEquals(printer1, printer2); [EOL]     assertEquals(printer1.hashCode(), printer2.hashCode()); [EOL]     assertFalse(printer1.equals(new Object())); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testToObject_byte() { [EOL]     final byte[] b = null; [EOL]     assertArrayEquals(null, ArrayUtils.toObject(b)); [EOL]     assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); [EOL]     assertTrue(Arrays.equals(new Byte[] { Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999) }, ArrayUtils.toObject(new byte[] { Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999 }))); [EOL] }
@Test [EOL] public void testLeftString() { [EOL]     final StrBuilder sb = new StrBuilder("left"); [EOL]     assertEquals("left", sb.leftString(5)); [EOL]     assertEquals("left", sb.leftString(-5)); [EOL]     assertEquals("left", sb.leftString(0)); [EOL]     assertEquals("left", sb.leftString(15)); [EOL] }
@Test [EOL] public void testLeftString() { [EOL]     final StrBuilder sb = new StrBuilder("left"); [EOL]     assertEquals("left", sb.leftString(5)); [EOL]     assertEquals("left", sb.leftString(-5)); [EOL]     assertEquals("left", sb.leftString(0)); [EOL]     assertEquals("left", sb.leftString(15)); [EOL] }
@Test [EOL] public void testLeftString() { [EOL]     final StrBuilder sb = new StrBuilder("left"); [EOL]     assertEquals("left", sb.leftString(5)); [EOL]     assertEquals("left", sb.leftString(-5)); [EOL]     assertEquals("left", sb.leftString(0)); [EOL]     assertEquals("left", sb.leftString(15)); [EOL] }
@Test [EOL] public void testLeftString() { [EOL]     final StrBuilder sb = new StrBuilder("left"); [EOL]     assertEquals("left", sb.leftString(-1)); [EOL]     assertEquals("left", sb.leftString(0)); [EOL]     assertEquals("left", sb.leftString(1)); [EOL]     assertEquals("left", sb.leftString(16)); [EOL]     assertEquals("left", sb.leftString(200)); [EOL] }
@Test [EOL] public void testLeftStringInt() { [EOL]     final StrBuilder sb = new StrBuilder("left"); [EOL]     assertEquals("left", sb.leftString(5)); [EOL]     assertEquals("", sb.leftString(-5)); [EOL]     assertEquals("left", sb.leftString(0)); [EOL]     assertEquals("left", sb.leftString(15)); [EOL] }
@Test [EOL] public void testReplaceFirst_String_String() { [EOL]     final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceFirst((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceFirst("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceFirst_String_String() { [EOL]     final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceFirst((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceFirst("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceFirst_String_String() { [EOL]     final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceFirst((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceFirst("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceFirst_String_String() { [EOL]     final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceFirst((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceFirst("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceFirst_String_String() { [EOL]     final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceFirst((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceFirst("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceFirst_String_String() { [EOL]     final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceFirst((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceFirst("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceFirst_String_String() { [EOL]     final StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceFirst((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceFirst("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceFirst("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceFirst("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceFirst("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLocaleMatches() { [EOL]     final DateParser parser = getInstance(yMdHmsSZ, SWEDEN); [EOL]     assertEquals(SWEDEN, parser.getLocale()); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLocaleMatches() { [EOL]     final DateParser parser = getInstance(yMdHmsSZ, SWEDEN); [EOL]     assertEquals(SWEDEN, parser.getLocale()); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLocaleMatches() { [EOL]     final DateParser parser = getInstance(yMdHmsSZ, SWEDEN); [EOL]     assertEquals(SWEDEN, parser.getLocale()); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testLocaleMatches() { [EOL]     final DateParser parser = getInstance(yMdHmsSZ, SWEDEN); [EOL]     assertEquals(SWEDEN, parser.getLocale()); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]             return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLocaleMatches() { [EOL]     final DateParser parser = getInstance(yMdHmsSZ, SWEDEN); [EOL]     assertEquals(SWEDEN, parser.getLocale()); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     cal.setTimeZone(NEW_YORK); [EOL]     DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); [EOL]     assertEquals(cal.getTime(), parse); [EOL]     fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.AD); [EOL]     assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testSwapCase_String() { [EOL]     assertEquals(null, StringUtils.swapCase(null)); [EOL]     assertEquals("", StringUtils.swapCase("")); [EOL]     assertEquals("  ", StringUtils.swapCase("  ")); [EOL]     assertEquals("i", StringUtils.swapCase("I")); [EOL]     assertEquals("I", StringUtils.swapCase("i")); [EOL]     assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123")); [EOL]     assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123")); [EOL]     assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123")); [EOL]     assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123")); [EOL]     final String test = "This String contains a TitleCase character: \u01C8"; [EOL]     final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]     assertEquals(expect, StringUtils.swapCase(test)); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void test_getPackageCanonicalName_String() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3")); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3")); [EOL]     assertEquals("", ClassUtils.getPackageCanonicalName((String) null)); [EOL] }
@Test [EOL] public void testConstructor() { [EOL]     assertNotNull(new ClassUtils()); [EOL]     final Constructor<?>[] cons = ClassUtils.class.getDeclaredConstructors(); [EOL]     assertEquals(1, cons.length); [EOL]     assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]     assertTrue(Modifier.isPublic(ClassUtils.class.getModifiers())); [EOL]     assertFalse(Modifier.isFinal(ClassUtils.class.getModifiers())); [EOL] }
@Test [EOL] public void testConstructor() { [EOL]     assertNotNull(new ClassUtils()); [EOL]     final Constructor<?>[] cons = ClassUtils.class.getDeclaredConstructors(); [EOL]     assertEquals(1, cons.length); [EOL]     assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]     assertTrue(Modifier.isPublic(ClassUtils.class.getModifiers())); [EOL]     assertFalse(Modifier.isFinal(ClassUtils.class.getModifiers())); [EOL] }
@Test [EOL] public void test_getPackageCanonicalName_String() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3")); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3")); [EOL]     assertEquals("", ClassUtils.getPackageCanonicalName((String) null)); [EOL] }
@Test [EOL] public void test_getPackageName_String() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class.getName())); [EOL]     assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getPackageName((String) null)); [EOL] }
@Test [EOL] public void test_getPackageCanonicalName_Object() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils(), "<null>")); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Inner(), "<null>")); [EOL]     assertEquals("<null>", ClassUtils.getPackageCanonicalName(null, "<null>")); [EOL] }
@Test [EOL] public void test_getPackageCanonicalName_Object() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils(), "<null>")); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Inner(), "<null>")); [EOL]     assertEquals("<null>", ClassUtils.getPackageCanonicalName(null, "<null>")); [EOL] }
@Test [EOL] public void test_getPackageCanonicalName_Object() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils(), "<null>")); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Inner(), "<null>")); [EOL]     assertEquals("<null>", ClassUtils.getPackageCanonicalName(null, "<null>")); [EOL] }
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementShortArray() { [EOL]     short[] array; [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); [EOL]     assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); [EOL]     assertEquals(Short.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testAppendln_Long() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final long l) { [EOL]             count[0]++; [EOL]             return super.append(l); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln(1234567890L); [EOL]     assertEquals("1234567890" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testAppendln_Double() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final double value) { [EOL]             count[0]++; [EOL]             return super.append(value); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln(0.9d); [EOL]     assertEquals("0.9" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testAppendln_int() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final int value) { [EOL]             count[0]++; [EOL]             return super.append(value); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln(count[0]); [EOL]     assertEquals("" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testAppendln_float() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final float b) { [EOL]             count[0]++; [EOL]             return super.append(b); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln(0.9f); [EOL]     assertEquals("0.9" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testAppendln_PrimitiveNumber() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     sb.appendln(0); [EOL]     assertEquals("0" + SEP, sb.toString()); [EOL]     sb.appendln(1L); [EOL]     assertEquals("01" + SEP, sb.toString()); [EOL]     sb.appendln(2.3f); [EOL]     assertEquals("012.3" + SEP, sb.toString()); [EOL]     sb.appendln(4.5d); [EOL]     assertEquals("012.34.5" + SEP, sb.toString()); [EOL] }
@Test [EOL] public void testAppendln_int() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final int value) { [EOL]             count[0]++; [EOL]             return super.append(value); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln(0); [EOL]     assertEquals("0" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testAppendln_Long() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final long l) { [EOL]             count[0]++; [EOL]             return super.append(l); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln(1234567890L); [EOL]     assertEquals("1234567890" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnCharacters = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiously"; [EOL]     assertEquals(splitWithMultipleCharsExpectedResults.length, splitWithMultipleChars.length); [EOL]     for (int i = 0; i < splitWithMultipleCharsExpectedResults.length; i++) { [
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnCharacters = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiously"; [EOL]     assertEquals(splitWithMultipleCharsExpectedResults.length, splitWithMultipleChars.length); [EOL]     for (int i = 0; i < splitWithMultipleCharsExpectedResults.length; i++) { [
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnCharacters = StringUtils.splitPreserveAllTokens("abstemiously", "."); [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens("abstemiously de fg", null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleChars = StringUtils.splitPreserveAllTokens("abstemiouslyaeiouyabstemiously", "."); [EOL]     assert
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(splitWithMultipleCharsAndStringExpectedResults[i], splitWithMultipleCharsAndString[i]); [EOL]     } [EOL]     final
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(splitWithMultipleCharsAnd
@Test [EOL] public void testSplit_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.split(null, ".")); [EOL]     assertArrayEquals(null, StringUtils.split(null, ".", 3)); [EOL]     assertEquals(0, StringUtils.split("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.split(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.split(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.split(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.split(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitWithMultipleCharsAndStringExpectedResults.length, splitWithMultipleCharsAndStringResults.length); [EOL]     for (int i = 0; i < splitWithMultiple
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnCharacters = StringUtils.splitPreserveAllTokens("abstemiously", "."); [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens("abstemiously de fg", null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleChars = StringUtils.splitPreserveAllTokens("abstemiouslyaeiouyabstemiously", "."); [EOL]     assert
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleCharsAndStringExpectedResults.length, splitWithMultipleCharsAndString.length); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) {
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitWithMultipleCharsAndStringExpectedResults.length, splitWithMultiple
@Test [EOL] public void testSplit_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.split(null, ".")); [EOL]     assertArrayEquals(null, StringUtils.split(null, ".", 3)); [EOL]     assertEquals(0, StringUtils.split("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.split(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.split(stringToSplitOnCharactersAndString, null, 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.split(stringToSplitWithCharactersAndString, "aeiouy", 2); [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.split(stringToSplitWithCharactersAndString, "y", 1); [EOL]     assertEquals(splitWithMultipleCharsAndStringExpectedResults.length, splitWithMultipleCharsAndStringResults.length); [EOL]     for (int i = 0;
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplit_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.split(null, ".")); [EOL]     assertArrayEquals(null, StringUtils.split(null, ".", 3)); [EOL]     assertEquals(0, StringUtils.split("", ".").length); [EOL]     String str = "a b  .c"; [EOL]     String[] res = StringUtils.split(str, "."); [EOL]     assertEquals(3, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     assertEquals("b", res[1]); [EOL]     assertEquals(".c", res[2]); [EOL]     str = " a "; [EOL]     res = StringUtils.split(str, "."); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     str = "a" + WHITESPACE + "b" + NON_WHITESPACE + "c"; [EOL]     res = StringUtils.split(str, null); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     str = "a" + NON_WHITESPACE + "b" + NON_WHITESPACE + "c"; [EOL]     res = StringUtils.split(str, null); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     str = "a" + NON_WHITESPACE + "b" + NON_WHITESPACE + "c"; [EOL]     res = StringUtils.split(str, null); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     str = "a" + NON_WHITESPACE + "b" + NON_WHITESPACE + "c"; [EOL]     res = StringUtils.split(str, null); [EOL]     assertEquals(1, res.length); [EOL]     assertEquals("a", res[0]); [EOL]     str = "a" + NON_WHITESPACE + "b" + NON_WHITESPACE + "c"; [EOL]     res = StringUtils.split(str
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnCharacters = StringUtils.splitPreserveAllTokens("abstemiously", "."); [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens("abstemiously de fg", null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleChars = StringUtils.splitPreserveAllTokens("abstemiouslyaeiouyabstemiously", "."); [EOL]     assert
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     for (int i = 0; i < splitWithMultipleCharsAndString.length; i++) { [EOL]         assertEquals(split
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitWithMultipleCharsAndStringExpectedResults.length, splitWithMultiple
@Test [EOL] public void testSplit_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.split(null, ".")); [EOL]     assertArrayEquals(null, StringUtils.split(null, ".", 3)); [EOL]     assertEquals(0, StringUtils.split("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.split(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.split(stringToSplitOnCharactersAndString, null, 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleChars = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.split(stringToSplitWithCharactersAndString, "aeiouy", 2); [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.split(stringToSplitWithCharactersAndString, "y", 1); [EOL]     assertEquals(splitWithMultipleCharsAndStringExpectedResults.length, splitWithMultipleCharsAndStringResults.length); [EOL]     for (int i = 0;
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]     } [EOL]     final String[] splitWithMultipleCharsAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleCharsAndString = StringUtils.splitPreserveAllTokens(stringToSplitWithCharactersAndString, "aeiouy"); [EOL]     assertEquals(splitWithMultipleCharsAndStringExpectedResults.length, splitWithMultiple
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringString_StringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testSplitPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]     assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitPreserveAllTokens(stringToSplitOnNulls, null); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnNullExpectedResults.length; j++) { [EOL]         assertEquals(splitOnNullExpectedResults[i][j], splitOnNullResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitOnStringExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitPreserveAllTokens(stringToSplitOnCharacters, null); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         for (int j = 0; j < splitOnStringExpectedResults.length; j++) { [EOL]         assertEquals(splitOnStringExpectedResults[i][j], splitOnStringResults[i][j]); [EOL]         } [EOL]     } [EOL]     final String[] splitWithStringExpectedResults = StringUtils.splitPreserveAllTokens("ab   de fg", null); [EOL]     assertEquals(splitWithStringExpectedResults.length, splitWithStringResults.length); [EOL]     for (int i = 0; i < splitWithStringExpectedResults.length; i++) { [EOL]         assertEquals(splitWithStringExpectedResults[i][j], splitWithStringResults[i][j]); [EOL]
@Test [EOL] public void testGetSet() { [EOL]     final MutableShort mutNum = new MutableShort((short) 0); [EOL]     assertEquals((short) 0, new MutableShort().shortValue()); [EOL]     assertEquals(Short.valueOf((short) 0), new MutableShort().getValue()); [EOL]     mutNum.setValue((short) 1); [EOL]     assertEquals((short) 1, mutNum.shortValue()); [EOL]     assertEquals(Short.valueOf((short) 1), mutNum.getValue()); [EOL]     mutNum.setValue(Short.valueOf((short) 2)); [EOL]     assertEquals((short) 2, mutNum.shortValue()); [EOL]     assertEquals(Short.valueOf((short) 2), mutNum.getValue()); [EOL]     mutNum.setValue(new MutableShort((short) 3)); [EOL]     assertEquals((short) 3, mutNum.shortValue()); [EOL]     try { [EOL]         mutNum.setValue(new MutableShort((short) null); [EOL]         fail(); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals((short) 0, new MutableShort().shortValue()); [EOL]     assertEquals((short) 1, new MutableShort((short) 1).shortValue()); [EOL]     assertEquals((short) 2, new MutableShort(Short.valueOf((short) 2)).shortValue()); [EOL]     assertEquals((short) 3, new MutableShort(new MutableShort((short) 3)).shortValue()); [EOL]     assertEquals((short) 2, new MutableShort("2").shortValue()); [EOL]     try { [EOL]         new MutableShort((Number) null); [EOL]         fail(); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetSet() { [EOL]     final MutableShort mutNum = new MutableShort((short) 0); [EOL]     assertEquals(0, new MutableShort().shortValue()); [EOL]     assertEquals(Short.valueOf((short) 0), new MutableShort().getValue()); [EOL]     mutNum.setValue((short) 1); [EOL]     assertEquals(1, mutNum.shortValue()); [EOL]     assertEquals(Short.valueOf((short) 1), mutNum.getValue()); [EOL]     mutNum.setValue(Short.valueOf((short) 2)); [EOL]     assertEquals(2, mutNum.shortValue()); [EOL]     assertEquals(Short.valueOf((short) 2), mutNum.getValue()); [EOL]     mutNum.setValue(new MutableShort((short) 3)); [EOL]     assertEquals(3, mutNum.shortValue()); [EOL]     try { [EOL]         mutNum.setValue(new MutableShort((Number) null); [EOL]         fail(); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals((short) 0, new MutableShort().shortValue()); [EOL]     assertEquals((short) 1, new MutableShort((short) 1).shortValue()); [EOL]     assertEquals((short) 2, new MutableShort(Short.valueOf((short) 2)).shortValue()); [EOL]     assertEquals((short) 3, new MutableShort(new MutableShort((short) 3)).shortValue()); [EOL]     try { [EOL]         new MutableShort((Number) null); [EOL]         fail(); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetSet() { [EOL]     final MutableShort mutNum = new MutableShort((short) 0); [EOL]     assertEquals(0, new MutableShort().shortValue()); [EOL]     assertEquals(Short.valueOf((short) 0), new MutableShort().getValue()); [EOL]     mutNum.setValue((short) 1); [EOL]     assertEquals(1, mutNum.shortValue()); [EOL]     assertEquals(Short.valueOf((short) 1), mutNum.getValue()); [EOL]     mutNum.setValue(Short.valueOf((short) 2)); [EOL]     assertEquals(2, mutNum.shortValue()); [EOL]     assertEquals(Short.valueOf((short) 2), mutNum.getValue()); [EOL]     mutNum.setValue(new MutableShort((short) 3)); [EOL]     assertEquals(3, mutNum.shortValue()); [EOL]     try { [EOL]         mutNum.setValue(new MutableShort((short) null); [EOL]         fail(); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetSet() { [EOL]     final MutableShort mutNum = new MutableShort((short) 0); [EOL]     assertEquals(0, new MutableShort().shortValue()); [EOL]     assertEquals(Short.valueOf((short) 0), new MutableShort().getValue()); [EOL]     mutNum.setValue((short) 1); [EOL]     assertEquals(1, mutNum.shortValue()); [EOL]     assertEquals(Short.valueOf((short) 1), mutNum.getValue()); [EOL]     mutNum.setValue(Short.valueOf((short) 2)); [EOL]     assertEquals(2, mutNum.shortValue()); [EOL]     assertEquals(Short.valueOf((short) 2), mutNum.getValue()); [EOL]     mutNum.setValue(new MutableShort((short) 3)); [EOL]     assertEquals(3, mutNum.shortValue()); [EOL]     try { [EOL]         mutNum.setValue(new MutableShort((Number) null); [EOL]         fail(); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals((short) 0, new MutableShort().shortValue()); [EOL]     assertEquals((short) 1, new MutableShort((short) 1).shortValue()); [EOL]     assertEquals((short) 2, new MutableShort(Short.valueOf((short) 2)).shortValue()); [EOL]     assertEquals((short) 3, new MutableShort(new MutableShort((short) 3)).shortValue()); [EOL]     try { [EOL]         new MutableShort((Number) null); [EOL]         fail(); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testIndexOfAny_StringStringArray() { [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (CharSequence[]) null)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR)); [EOL]     assertEquals(3, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { "llll" })); [EOL]     assertEquals(6, StringUtils.indexOfAny(FOOBAR, new String[] { "" })); [EOL]     assertEquals(0, StringUtils.indexOfAny("", new String[] { "" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { "a" })); [EOL]     assertEquals(-1, StringUtils.indexOfAny("", new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] { null })); [EOL]     assertEquals(-1, StringUtils.indexOfAny(null, new String[] { null })); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals(-1, sb.lastIndexOf(null)); [EOL]     assertEquals(-1, sb.lastIndexOf("")); [EOL]     sb.append("ab bd"); [EOL]     assertEquals(0, sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals(2, sb.lastIndexOf("c")); [EOL]     assertEquals(4, sb.lastIndexOf("d")); [EOL]     assertEquals(-1, sb.lastIndexOf("e")); [EOL]     assertEquals(0, sb.lastIndexOf("")); [EOL]     assertEquals(-1, sb.lastIndexOf((String) null)); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("b")); [EOL]     assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); [EOL]     assertEquals(-1, sb.lastIndexOf("z")); [EOL] }
@Test [EOL] public void testLastIndexOf_String() { [EOL]     final StrBuilder sb = new StrBuilder("abab"); [EOL]     assertEquals(2, sb.lastIndexOf("a")); [EOL]     assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); [EOL]     assertEquals(3, sb.lastIndexOf("ab")); [EOL]     assertEquals("abab".lastIndexOf("ab"), sb.lastIndexOf("ab")); [EOL]     assertEquals(-1, sb.lastIndexOf("ab")); [EOL]     try { [EOL]         sb.lastIndexOf("anything"); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.lastIndexOf("anything"); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb.append("anything"); [EOL]     assertEquals(2, sb.lastIndexOf("anything")); [EOL]     try { [EOL]         sb.lastIndexOf("anything"); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testEscapeSurrogatePairs() throws Exception { [EOL]     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]     assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]     assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testGetAverageCallsPerPeriod() throws InterruptedException { [EOL]     final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testGetLastAcquiresPerPeriod() throws InterruptedException { [EOL]     final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class); [EOL]     final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]     prepareStartTimer(service, future); [EOL]     EasyMock.replay(service, future); [EOL]     final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, LIMIT); [EOL]     for (int i = 0; i < LIMIT; i++) { [EOL]         assertEquals("Wrong semaphore count at " + i, LIMIT - i, semaphore.getLastAcquiresPerPeriod()); [EOL]         semaphore.acquire(); [EOL]     } [EOL]     semaphore.endOfPeriod(); [EOL]     assertEquals("Wrong semaphore count in new period", LIMIT, semaphore.getLastAcquiresPerPeriod()); [EOL]     EasyMock.verify(service, future); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testGetAverageCallsPerPeriod() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testGetLastAcquiresPerPeriod() throws InterruptedException { [EOL]     final ScheduledExecutorService service = EasyMock.createMock(ScheduledExecutorService.class); [EOL]     final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]     prepareStartTimer(service, future); [EOL]     EasyMock.replay(service, future); [EOL]     final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, LIMIT); [EOL]     for (int i = 0; i < LIMIT; i++) { [EOL]         assertEquals("Wrong semaphore count at " + i, LIMIT - i, semaphore.getLastAcquiresPerPeriod()); [EOL]         semaphore.acquire(); [EOL]     } [EOL]     semaphore.endOfPeriod(); [EOL]     assertEquals("Wrong semaphore count in new period", LIMIT, semaphore.getLastAcquiresPerPeriod()); [EOL]     EasyMock.verify(service, future); [EOL] }
@Test [EOL] public void testStartTimer() throws InterruptedException { [EOL]     final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); [EOL]     final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]     assertNotNull("No future returned", future); [EOL]     Thread.sleep(PERIOD); [EOL]     final int trials = 10; [EOL]     int count = 0; [EOL]     do { [EOL]         Thread.sleep(PERIOD); [EOL]         if (count++ > trials) { [EOL]             fail("endOfPeriod() not called!"); [EOL]         } [EOL]     } while (semaphore.getPeriodEnds() <= 0); [EOL]     semaphore.shutdown(); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array2)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array2.hashCode())); [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array3)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array3.hashCode())); [EOL]     assertFalse(Arrays.equals(array1, array2)); [EOL]     assertFalse(Arrays.equals(array1, array3)); [EOL]     assertFalse(Arrays.equals(array2, array1)); [EOL]     assertFalse(Arrays.equals(array2, array2)); [EOL]     assertFalse(Arrays.equals(array3, array3)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void test_getInstance_String_Locale() { [EOL]     final Locale realDefaultLocale = Locale.getDefault(); [EOL]     try { [EOL]         Locale.setDefault(Locale.US); [EOL]         final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY); [EOL]         final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy"); [EOL]         final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY); [EOL]         assertTrue(format1 != format2); [EOL]         assertSame(format1, format3); [EOL]         assertEquals(Locale.GERMANY, format1.getLocale()); [EOL]     } finally { [EOL]         Locale.setDefault(realDefaultLocale); [EOL]     } [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatPeriodISO() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar base = Calendar.getInstance(timeZone); [EOL]     base.set(1970, 0, 1, 0, 0, 0); [EOL]     base.set(Calendar.MILLISECOND, 0); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2002, 1, 23, 9, 11, 12); [EOL]     cal.set(Calendar.MILLISECOND, 1); [EOL]     String text; [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2002-02-23T09:11:12-03:00", text); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P32Y1M22DT9H11M12.001S", text); [EOL]     cal.set(1971, 1, 3, 10, 30, 0); [EOL]     cal.set(Calendar.MILLISECOND, 0); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P1Y1M2DT10H30M0.000S", text); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P1Y1M2DT10H30M0.000S", text); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array2)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array2.hashCode())); [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array3)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array3.hashCode())); [EOL]     assertFalse(Arrays.equals(array1, array2)); [EOL]     assertFalse(Arrays.equals(array1, array3)); [EOL]     assertFalse(Arrays.equals(array2, array1)); [EOL]     assertFalse(Arrays.equals(array2, array2)); [EOL]     assertFalse(Arrays.equals(array3, array3)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array2)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array2.hashCode())); [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array3)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array3.hashCode())); [EOL]     assertFalse(Arrays.equals(array1, array2)); [EOL]     assertFalse(Arrays.equals(array1, array3)); [EOL]     assertFalse(Arrays.equals(array2, array1)); [EOL]     assertFalse(Arrays.equals(array2, array2)); [EOL]     assertFalse(Arrays.equals(array3, array3)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatPeriodISO() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar base = Calendar.getInstance(timeZone); [EOL]     base.set(1970, 0, 1, 0, 0, 0); [EOL]     base.set(Calendar.MILLISECOND, 0); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2002, 1, 23, 9, 11, 12); [EOL]     cal.set(Calendar.MILLISECOND, 1); [EOL]     String text; [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2002-02-23T09:11:12-03:00", text); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P32Y1M22DT9H11M12.001S", text); [EOL]     cal.set(1971, 1, 3, 10, 30, 0); [EOL]     cal.set(Calendar.MILLISECOND, 0); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P1Y1M2DT10H30M0.000S", text); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P1Y1M2DT10H30M0.000S", text); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testMultipartKey() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime()))); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime().getTime()))); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime().getTime()).toString()); [EOL]     c.set(2005, 1, 2, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime().getTime()))); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime().getTime()).toString()); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatPeriodISO() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar base = Calendar.getInstance(timeZone); [EOL]     base.set(1970, 0, 1, 0, 0, 0); [EOL]     base.set(Calendar.MILLISECOND, 0); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2002, 1, 23, 9, 11, 12); [EOL]     cal.set(Calendar.MILLISECOND, 1); [EOL]     String text; [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2002-02-23T09:11:12-03:00", text); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P32Y1M22DT9H11M12.001S", text); [EOL]     cal.set(1971, 1, 3, 10, 30, 0); [EOL]     cal.set(Calendar.MILLISECOND, 0); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P1Y1M2DT10H30M0.000S", text); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P1Y1M2DT10H30M0.000S", text); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array2)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array2.hashCode())); [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array3)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array3.hashCode())); [EOL]     assertFalse(Arrays.equals(array1, array2)); [EOL]     assertFalse(Arrays.equals(array1, array3)); [EOL]     assertFalse(Arrays.equals(array2, array1)); [EOL]     assertFalse(Arrays.equals(array2, array2)); [EOL]     assertFalse(Arrays.equals(array3, array3)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array2)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array2.hashCode())); [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array3)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array3.hashCode())); [EOL]     assertFalse(Arrays.equals(array1, array2)); [EOL]     assertFalse(Arrays.equals(array1, array3)); [EOL]     assertFalse(Arrays.equals(array2, array1)); [EOL]     assertFalse(Arrays.equals(array2, array2)); [EOL]     assertFalse(Arrays.equals(array3, array3)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatPeriodISO() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar base = Calendar.getInstance(timeZone); [EOL]     base.set(1970, 0, 1, 0, 0, 0); [EOL]     base.set(Calendar.MILLISECOND, 0); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2002, 1, 23, 9, 11, 12); [EOL]     cal.set(Calendar.MILLISECOND, 1); [EOL]     String text; [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2002-02-23T09:11:12-03:00", text); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P32Y1M22DT9H11M12.001S", text); [EOL]     cal.set(1971, 1, 3, 10, 30, 0); [EOL]     cal.set(Calendar.MILLISECOND, 0); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P1Y1M2DT10H30M0.000S", text); [EOL]     text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); [EOL]     assertEquals("P1Y1M2DT10H30M0.000S", text); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array2)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array2.hashCode())); [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array3)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array3.hashCode())); [EOL]     assertFalse(Arrays.equals(array1, array2)); [EOL]     assertFalse(Arrays.equals(array1, array3)); [EOL]     assertFalse(Arrays.equals(array2, array1)); [EOL]     assertFalse(Arrays.equals(array2, array2)); [EOL]     assertFalse(Arrays.equals(array3, array3)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testMultipartKey() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime()))); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime().getTime()))); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime().getTime()).toString()); [EOL]     c.set(2005, 1, 2, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime().getTime()))); [EOL]     assertEquals("2005-01-01T12:00:00", c.format(new Date(c.getTime().getTime().getTime()).toString()); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testAmPm() throws ParseException { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DateParser h = getInstance("yyyy-MM-dd hh a mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser K = getInstance("yyyy-MM-dd KK a mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser k = getInstance("yyyy-MM-dd kk:mm:ss", NEW_YORK, Locale.US); [EOL]     final DateParser H = getInstance("yyyy-MM-dd HH:mm:ss", NEW_YORK, Locale.US); [EOL]     cal.set(2010, 7, 1, 0, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 12 AM 33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 0 AM 33:20")); [EOL]     assertEquals(cal.getTime(), k.parse("2010-08-01 00:33:20")); [EOL]     assertEquals(cal.getTime(), H.parse("2010-08-01 00:33:20")); [EOL]     cal.set(2010, 7, 1, 3, 33, 20); [EOL]     assertEquals(cal.getTime(), h.parse("2010-08-01 3 AM 33:20")); [EOL]     assertEquals(cal.getTime(), K.parse("2010-08-01 03:33:20")); [EOL]     assertEquals(cal.getTime(), k.parse("2010-08-01 03:33:20")); [EOL]     assertEquals(cal.getTime(), H.parse("2010-08-01 03:33:20")); [EOL]     cal.set(2010, 7, 1, 15, 33, 20); [EOL]     assertEquals(
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testFormatUTC() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); [EOL]     assertEquals("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array2)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array2.hashCode())); [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(Arrays.equals(array1, array3)); [EOL]     assertTrue(Arrays.equals(array1.hashCode(), array3.hashCode())); [EOL]     assertFalse(Arrays.equals(array1, array2)); [EOL]     assertFalse(Arrays.equals(array1, array3)); [EOL]     assertFalse(Arrays.equals(array2, array1)); [EOL]     assertFalse(Arrays.equals(array2, array2)); [EOL]     assertFalse(Arrays.equals(array3, array3)); [EOL] }
@Test [EOL] public void testSpecialCharacters() throws Exception { [EOL]     testSdfAndFdp("q", "", true); [EOL]     testSdfAndFdp("Q", "", true); [EOL]     testSdfAndFdp("$", "$", false); [EOL]     testSdfAndFdp("?.d", "?.12", false); [EOL]     testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); [EOL]     testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); [EOL]     testSdfAndFdp("'$\\Ed'", "$\\Ed", false); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testConstructor() { [EOL]     assertNotNull(new CompareToBuilder()); [EOL]     final Constructor<?>[] cons = CompareToBuilder.class.getDeclaredConstructors(); [EOL]     assertEquals(1, cons.length); [EOL]     assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]     assertTrue(Modifier.isPublic(CompareToBuilder.class.getModifiers())); [EOL]     assertFalse(Modifier.isFinal(CompareToBuilder.class.getModifiers())); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final TestObject[] array3 = new TestObject[3]; [EOL]     array3[0] = new TestObject(4); [EOL]     array3[1] = new TestObject(5); [EOL]     array3[2] = new TestObject(6); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final TestObject[] array3 = new TestObject[3]; [EOL]     array3[0] = new TestObject(4); [EOL]     array3[1] = new TestObject(5); [EOL]     array3[2] = new TestObject(6); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final TestObject[] array3 = new TestObject[3]; [EOL]     array3[0] = new TestObject(4); [EOL]     array3[1] = new TestObject(5); [EOL]     array3[2] = new TestObject(6); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final TestObject[] array3 = new TestObject[3]; [EOL]     array3[0] = new TestObject(4); [EOL]     array3[1] = new TestObject(5); [EOL]     array3[2] = new TestObject(6); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final TestObject[] array3 = new TestObject[3]; [EOL]     array3[0] = new TestObject(4); [EOL]     array3[1] = new TestObject(5); [EOL]     array3[2] = new TestObject(6); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testConstructor() { [EOL]     assertNotNull(new CompareToBuilder()); [EOL]     final Constructor<?>[] cons = CompareToBuilder.class.getDeclaredConstructors(); [EOL]     assertEquals(1, cons.length); [EOL]     assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]     assertTrue(Modifier.isPublic(CompareToBuilder.class.getModifiers())); [EOL]     assertFalse(Modifier.isFinal(CompareToBuilder.class.getModifiers())); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final TestObject[] array3 = new TestObject[3]; [EOL]     array3[0] = new TestObject(4); [EOL]     array3[1] = new TestObject(5); [EOL]     array3[2] = new TestObject(6); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final TestObject[] array3 = new TestObject[3]; [EOL]     array3[0] = new TestObject(4); [EOL]     array3[1] = new TestObject(5); [EOL]     array3[2] = new TestObject(6); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArrayHiddenByObject() { [EOL]     final long[] array1 = new long[2]; [EOL]     array1[0] = 5L; [EOL]     array1[1] = 6L; [EOL]     final long[] array2 = new long[2]; [EOL]     array2[0] = 5L; [EOL]     array2[1] = 6L; [EOL]     final long[] array3 = new long[3]; [EOL]     array3[0] = 5L; [EOL]     array3[1] = 6L; [EOL]     array3[2] = 7L; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     final long[] obj1 = new long[2]; [EOL]     obj1[0] = 5L; [EOL]     obj1[1] = 6L; [EOL]     final long[] obj2 = new long[2]; [EOL]     obj2[0] = 5L; [EOL]     obj2[1] = 6L; [EOL]     final long[] obj3 = new long[3]; [EOL]     obj3[0] = 5L; [EOL]     obj3[1] = 6L; [EOL]     obj3[2] = 7L; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final TestObject[] array3 = new TestObject[3]; [EOL]     array3[0] = new TestObject(4); [EOL]     array3[1] = new TestObject(5); [EOL]     array3[2] = new TestObject(6); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testToComparison() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertEquals(0, new CompareToBuilder().toComparison()); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testConstructor() { [EOL]     assertNotNull(new CompareToBuilder()); [EOL]     final Constructor<?>[] cons = CompareToBuilder.class.getDeclaredConstructors(); [EOL]     assertEquals(1, cons.length); [EOL]     assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]     assertTrue(Modifier.isPublic(CompareToBuilder.class.getModifiers())); [EOL]     assertFalse(Modifier.isFinal(CompareToBuilder.class.getModifiers())); [EOL] }
@Test [EOL] public void testToComparison() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL] }
@Test [EOL] public void testObjectArray() { [EOL]     final TestObject[] obj1 = new TestObject[2]; [EOL]     obj1[0] = new TestObject(4); [EOL]     obj1[1] = new TestObject(5); [EOL]     final TestObject[] obj2 = new TestObject[2]; [EOL]     obj2[0] = new TestObject(4); [EOL]     obj2[1] = new TestObject(5); [EOL]     final TestObject[] obj3 = new TestObject[3]; [EOL]     obj3[0] = new TestObject(4); [EOL]     obj3[1] = new TestObject(5); [EOL]     obj3[2] = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = new TestObject(7); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_double_double() { [EOL]     final Double[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Double[] { Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999) }, Double.MAX_VALUE))); [EOL] }
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testBinaryToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('2', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('3', Conversion.binaryToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('6', Conversion.binaryToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryToHexDigit(new boolean[] { true, true, true, false })); [EOL]     assertEquals('8', Conversion.binaryToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('9', Conversion.binaryToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('a', Conversion.binaryToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('b', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('f', Conversion.binaryToHexDigit(new boolean[] { true, true, true, true })); [EOL]     assertEquals('1', Conversion.binaryToHexDigit(new boolean[] {
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[4]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, (double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, (double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[4]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[4]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[5]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[] { 1, 2 }, new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[] { 2, 1 }, new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], new double[0]); [EOL
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[4]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[4]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[] { 1, 2 }, new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[] { 2, 1 }, new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], new double[0]); [EOL
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, (double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, (double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, (double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[4]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[4]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[4]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, (double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null, (double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0], (double[]) null); [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[1]); [EOL]         fail("IllegalArgumentException expected for one input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[2]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[3]); [EOL]         fail("IllegalArgumentException expected for two input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testEnforceExceptions() { [EOL]     try { [EOL]         IEEE754rUtils.min((float[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new float[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.min(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max((double[]) null); [EOL]         fail("IllegalArgumentException expected for null input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         IEEE754rUtils.max(new double[0]); [EOL]         fail("IllegalArgumentException expected for empty input"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testLeftPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.leftPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.leftPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.leftPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.leftPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.leftPad("abc", 5, '\uffff')); [EOL]     assertEquals("abc", StringUtils.leftPad("abc", 2, ' ')); [EOL]     final String str = StringUtils.leftPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testLeftPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.leftPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.leftPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.leftPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.leftPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.leftPad("abc", 5, '\uffff')); [EOL]     assertEquals("abc", StringUtils.leftPad("abc", 2, ' ')); [EOL]     final String str = StringUtils.leftPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testRightPad_StringIntChar() { [EOL]     assertEquals(null, StringUtils.rightPad(null, 5, ' ')); [EOL]     assertEquals("     ", StringUtils.rightPad("", 5, ' ')); [EOL]     assertEquals("  abc", StringUtils.rightPad("abc", 5, ' ')); [EOL]     assertEquals("xxabc", StringUtils.rightPad("abc", 5, 'x')); [EOL]     assertEquals("\uffff\uffffabc", StringUtils.rightPad("abc", 5, '\uffff')); [EOL]     final String str = StringUtils.rightPad("aaa", 10000, 'a'); [EOL]     assertEquals(10000, str.length()); [EOL]     assertTrue(StringUtils.containsOnly(str, new char[] { 'a' })); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testCenter_StringInt() { [EOL]     assertEquals(null, StringUtils.center(null, -1)); [EOL]     assertEquals(null, StringUtils.center(null, 4)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals("ab", StringUtils.center("ab", 0)); [EOL]     assertEquals("ab", StringUtils.center("ab", -1)); [EOL]     assertEquals("ab", StringUtils.center("ab", 1)); [EOL]     assertEquals("    ", StringUtils.center("", 4)); [EOL]     assertEquals(" ab ", StringUtils.center("ab", 4)); [EOL]     assertEquals("abcd", StringUtils.center("abcd", 2)); [EOL]     assertEquals(" a  ", StringUtils.center("a", 4)); [EOL]     assertEquals("  a  ", StringUtils.center("a", 5)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() throws Exception { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_toStringExcludeCollection() { [EOL]     final List<String> excludeList = new ArrayList<String>(); [EOL]     excludeList.add(null); [EOL]     excludeList.add(null); [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void test_toStringExcludeCollectionWithNulls() { [EOL]     final List<String> excludeList = new ArrayList<String>(); [EOL]     excludeList.add(null); [EOL]     excludeList.add(null); [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_toStringExclude() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[] { SECRET_FIELD }); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void test_toStringExcludeCollection() { [EOL]     final List<String> excludeList = new ArrayList<String>(); [EOL]     excludeList.add(null); [EOL]     excludeList.add(null); [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void test_setExcludeFieldNames() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_isAppendTransics() { [EOL]     final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]     assertFalse(instance1.isAppendTransics()); [EOL]     assertTrue(instance1.isAppendStatics()); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertTrue(instance1.isAppendTransics()); [EOL]     assertFalse(instance1.isAppendStatics()); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertTrue(instance1.isAppendTransics()); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     assertFalse(instance1.isAppendTransics()); [EOL]     assertTrue(instance1.isAppendStatics()); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_setExcludeFieldNames() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_toStringExclude() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[] { SECRET_FIELD }); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() throws Exception { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_toStringExclude() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[] { SECRET_FIELD }); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_setExcludeFieldNames() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_toStringExcludeArray() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[] { SECRET_FIELD }); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_toStringExcludeCollectionWithNulls() { [EOL]     final List<String> excludeList = new ArrayList<String>(); [EOL]     excludeList.add(null); [EOL]     excludeList.add(null); [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void test_toStringExcludeCollection() { [EOL]     final List<String> excludeList = new ArrayList<String>(); [EOL]     excludeList.add(null); [EOL]     excludeList.add(null); [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void test_toStringExcludeCollectionWithNulls() { [EOL]     final List<String> excludeList = new ArrayList<String>(); [EOL]     excludeList.add(null); [EOL]     excludeList.add(null); [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void test_isAppendTransics() { [EOL]     final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]     assertFalse(instance1.isAppendTransics()); [EOL]     assertTrue(instance1.isAppendStatics()); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertTrue(instance1.isAppendTransics()); [EOL]     assertFalse(instance1.isAppendStatics()); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertTrue(instance1.isAppendTransics()); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     assertFalse(instance1.isAppendTransics()); [EOL]     assertTrue(instance1.isAppendStatics()); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void test_toStringExclude() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[] { SECRET_FIELD }); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void test_setExcludeFieldNames() { [EOL]     final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null); [EOL]     this.validateSecretFieldPresent(toString); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test(expected = IllegalArgumentException.class) [EOL] public void testXor_object_nullElementInput() { [EOL]     BooleanUtils.xor(new Boolean[] { null }); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test(expected = IllegalArgumentException.class) [EOL] public void testXor_object_nullElementInput() { [EOL]     BooleanUtils.xor(new Boolean[] { null }); [EOL] }
@Test(expected = IllegalArgumentException.class) [EOL] public void testXor_object_nullElementInput() { [EOL]     BooleanUtils.xor(new Boolean[] { null }); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test [EOL] public void testXor_primitive_validInput_2items() { [EOL]     assertTrue("False result for (true, true)", BooleanUtils.xor(new boolean[] { true, true })); [EOL]     assertTrue("True result for (false, false)", !BooleanUtils.xor(new boolean[] { false, false })); [EOL]     assertTrue("True result for (true, false)", !BooleanUtils.xor(new boolean[] { true, false })); [EOL]     assertTrue("True result for (false, true)", !BooleanUtils.xor(new boolean[] { false, true })); [EOL] }
@Test [EOL] public void testRemoveEndIgnoreCase() { [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, null)); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "")); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "a")); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", null), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", ""), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", "a"), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com.", ".com"), "www.domain.com."); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ".com"), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ""), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", null), "domain.com"); [EOL] }
@Test [EOL] public void testRemoveEndIgnoreCase() { [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, null)); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "")); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "a")); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", null), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", ""), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", "a"), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com.", ".com"), "www.domain.com."); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ".com"), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ""), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", null), "domain.com"); [EOL] }
@Test [EOL] public void testRemoveEndIgnoreCase() { [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, null)); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "")); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "a")); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", null), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", ""), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", "a"), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com.", ".com"), "www.domain.com."); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ".com"), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ""), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", null), "domain.com"); [EOL] }
@Test [EOL] public void testAppendIfMissing() { [EOL]     assertEquals("appendIfMissing(null,null)", null, StringUtils.appendIfMissing(null, null)); [EOL]     assertEquals("appendIfMissing(abc,null)", "abc", StringUtils.appendIfMissing("abc", null)); [EOL]     assertEquals("appendIfMissing(\"\",xyz)", "xyz", StringUtils.appendIfMissing("", "xyz")); [EOL]     assertEquals("appendIfMissing(abc,xyz)", "abcxyz", StringUtils.appendIfMissing("abc", "xyz")); [EOL]     assertEquals("appendIfMissing(aXYZ,xyz)", "aXYZxyz", StringUtils.appendIfMissing("aXYZ", "xyz")); [EOL]     assertEquals("appendIfMissing(null,null,null)", null, StringUtils.appendIfMissing(null, null, (CharSequence[]) null)); [EOL]     assertEquals("appendIfMissing(abc,null,null)", "abc", StringUtils.appendIfMissing("abc", null, (CharSequence[]) null)); [EOL]     assertEquals("appendIfMissing(\"\",xyz,null))", "xyz", StringUtils.appendIfMissing("", "xyz", (CharSequence[]) null)); [EOL]     assertEquals("appendIfMissing(abc,xyz,{null})", "abcxyz", StringUtils.appendIfMissing("abc", "xyz", new CharSequence[] { null })); [EOL]     assertEquals("appendIfMissing(abc,xyz,\"\")", "abc", StringUtils.appendIfMissing("abc", "xyz", "")); [EOL]     assertEquals("appendIfMissing(abc,xyz,mno)", "abcxyz", StringUtils.appendIfMissing("abc", "xyz", "mno")); [EOL]     assertEquals("appendIfMissing(abcxyz,xyz,mno)", "abcxyz", StringUtils.appendIfMissing("abcxyz", "xyz", "mno")); [EOL]     assertEquals("appendIfMissing(abcmno,xyz,mno)", "abcmno", StringUtils.appendIf
@Test [EOL] public void testRemoveEndIgnoreCase() { [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, null)); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "")); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "a")); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", null), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", ""), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", "a"), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com.", ".com"), "www.domain.com."); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ".com"), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ""), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", null), "domain.com"); [EOL] }
@Test [EOL] public void testRemoveEndIgnoreCase() { [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, null)); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "")); [EOL]     assertNull(StringUtils.removeEndIgnoreCase(null, "a")); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", null), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", ""), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("", "a"), ""); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com.", ".com"), "www.domain.com."); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ".com"), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ""), "domain.com"); [EOL]     assertEquals(StringUtils.removeEndIgnoreCase("domain.com", null), "domain.com"); [EOL] }
@Test [EOL] public void testAppendIfMissing() { [EOL]     assertEquals("appendIfMissing(null,null)", null, StringUtils.appendIfMissing(null, null)); [EOL]     assertEquals("appendIfMissing(abc,null)", "abc", StringUtils.appendIfMissing("abc", null)); [EOL]     assertEquals("appendIfMissing(\"\",xyz)", "xyz", StringUtils.appendIfMissing("", "xyz")); [EOL]     assertEquals("appendIfMissing(abc,xyz)", "abcxyz", StringUtils.appendIfMissing("abc", "xyz")); [EOL]     assertEquals("appendIfMissing(aXYZ,xyz)", "aXYZxyz", StringUtils.appendIfMissing("aXYZ", "xyz")); [EOL]     assertEquals("appendIfMissing(null,null,null)", null, StringUtils.appendIfMissing(null, null, (CharSequence[]) null)); [EOL]     assertEquals("appendIfMissing(abc,null,null)", "abc", StringUtils.appendIfMissing("abc", null, (CharSequence[]) null)); [EOL]     assertEquals("appendIfMissing(\"\",xyz,null))", "xyz", StringUtils.appendIfMissing("", "xyz", (CharSequence[]) null)); [EOL]     assertEquals("appendIfMissing(abc,xyz,{null})", "abcxyz", StringUtils.appendIfMissing("abc", "xyz", new CharSequence[] { null })); [EOL]     assertEquals("appendIfMissing(abc,xyz,\"\")", "abc", StringUtils.appendIfMissing("abc", "xyz", "")); [EOL]     assertEquals("appendIfMissing(abc,xyz,mno)", "abcxyz", StringUtils.appendIfMissing("abc", "xyz", "mno")); [EOL]     assertEquals("appendIfMissing(abcxyz,xyz,mno)", "abcxyz", StringUtils.appendIfMissing("abcxyz", "xyz", "mno")); [EOL]     assertEquals("appendIfMissing(abcmno,xyz,mno)", "abcmno", StringUtils.appendIf
@Test [EOL] public void test_getShortCanonicalName_Object() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortCanonicalName(new ClassUtils(), "<null>")); [EOL]     assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName(new Inner(), "<null>")); [EOL]     assertEquals("ClassUtilsTest.1", ClassUtils.getShortCanonicalName(new Inner(), "<null>")); [EOL]     class Named extends Object { [EOL]     } [EOL]     assertEquals("ClassUtilsTest.1", ClassUtils.getShortCanonicalName(new Object() { [EOL]     }, "<null>")); [EOL]     assertEquals("ClassUtilsTest.1Named", ClassUtils.getShortCanonicalName(new Named(), "<null>")); [EOL] }
@Test [EOL] public void test_getShortCanonicalName_Object() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortCanonicalName(new ClassUtils(), "<null>")); [EOL]     assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName(new Inner(), "<null>")); [EOL]     assertEquals("ClassUtilsTest.1", ClassUtils.getShortCanonicalName(new Inner(), "<null>")); [EOL]     class Named extends Object { [EOL]     } [EOL]     assertEquals("ClassUtilsTest.1", ClassUtils.getShortCanonicalName(new Object() { [EOL]     }, "<null>")); [EOL]     assertEquals("ClassUtilsTest.1Named", ClassUtils.getShortCanonicalName(new Named(), "<null>")); [EOL] }
@Test [EOL] public void test_getShortCanonicalName_Object() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortCanonicalName(new ClassUtils(), "<null>")); [EOL]     assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName(new Inner(), "<null>")); [EOL]     assertEquals("ClassUtilsTest.1", ClassUtils.getShortCanonicalName(new Inner(), "<null>")); [EOL]     class Named extends Object { [EOL]     } [EOL]     assertEquals("ClassUtilsTest.1", ClassUtils.getShortCanonicalName(new Object() { [EOL]     }, "<null>")); [EOL]     assertEquals("ClassUtilsTest.1Named", ClassUtils.getShortCanonicalName(new Named(), "<null>")); [EOL] }
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(6, -10); [EOL]     f2 = Fraction.getFraction(-4, -5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(6, -10); [EOL]     f2 = Fraction.getFraction(-4, -5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(6, -10); [EOL]     f2 = Fraction.getFraction(-4, -5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testMapLookup_nullMap() { [EOL]     final Map<String, ?> map = null; [EOL]     assertEquals(null, StrLookup.mapLookup(map)); [EOL]     assertEquals(null, StrLookup.mapLookup(map)); [EOL]     assertEquals(null, StrLookup.mapLookup("")); [EOL]     assertEquals(null, StrLookup.mapLookup("any")); [EOL] }
@Test [EOL] public void testMapLookup_nullMap() { [EOL]     final Map<String, ?> map = null; [EOL]     assertEquals(null, StrLookup.mapLookup(map)); [EOL]     assertEquals(null, StrLookup.mapLookup(map)); [EOL]     assertEquals(null, StrLookup.mapLookup("")); [EOL]     assertEquals(null, StrLookup.mapLookup("any")); [EOL] }
@Test [EOL] public void testMapLookup_nullMap() { [EOL]     final Map<String, ?> map = null; [EOL]     assertEquals(null, StrLookup.mapLookup(map)); [EOL]     assertEquals(null, StrLookup.mapLookup(map)); [EOL]     assertEquals(null, StrLookup.mapLookup("")); [EOL]     assertEquals(null, StrLookup.mapLookup("any")); [EOL] }
@Test [EOL] public void testMapLookup_nullMap() { [EOL]     final Map<String, ?> map = null; [EOL]     assertEquals(null, StrLookup.mapLookup(map)); [EOL]     assertEquals(null, StrLookup.mapLookup(map)); [EOL]     assertEquals(null, StrLookup.mapLookup("")); [EOL]     assertEquals(null, StrLookup.mapLookup("any")); [EOL] }
@Test [EOL] public void testSystemPropertiesLookup() { [EOL]     assertEquals(null, StrLookup.systemPropertiesLookup().lookup(null)); [EOL]     assertEquals(null, StrLookup.systemPropertiesLookup().lookup("")); [EOL]     assertEquals(null, StrLookup.systemPropertiesLookup().lookup("any")); [EOL] }
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementFloatArray() { [EOL]     float[] array; [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]     assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]     assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementIntArray() { [EOL]     int[] array; [EOL]     array = ArrayUtils.removeElement((int[]) null, 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1 }, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2, 1 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2, 1 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL] }
@Test [EOL] public void testRemoveElementIntArray() { [EOL]     int[] array; [EOL]     array = ArrayUtils.removeElement((int[]) null, 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1 }, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2, 1 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2, 1 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL] }
@Test [EOL] public void testRemoveElementIntArray() { [EOL]     int[] array; [EOL]     array = ArrayUtils.removeElement((int[]) null, 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1 }, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2, 1 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2, 1 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL] }
@Test [EOL] public void testCloneInt() { [EOL]     assertEquals(null, ArrayUtils.clone((int[]) null)); [EOL]     final int[] original = new int[] { 1, 4 }; [EOL]     final int[] cloned = ArrayUtils.clone(original); [EOL]     assertTrue(Arrays.equals(original, cloned)); [EOL]     assertTrue(original != cloned); [EOL] }
@Test [EOL] public void testRemoveElementIntArray() { [EOL]     int[] array; [EOL]     array = ArrayUtils.removeElement((int[]) null, 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1 }, 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElement(new int[] { 1, 2, 1 }, 1); [EOL]     assertTrue(Arrays.equals(new int[] { 2, 1 }, array)); [EOL]     assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL] }
@Test [EOL] public void testObject() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(null, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(6); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testIsRegistered() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     o2.setA(6); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, null)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(null, o2)); [EOL] }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testGetRegistry() { [EOL]     final Set<Pair<IDKey, IDKey>> set = EqualsBuilder.getRegistry(); [EOL]     assertEquals(set.size(), 1); [EOL]     assertTrue(set.contains(new Pair<IDKey, IDKey>(new IDKey("a"), new IDKey("a")))); [EOL]     assertTrue(set.contains(new Pair<IDKey, IDKey>(new IDKey("a"), new IDKey("b")))); [EOL]     assertTrue(set.contains(new Pair<IDKey, IDKey>(new IDKey("c"), new IDKey("d")))); [EOL]     set.add(new Pair<IDKey, IDKey>(new IDKey("a"), new IDKey("b"))); [EOL]     assertTrue(set.contains(new Pair<IDKey, IDKey>(new IDKey("a"), new IDKey("c"))); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL] }
@Test [EOL] public void testIsRegistered() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, null)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(null, o2)); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionHierarchy() { [EOL]     testReflectionHierarchy(false); [EOL] }
@Test [EOL] public void testReflectionHierarchy() { [EOL]     testReflectionHierarchy(false); [EOL] }
@Test [EOL] public void testGetRegisterPair() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     final Pair<IDKey, IDKey> pair1 = EqualsBuilder.getRegisterPair(o1, o1); [EOL]     assertEquals(new IDKey(o1), pair1.getLeft()); [EOL]     assertEquals(new IDKey(5), pair1.getRight()); [EOL]     final Pair<IDKey, IDKey> pair2 = EqualsBuilder.getRegisterPair(o1, o2); [EOL]     assertEquals(new IDKey(6), pair2.getLeft()); [EOL]     assertEquals(new IDKey(7), pair2.getRight()); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testIsRegistered() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     o2.setA(6); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, null)); [EOL]     assertTrue(!EqualsBuilder.isRegistered(null, o2)); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionHierarchy() { [EOL]     testReflectionHierarchy(false); [EOL] }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testGetRegisterPair() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     final Pair<IDKey, IDKey> pair1 = EqualsBuilder.getRegisterPair(o1, o1); [EOL]     assertEquals(new IDKey(o1), pair1.getLeft()); [EOL]     assertEquals(new IDKey(5), pair1.getRight()); [EOL]     final Pair<IDKey, IDKey> pair2 = EqualsBuilder.getRegisterPair(o1, o2); [EOL]     assertEquals(new IDKey(6), pair2.getLeft()); [EOL]     assertEquals(new IDKey(7), pair2.getRight()); [EOL] }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testObject() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     o2.setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, this).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testObject() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     o2.setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, this).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testObject() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     o2.setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, this).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testObject() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     o2.setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, this).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testGetRegisterPair() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     final Pair<IDKey, IDKey> pair1 = EqualsBuilder.getRegisterPair(o1, o1); [EOL]     assertEquals(new IDKey(o1), pair1.getLeft()); [EOL]     assertEquals(new IDKey(5), pair1.getRight()); [EOL]     final Pair<IDKey, IDKey> pair2 = EqualsBuilder.getRegisterPair(o1, o2); [EOL]     assertEquals(new IDKey(6), pair2.getLeft()); [EOL]     assertEquals(new IDKey(7), pair2.getRight()); [EOL]     final Set<Pair<IDKey, IDKey>> set = new HashSet<Pair<IDKey, IDKey>>(); [EOL]     set.add(pair1); [EOL]     set.add(pair2); [EOL]     assertEquals(2, set.size()); [EOL]     assertTrue(set.contains(pair1)); [EOL]     assertTrue(set.contains(pair2)); [EOL]     final Object o3 = new Object(); [EOL]     final Pair<IDKey, IDKey> pair3 = EqualsBuilder.getRegisterPair(o3, o3); [EOL]     assertEquals(new IDKey(6), pair3.getLeft()); [EOL]     assertEquals(new IDKey(7), pair3.getRight()); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testObject() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     o2.setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, this).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testUnregister() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.isRegistered(o1, o1)); [EOL]     assertFalse(EqualsBuilder.isRegistered(o1, o2)); [EOL]     EqualsBuilder.unregister(o1, o2); [EOL]     assertTrue(!EqualsBuilder.isRegistered(o1, o2)); [EOL]     }
@Test [EOL] public void testGetRegisterPair() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     final Pair<IDKey, IDKey> pair1 = EqualsBuilder.getRegisterPair(o1, o1); [EOL]     assertEquals(new IDKey(o1), pair1.getLeft()); [EOL]     assertEquals(new IDKey(5), pair1.getRight()); [EOL]     final Pair<IDKey, IDKey> pair2 = EqualsBuilder.getRegisterPair(o1, o2); [EOL]     assertEquals(new IDKey(6), pair2.getLeft()); [EOL]     assertEquals(new IDKey(7), pair2.getRight()); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testReflectionHierarchyEquals() { [EOL]     testReflectionHierarchyEquals(false); [EOL] }
@Test [EOL] public void testGetRegistry() { [EOL]     final Set<Pair<IDKey, IDKey>> set = EqualsBuilder.getRegistry(); [EOL]     assertEquals(set.size(), 1); [EOL]     assertTrue(set.contains(new Pair<IDKey, IDKey>(new IDKey("a"), new IDKey("a")))); [EOL]     assertTrue(set.contains(new Pair<IDKey, IDKey>(new IDKey("a"), new IDKey("b")))); [EOL]     assertTrue(set.contains(new Pair<IDKey, IDKey>(new IDKey("c"), new IDKey("d")))); [EOL]     set.add(new Pair<IDKey, IDKey>(new IDKey("a"), new IDKey("b"))); [EOL]     assertTrue(set.contains(new Pair<IDKey, IDKey>(new IDKey("a"), new IDKey("b"))); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testObject() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(null, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testReflectionEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     o2.setA(4); [EOL]     assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); [EOL]     assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); [EOL]     assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(-1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(-1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(-1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(-1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testGetLevenshteinDistance_StringStringInt() { [EOL]     assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("", "a")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog")); [EOL]     assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo")); [EOL]     assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz")); [EOL]     assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo")); [EOL]     assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo")); [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance("a", null); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         @SuppressWarnings("unused") [EOL]         final int d = StringUtils.getLevenshteinDistance(null, "a"); [EOL]         fail("expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T16:33:20", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal.getTime())); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal.getTime())); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal.getTime())); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY); [EOL]     final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy"); [EOL]     assertEquals(format1, format2); [EOL]     assertEquals(format1.hashCode(), format2.hashCode()); [EOL]     assertFalse(format1.equals(new Object())); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal.getTime())); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final DatePrinter format2 = getInstance("yyyy GGGG MMMM dddd aaaa EEEE H mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format2.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal.getTime())); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     cal.set(Calendar.MILLISECOND, 989); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T16:33:20", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), Locale.US); [EOL]     assertEquals("2003-02-10T08:33:20", text); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal.getTime())); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal.getTime())); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL]     cal.set(Calendar.ERA, GregorianCalendar.BC); [EOL]     final DatePrinter format2 = getInstance("yyyy GGGG MMMM dddd aaaa EEEE H mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format2.format(cal)); [EOL] }
@Test [EOL] public void testMilleniumBug() { [EOL]     final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]     cal.clear(); [EOL]     cal.set(2003, 1, 10, 15, 33, 20); [EOL]     final DatePrinter format = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); [EOL]     assertEquals("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00", format.format(cal.getTime())); [EOL]     assertEquals("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testLang538() { [EOL]     final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); [EOL]     cal.clear(); [EOL]     cal.set(2009, 9, 16, 8, 42, 16); [EOL]     final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); [EOL]     assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); [EOL]     assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testObjectArrayHiddenByObject() { [EOL]     final TestObject[] array1 = new TestObject[2]; [EOL]     array1[0] = new TestObject(4); [EOL]     array1[1] = new TestObject(5); [EOL]     final TestObject[] array2 = new TestObject[2]; [EOL]     array2[0] = new TestObject(4); [EOL]     array2[1] = new TestObject(5); [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]     array1[1].setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testAdd() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.add(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, 1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL] }
@Test [EOL] public void testTruncateAmPm() throws Exception { [EOL]     final int calendarField = Calendar.AM_PM; [EOL]     Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 11:59:59.999"); [EOL]     baseTruncateTest(targetAmDate, lastTruncateDate, calendarField); [EOL]     lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999"); [EOL]     baseTruncateTest(targetPmDate, lastTruncateDate, calendarField); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testAdd() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.add(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, 1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL] }
@Test [EOL] public void testTruncateAmPm() throws Exception { [EOL]     final int calendarField = Calendar.AM_PM; [EOL]     Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 11:59:59.999"); [EOL]     baseTruncateTest(targetAmDate, lastTruncateDate, calendarField); [EOL]     lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999"); [EOL]     baseTruncateTest(targetPmDate, lastTruncateDate, calendarField); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testAdd() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.add(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, 1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL] }
@Test [EOL] public void testAdd() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.add(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, 1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL] }
@Test [EOL] public void testAddMilliseconds() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.addMilliseconds(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.addMilliseconds(base, 1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.addMilliseconds(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.addMilliseconds(base, 1000); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testAdd() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.add(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, 1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncateAmPm() throws Exception { [EOL]     final int calendarField = Calendar.AM_PM; [EOL]     Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 11:59:59.999"); [EOL]     baseTruncateTest(targetAmDate, lastTruncateDate, calendarField); [EOL]     lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999"); [EOL]     baseTruncateTest(targetPmDate, lastTruncateDate, calendarField); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testParseSync() throws InterruptedException { [EOL]     final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]     final FastDateFormat formatter = FastDateFormat.getInstance(pattern); [EOL]     final long sdfTime = measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public Object parseObject(final String formattedDate) throws ParseException { [EOL]             synchronized (this) { [EOL]                 return super.parse(formattedDate); [EOL]             } [EOL]         } [EOL]     }); [EOL]     final long fdfTime = measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]     final String times = ">>FastDateFormatTest: FastDateParser:" + fdfTime + "  SimpleDateFormat:" + sdfTime; [EOL]     System.out.println(times); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testAdd() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.add(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, 1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.add(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncateAmPm() throws Exception { [EOL]     final int calendarField = Calendar.AM_PM; [EOL]     Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 11:59:59.999"); [EOL]     baseTruncateTest(targetAmDate, lastTruncateDate, calendarField); [EOL]     lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999"); [EOL]     baseTruncateTest(targetPmDate, lastTruncateDate, calendarField); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testAddMilliseconds() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.addMilliseconds(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.addMilliseconds(base, 1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.addMilliseconds(base, -1); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.addMilliseconds(base, 1000); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL] }
@Test [EOL] public void testTruncateAmPm() throws Exception { [EOL]     final int calendarField = Calendar.AM_PM; [EOL]     Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 11:59:59.999"); [EOL]     baseTruncateTest(targetAmDate, lastTruncateDate, calendarField); [EOL]     lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999"); [EOL]     baseTruncateTest(targetPmDate, lastTruncateDate, calendarField); [EOL] }
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testTruncate() throws Exception { [EOL]     assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); [EOL]     assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); [EOL]     assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); [EOL]     assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); [EOL]     assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); [EOL]     assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); [EOL]     assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); [EOL]     assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); [EOL]     assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); [EOL]     assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); [EOL]     assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18,
@Test [EOL] public void testIsAvailable() { [EOL]     assertEquals(Boolean.TRUE, ObjectUtils.isAvailable(Boolean.class)); [EOL]     final Calendar calendar = Calendar.getInstance(); [EOL]     final Date nonNullComparable1 = calendar.getTime(); [EOL]     final Date nonNullComparable2 = calendar.getTime(); [EOL]     final String[] nullAray = null; [EOL]     calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1); [EOL]     final Date minComparable = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable2); [EOL]     assertNull(ObjectUtils.isAvailable(null)); [EOL]     assertNull(ObjectUtils.isAvailable(nonNullComparable1.getTime())); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.YEAR) - 1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.MONTH) - 1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.HOUR_OF_DAY))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.MINUTE), Integer.valueOf(0)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.HOUR_OF_DAY))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get
@Test [EOL] public void testIsAvailable() { [EOL]     assertEquals(Boolean.TRUE, ObjectUtils.isAvailable(Boolean.class)); [EOL]     final Integer i = Integer.valueOf(45); [EOL]     final Boolean b = Boolean.valueOf(false); [EOL]     assertEquals(Boolean.FALSE, ObjectUtils.isAvailable(Boolean.class)); [EOL]     assertEquals(i, ObjectUtils.isAvailable(i)); [EOL]     b = Boolean.valueOf(true); [EOL]     assertEquals(Boolean.TRUE, ObjectUtils.isAvailable(b)); [EOL]     assertEquals(i, ObjectUtils.isAvailable(i)); [EOL]     b = ObjectUtils.valueOf(Boolean.FALSE); [EOL]     assertEquals(Boolean.FALSE, ObjectUtils.isAvailable(b)); [EOL]     try { [EOL]         ObjectUtils.isAvailable(null); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final NullPointerException npe) { [EOL]     } [EOL] }
@Test [EOL] public void testIsOfType() { [EOL]     assertFalse(ObjectUtils.isOfType(Boolean.FALSE)); [EOL]     assertTrue(ObjectUtils.isOfType(Boolean.TRUE)); [EOL]     assertFalse(ObjectUtils.isOfType(null)); [EOL]     final Integer i = Integer.valueOf(45); [EOL]     final Boolean b = Boolean.valueOf(Boolean.TRUE); [EOL]     final Boolean c = Boolean.valueOf(Boolean.FALSE); [EOL]     assertFalse(ObjectUtils.isOfType(i)); [EOL]     assertTrue(ObjectUtils.isOfType(b)); [EOL]     assertFalse(ObjectUtils.isOfType(c)); [EOL]     try { [EOL]         ObjectUtils.isOfType((Boolean) null); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final NullPointerException npe) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isOfType(Boolean.TRUE); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final NullPointerException npe) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isOfType(Boolean.FALSE); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final NullPointerException npe) { [EOL]     } [EOL] }
@Test [EOL] public void testIsAvailable() { [EOL]     final Calendar calendar = Calendar.getInstance(); [EOL]     final Date nonNullComparable1 = calendar.getTime(); [EOL]     final Date nonNullComparable2 = calendar.getTime(); [EOL]     final String[] nullAray = null; [EOL]     calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1); [EOL]     final Date minComparable = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable2); [EOL]     assertNull(ObjectUtils.isAvailable((String) null)); [EOL]     assertNull(ObjectUtils.isAvailable(nullAray)); [EOL]     assertTrue(ObjectUtils.isAvailable(nonNullComparable1)); [EOL]     assertTrue(ObjectUtils.isAvailable(nonNullComparable1.getTime())); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.YEAR))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.MONTH))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.HOUR_OF_DAY))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.MINUTE))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.HOUR_OF_DAY))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(
@Test [EOL] public void testIsAvailable() { [EOL]     final Calendar calendar = Calendar.getInstance(); [EOL]     final Date nonNullComparable1 = calendar.getTime(); [EOL]     final Date nonNullComparable2 = calendar.getTime(); [EOL]     final String[] nullAray = null; [EOL]     calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1); [EOL]     final Date minComparable = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable2); [EOL]     assertNull(ObjectUtils.isAvailable(nonNullComparable1)); [EOL]     assertNull(ObjectUtils.isAvailable(nonNullComparable1, calendar)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(null, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1, nonNullComparable2)); [EOL]     assertSame(nonNullComparable2, ObjectUtils.isAvailable(nonNullComparable2, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1, nonNullComparable3)); [EOL]     assertSame(nonNullComparable3, ObjectUtils.isAvailable(nonNullComparable3, nonNullComparable1)); [EOL]     final Calendar calendar1 = Calendar.getInstance(); [EOL]     final Date nonNullComparable2 = calendar.getTime(); [EOL]     final Date nonNullComparable3 = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable2); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1, nonNullComparable3)); [EOL]     assertSame(nonNullComparable2, ObjectUtils.isAvailable(nonNullComparable2, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1, (String) null)); [EOL]     assertNull(ObjectUtils.isAvailable(null, (String) null)); [EOL] }
@Test [EOL] public void testIsAccessible() { [EOL]     assertTrue(ObjectUtils.isAccessible(Short.MIN_VALUE)); [EOL]     assertTrue(ObjectUtils.isAccessible(Short.MAX_VALUE)); [EOL]     try { [EOL]         ObjectUtils.isAccessible(null); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Short.TYPE); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Short.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Integer.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Long.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Short.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testIsAssignable() { [EOL]     assertEquals(Boolean.TRUE, ObjectUtils.isAssignable(Boolean.TRUE)); [EOL]     assertEquals(Boolean.FALSE, ObjectUtils.isAssignable(Boolean.FALSE)); [EOL]     try { [EOL]         ObjectUtils.isAssignable(Boolean.TRUE); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Boolean.FALSE); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Byte.valueOf((byte) 1)); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Byte.valueOf((byte) 2)); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Short.valueOf((short) 3)); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Short.valueOf((short) 4)); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testIsAssignable() { [EOL]     assertEquals(Boolean.TRUE, ObjectUtils.isAssignable(Boolean.TRUE)); [EOL]     assertEquals(Boolean.FALSE, ObjectUtils.isAssignable(Boolean.FALSE)); [EOL]     try { [EOL]         ObjectUtils.isAssignable(Boolean.TRUE); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Boolean.FALSE); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Boolean.TRUE); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Byte.valueOf((byte) 1)); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Byte.valueOf((byte) 2)); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Short.valueOf((short) 3)); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAssignable(Short.valueOf((short) 4)); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testIsAssignable() { [EOL]     final Boolean o1 = Boolean.TRUE; [EOL]     final Boolean o2 = Boolean.FALSE; [EOL]     assertEquals(o1, ObjectUtils.isAssignable(o1)); [EOL]     assertEquals(o1, ObjectUtils.isAssignable(o2)); [EOL]     assertTrue(ObjectUtils.isAssignable(Integer.valueOf(1))); [EOL]     assertTrue(ObjectUtils.isAssignable(Integer.valueOf(2))); [EOL]     assertFalse(ObjectUtils.isAssignable(Boolean.TRUE)); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(3))); [EOL]     assertTrue(ObjectUtils.isAssignable(Integer.valueOf(4))); [EOL]     assertTrue(ObjectUtils.isAssignable(Long.valueOf(5L))); [EOL]     assertTrue(ObjectUtils.isAssignable(Long.valueOf(6L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Long.valueOf(7L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(8L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(9L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(10L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(11L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(12L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(13L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(14L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(15L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(16L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(17L))); [EOL]     assertFalse(ObjectUtils.isAssignable(Integer.valueOf(18L))); [EOL]     assertFalse(ObjectUtils.isAssignable(
@Test [EOL] public void testIsAccessible() { [EOL]     assertEquals(Boolean.TRUE, ObjectUtils.isAccessible(Boolean.TRUE)); [EOL]     final Boolean b = Boolean.TRUE; [EOL]     assertEquals(Boolean.FALSE, ObjectUtils.isAccessible(Boolean.FALSE)); [EOL]     try { [EOL]         ObjectUtils.isAccessible(null); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final NullPointerException npe) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Boolean.TRUE); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final NullPointerException npe) { [EOL]     } [EOL] }
@Test [EOL] public void testIsAccessibleByte() { [EOL]     assertTrue(ObjectUtils.isAccessibleByte(Byte.MIN_VALUE)); [EOL]     assertTrue(ObjectUtils.isAccessibleByte(Byte.MAX_VALUE)); [EOL]     try { [EOL]         ObjectUtils.isAccessibleByte(0); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessibleByte(1); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessibleByte(Byte.MAX_VALUE + 1); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessibleByte((byte) 1); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testIsAvailable() { [EOL]     assertEquals(Boolean.TRUE, ObjectUtils.isAvailable(Boolean.TRUE)); [EOL]     final Calendar calendar = Calendar.getInstance(); [EOL]     final Date nonNullComparable1 = calendar.getTime(); [EOL]     final Date nonNullComparable2 = calendar.getTime(); [EOL]     final String[] nullAray = null; [EOL]     calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1); [EOL]     final Date minComparable = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable2); [EOL]     assertNull(ObjectUtils.isAvailable(null)); [EOL]     assertNull(ObjectUtils.isAvailable(nonNullComparable1.getTime())); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.YEAR) - 1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.MONTH) - 1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.HOUR_OF_DAY))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.MINUTE), Integer.valueOf(0)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.HOUR_OF_DAY))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get(Calendar.DAY_OF_WEEK))); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1.get
@Test [EOL] public void testIsAvailable() { [EOL]     final Calendar calendar = Calendar.getInstance(); [EOL]     final Date nonNullComparable1 = calendar.getTime(); [EOL]     final Date nonNullComparable2 = calendar.getTime(); [EOL]     final String[] nullAray = null; [EOL]     calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1); [EOL]     final Date minComparable = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable2); [EOL]     assertNull(ObjectUtils.isAvailable((String) null)); [EOL]     assertNull(ObjectUtils.isAvailable(nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nullAray)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable2)); [EOL]     assertSame(nonNullComparable2, ObjectUtils.isAvailable(nonNullComparable2)); [EOL]     final Calendar calendar1 = Calendar.getInstance(); [EOL]     final Date nonNullComparable = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1)); [EOL]     assertSame(nonNullComparable2, ObjectUtils.isAvailable(nonNullComparable2)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1)); [EOL]     final Calendar calendar2 = Calendar.getInstance(); [EOL]     final Date nonNullComparable3 = calendar.getTime(); [EOL]     assertSame(nonNullComparable3, ObjectUtils.isAvailable(nonNullComparable3)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.isAvailable(nonNullComparable1)); [EOL]     assertSame(nonNullComparable2, ObjectUtils.isAvailable(nonNullComparable2)); [EOL]     assertSame(nonNullCom
@Test [EOL] public void testIsAccessible() { [EOL]     assertTrue(ObjectUtils.isAccessible(Byte.MIN_VALUE)); [EOL]     assertTrue(ObjectUtils.isAccessible(Byte.MAX_VALUE)); [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MIN_VALUE + 1); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MAX_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MIN_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MAX_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MIN_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.MAX_VALUE); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testIsAccessible() { [EOL]     assertTrue(ObjectUtils.isAccessible(Short.MIN_VALUE)); [EOL]     assertTrue(ObjectUtils.isAccessible(Short.MAX_VALUE)); [EOL]     try { [EOL]         ObjectUtils.isAccessible(null); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Short.class); [EOL]         fail("NullPointerException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Short.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Integer.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Long.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Short.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessible(Byte.class); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testIsAccessibleByte() { [EOL]     assertTrue(ObjectUtils.isAccessibleByte(Byte.MIN_VALUE)); [EOL]     assertTrue(ObjectUtils.isAccessibleByte(Byte.MAX_VALUE)); [EOL]     try { [EOL]         ObjectUtils.isAccessibleByte(0); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessibleByte(1); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessibleByte(Byte.MAX_VALUE + 1); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         ObjectUtils.isAccessibleByte((byte) 1); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     a.hashCode(); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); [EOL]     assertFalse(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayD = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array3)); [EOL]     assertTrue(ArrayUtils.hashCode(array2) == ArrayUtils.hashCode(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 }
@Test [EOL] public void testDoubleArrayAsObject() { [EOL]     final double[] obj = new double[2]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[0] = 5.4d; [EOL]     final long l1 = Double.doubleToLongBits(5.4d); [EOL]     final int h1 = (int) (l1 ^ l1 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[1] = 6.3d; [EOL]     final long l2 = Double.doubleToLongBits(6.3d); [EOL]     final int h2 = (int) (l2 ^ l2 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final Integer i3 = Integer.valueOf(3); [EOL]     final Integer i4 = Integer.valueOf(4); [EOL]     final Integer i5 = Integer.valueOf(5); [EOL]     assertTrue(new IDKey(i3).hashCode() == new IDKey(i3).hashCode()); [EOL]     assertFalse(new IDKey(i3).hashCode() == new IDKey(i3).hashCode()); [EOL]     assertFalse(new IDKey(i3).hashCode() == new IDKey(null).hashCode()); [EOL] }
@Test [EOL] public void testBooleanMultiArray() { [EOL]     final boolean[][] obj = new boolean[2][]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[0]; [EOL]     assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[1]; [EOL]     assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[2]; [EOL]     assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0][0] = true; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[1] = new boolean[1]; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL] }
@Test [EOL] public void testConstructorEx2() { [EOL]     final HashCodeBuilder hcb = new HashCodeBuilder(2, 2); [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final IDKey key = new IDKey(0); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(key); [EOL]     final IDKey deserializedKey = (IDKey) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(key, deserializedKey); [EOL]     assertEquals(key.hashCode(), deserializedKey.hashCode()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.hashCode(arrayB) == ArrayUtils.hashCode(arrayA)); [EOL] }
@Test [EOL] public void testBooleanMultiArray() { [EOL]     final boolean[][] obj = new boolean[2][]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[0]; [EOL]     assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[1]; [EOL]     assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[2]; [EOL]     assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0][0] = true; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[1] = new boolean[1]; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL] }
@Test [EOL] public void testIDKey() { [EOL]     final Object value = new Object(); [EOL]     final IDKey key = new IDKey(value); [EOL]     assertEquals(value, key.getID()); [EOL]     assertTrue(key.equals(new IDKey(value))); [EOL]     assertFalse(key.equals(null)); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final IDKey key = new IDKey(0); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(key); [EOL]     final IDKey deserializedKey = (IDKey) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(key, deserializedKey); [EOL]     assertEquals(key.hashCode(), deserializedKey.hashCode()); [EOL] }
@Test [EOL] public void testDoubleArrayAsObject() { [EOL]     final double[] obj = new double[2]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[0] = 5.4d; [EOL]     final long l1 = Double.doubleToLongBits(5.4d); [EOL]     final int h1 = (int) (l1 ^ l1 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[1] = 6.3d; [EOL]     final long l2 = Double.doubleToLongBits(6.3d); [EOL]     final int h2 = (int) (l2 ^ l2 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL] }
@Test [EOL] public void testIsRegistered() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(null)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(new Object())); [EOL]     assertTrue(HashCodeBuilder.isRegistered(array1)); [EOL]     assertTrue(HashCodeBuilder.isRegistered(array1)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array2)); [EOL]     assertTrue(HashCodeBuilder.isRegistered(array2)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     final Object[] array4 = new Object[] { new String(new char[] { 'A', 'B' }; [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(HashCodeBuilder.isRegistered(arrayB)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayA)); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); [EOL]     assertFalse(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.hashCode(arrayB) == ArrayUtils.hashCode(arrayA)); [EOL] }
@Test [EOL] public void testDoubleArrayAsObject() { [EOL]     final double[] obj = new double[2]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[0] = 5.4d; [EOL]     final long l1 = Double.doubleToLongBits(5.4d); [EOL]     final int h1 = (int) (l1 ^ l1 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[1] = 6.3d; [EOL]     final long l2 = Double.doubleToLongBits(6.3d); [EOL]     final int h2 = (int) (l2 ^ l2 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL] }
@Test [EOL] public void testConstructorEx2() { [EOL]     final HashCodeBuilder hcb = new HashCodeBuilder(2, 2); [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName()); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testBooleanMultiArray() { [EOL]     final boolean[][] obj = new boolean[2][]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[0]; [EOL]     assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[1]; [EOL]     assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[2]; [EOL]     assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0][0] = true; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[1] = new boolean[1]; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array4 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.hashCode(arrayB) == ArrayUtils.hashCode(arrayA)); [EOL] }
@Test [EOL] public void testUnregister() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(array1)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     assertTrue(HashCodeBuilder.isRegistered(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(HashCodeBuilder.isRegistered(arrayB)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayB)); [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayC)); [EOL] }
@Test [EOL] public void testIsRegistered() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(null)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array1)); [EOL]     assertTrue(HashCodeBuilder.isRegistered(array1)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     assertTrue(HashCodeBuilder.isRegistered(array3)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array4)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(HashCodeBuilder.isRegistered(arrayB)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayA)); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); [EOL]     assertFalse(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.hashCode(arrayB) == ArrayUtils.hashCode(arrayA)); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final Integer i3 = Integer.valueOf(3); [EOL]     final Integer i4 = Integer.valueOf(4); [EOL]     final Integer i5 = Integer.valueOf(5); [EOL]     assertTrue(i3.hashCode() == i3.hashCode()); [EOL]     assertTrue(i3.hashCode() == i4.hashCode()); [EOL]     assertFalse(i3.hashCode() == i5.hashCode()); [EOL]     assertFalse(i3.hashCode() == i6.hashCode()); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final IDKey key = new IDKey(0); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(key); [EOL]     final IDKey deserializedKey = (IDKey) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(key, deserializedKey); [EOL]     assertEquals(key.hashCode(), deserializedKey.hashCode()); [EOL] }
@Test [EOL] public void testDoubleArrayAsObject() { [EOL]     final double[] obj = new double[2]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[0] = 5.4d; [EOL]     final long l1 = Double.doubleToLongBits(5.4d); [EOL]     final int h1 = (int) (l1 ^ l1 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[1] = 6.3d; [EOL]     final long l2 = Double.doubleToLongBits(6.3d); [EOL]     final int h2 = (int) (l2 ^ l2 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL] }
@Test [EOL] public void testIsRegistered() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     final long[][] array3 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(array1)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array2)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     final Object[] array4 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(HashCodeBuilder.isRegistered(arrayA)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayB)); [EOL]     assertTrue(HashCodeBuilder.isRegistered(arrayC)); [EOL]     final Object[] arrayD = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayD)); [EOL] }
@Test [EOL] public void testConstructorEx2() { [EOL]     final HashCodeBuilder hcb = new HashCodeBuilder(2, 2); [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL
@Test [EOL] public void testUnregister() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(array1)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     assertTrue(HashCodeBuilder.isRegistered(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(HashCodeBuilder.isRegistered(arrayB)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayB)); [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayC)); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testIDKey() { [EOL]     final Object value = new Object(); [EOL]     final IDKey key = new IDKey(value); [EOL]     assertEquals(value, key.getID()); [EOL]     assertSame(value, key.getValue()); [EOL]     assertSame(System.identityHashCode(value), key.hashCode()); [EOL] }
@Test [EOL] public void testConstructorEx2() { [EOL]     final HashCodeBuilder hcb = new HashCodeBuilder(2, 2); [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL
@Test [EOL] public void testSerialization() { [EOL]     final IDKey key = new IDKey(0); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(key); [EOL]     final IDKey deserializedKey = (IDKey) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(key, deserializedKey); [EOL]     assertEquals(key.hashCode(), deserializedKey.hashCode()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final Integer i3 = Integer.valueOf(3); [EOL]     final Integer i4 = Integer.valueOf(4); [EOL]     final Integer i5 = Integer.valueOf(5); [EOL]     assertTrue(i3.hashCode() == i3.hashCode()); [EOL]     assertTrue(i3.hashCode() == i4.hashCode()); [EOL]     assertFalse(i3.hashCode() == i5.hashCode()); [EOL]     assertFalse(i3.hashCode() == i6.hashCode()); [EOL] }
@Test [EOL] public void testDoubleArrayAsObject() { [EOL]     final double[] obj = new double[2]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[0] = 5.4d; [EOL]     final long l1 = Double.doubleToLongBits(5.4d); [EOL]     final int h1 = (int) (l1 ^ l1 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     obj[1] = 6.3d; [EOL]     final long l2 = Double.doubleToLongBits(6.3d); [EOL]     final int h2 = (int) (l2 ^ l2 >> 32); [EOL]     assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testToHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.toHashCode(array1) == ArrayUtils.toHashCode(array1)); [EOL]     assertFalse(ArrayUtils.toHashCode(array1) == ArrayUtils.toHashCode(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertTrue(ArrayUtils.toHashCode(array3) == ArrayUtils.toHashCode(array3)); [EOL]     assertTrue(ArrayUtils.toHashCode(array3) == ArrayUtils.toHashCode(array4)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.toHashCode(arrayB) == ArrayUtils.toHashCode(arrayA)); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testConstructorEx2() { [EOL]     final HashCodeBuilder hcb = new HashCodeBuilder(2, 2); [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL
@Test [EOL] public void testHashCodeBuilder() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.hashCode(arrayB) == ArrayUtils.hashCode(arrayC)); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); [EOL]     assertFalse(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayD = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(arrayB)); [EOL]     assertTrue(ArrayUtils.hashCode(arrayD) == ArrayUtils.hashCode(arrayC)); [EOL] }
@Test [EOL] public void testBooleanMultiArray() { [EOL]     final boolean[][] obj = new boolean[2][]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[0]; [EOL]     assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[1]; [EOL]     assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[2]; [EOL]     assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0][0] = true; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[1] = new boolean[1]; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); [EOL]     assertFalse(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); [EOL]     assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.hashCode(arrayB) == ArrayUtils.hashCode(arrayA)); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testSerialization() { [EOL]     final IDKey key = new IDKey(123); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(key); [EOL]     final IDKey deserializedKey = (IDKey) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(key, deserializedKey); [EOL]     assertEquals(key.hashCode(), deserializedKey.hashCode()); [EOL] }
@Test [EOL] public void testToHashCode() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertTrue(ArrayUtils.toHashCode(array1) == ArrayUtils.toHashCode(array1)); [EOL]     assertTrue(ArrayUtils.toHashCode(array1) == ArrayUtils.toHashCode(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertTrue(ArrayUtils.toHashCode(array3) == ArrayUtils.toHashCode(array3)); [EOL]     assertTrue(ArrayUtils.toHashCode(array3) == ArrayUtils.toHashCode(array4)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(ArrayUtils.toHashCode(arrayB) == ArrayUtils.toHashCode(arrayA)); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     a.hashCode(); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testUnregister() { [EOL]     final long[][] array1 = new long[][] { { 2, 5 }, { 4, 5 } }; [EOL]     final long[][] array2 = new long[][] { { 2, 5 }, { 4, 6 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(array1)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array2)); [EOL]     final Object[] array3 = new Object[] { new String(new char[] { 'A', 'B' }) }; [EOL]     final Object[] array4 = new Object[] { "AB" }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(array3)); [EOL]     assertTrue(HashCodeBuilder.isRegistered(array3)); [EOL]     final Object[] arrayA = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     final Object[] arrayB = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertTrue(HashCodeBuilder.isRegistered(arrayB)); [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayB)); [EOL]     final Object[] arrayC = new Object[] { new boolean[] { true, false }, new int[] { 6, 7 } }; [EOL]     assertFalse(HashCodeBuilder.isRegistered(arrayC)); [EOL] }
@Test [EOL] public void testBooleanMultiArray() { [EOL]     final boolean[][] obj = new boolean[2][]; [EOL]     assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[0]; [EOL]     assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[1]; [EOL]     assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0] = new boolean[2]; [EOL]     assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[0][0] = true; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     obj[1] = new boolean[1]; [EOL]     assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testConstructorEx2() { [EOL]     final HashCodeBuilder hcb = new HashCodeBuilder(2, 2); [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         hcb.hashCode(); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL]     b.hashCode(); [EOL]     assertNull(HashCodeBuilder.getRegistry()); [EOL] }
@Test [EOL] public void testIndexOfIgnoreCase_StringInt() { [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", -1)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 1)); [EOL]     assertEquals(0, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 2)); [EOL]     assertEquals(2, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 3)); [EOL]     assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 4)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 5)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 6)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 7)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 8)); [EOL]     assertEquals(1, StringUtils.indexOfIgnoreCase("aab", "AB", 1)); [EOL]     assertEquals(5, StringUtils.indexOfIgnoreCase("aabaabaa", "", 5)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("ab", "AAB", 0)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aab", "AAB", 1)); [EOL] }
@Test [EOL] public void testIndexOfIgnoreCase_StringInt() { [EOL]     assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", -1)); [EOL]     assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0)); [EOL]     assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 1)); [EOL]     assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 2)); [EOL]     assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 3)); [EOL]     assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 4)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 5)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 6)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 7)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 8)); [EOL]     assertEquals(1, StringUtils.indexOfIgnoreCase("aab", "AB", 1)); [EOL]     assertEquals(5, StringUtils.indexOfIgnoreCase("aabaabaa", "", 5)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("ab", "AAB", 0)); [EOL]     assertEquals(-1, StringUtils.indexOfIgnoreCase("aab", "AAB", 1)); [EOL] }
@Test [EOL] public void testNullToEmptyShortObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Short[]) null)); [EOL]     final Short[] original = new Short[] { 1, 2 }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Short[] empty = new Short[] {}; [EOL]     final Short[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testNullToEmptyShortObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Short[]) null)); [EOL]     final Short[] original = new Short[] { 1, 2 }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Short[] empty = new Short[] {}; [EOL]     final Short[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testNullToEmptyShortObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Short[]) null)); [EOL]     final Short[] original = new Short[] { 1, 2 }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Short[] empty = new Short[] {}; [EOL]     final Short[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetImplicitLowerBounds() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Type[] typeVarAssigns = TypeUtils.getImplicitLowerBounds(iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns[0]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[1], typeVarAssigns[1]); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetImplicitUpperBounds() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Type[] typeVarAssigns = TypeUtils.getImplicitUpperBounds(iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns[0]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[1], typeVarAssigns[1]); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetImplicitUpperBounds() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Type[] typeVarAssigns = TypeUtils.getImplicitUpperBounds(iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignableTypeVariable(iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]     final Type[] types = method.getGenericParameterTypes(); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[1]; [EOL]     Assert.assertTrue(TypeUtils.isAssignable(types[0], treeSetTypeVar)); [EOL]     Assert.assertTrue(TypeUtils.isAssignable(types[1], treeSetTypeVar)); [EOL]     Assert.assertTrue(TypeUtils.isAssignable(types[2], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[3], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[4], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[5], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[6], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[7], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[8], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[9], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[10], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[11], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[12], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types[13], treeSetTypeVar)); [EOL]     Assert.assertFalse(TypeUtils.isAssignable(types
@Test [EOL] public void testGetImplicitLowerBounds() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Type[] typeVarAssigns = TypeUtils.getImplicitLowerBounds(iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns[0]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[1], typeVarAssigns[1]); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]     final Type[] types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(types.length == 2); [EOL]     Assert.assertEquals(treeSetTypeVar, types[0]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[1]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[2]); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[1]; [EOL]     Assert.assertTrue(types.length == 3); [EOL]     Assert.assertEquals(treeSetTypeVar, types[3]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[4]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[5]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[6]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[7]); [EOL]     Assert.assertEquals(types[8], types[9]); [EOL]     Assert.assertEquals(types[10], types[11]); [EOL]     Assert.assertEquals(types[12], types[13]); [EOL]     Assert.assertEquals(types[13], types[14]); [EOL]     Assert.assertEquals(types[14], types[15]); [EOL]     Assert.assertEquals(types[15], types[16]); [EOL]     Assert.assertEquals(types[16], types[17]); [EOL]     Assert.assertEquals(types[17], types[18]); [EOL]     Assert.assertEquals(types[18], types[19]); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetImplicitUpperBounds() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Type[] typeVarAssigns = TypeUtils.getImplicitUpperBounds(iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns[0]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[1], typeVarAssigns[1]); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetImplicitLowerBounds() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Type[] typeVarAssigns = TypeUtils.getImplicitLowerBounds(iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns[0]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[1], typeVarAssigns[1]); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final Type iterableType = (Type) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(iterableType, (TypeVariable<?>) null); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]     final Type[] types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(types.length == types.length); [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         Assert.assertEquals(types[i], treeSetTypeVar); [EOL]     } [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[1]; [EOL]     Assert.assertTrue(types.length == treeSetTypeVar.length); [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         Assert.assertEquals(types[i], treeSetTypeVar[i]); [EOL]     } [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[2]; [EOL]     Assert.assertTrue(types.length == treeSetTypeVar.length); [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         Assert.assertEquals(types[i], treeSetTypeVar[i]); [EOL]     } [EOL]     final Type[] types2 = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes(); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[1]; [EOL]     Assert.assertTrue(types.length == treeSetTypeVar.length); [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         Assert.assertEquals(types[i], treeSetTypeVar[i]); [EOL]     } [EOL]     final Type[] types
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getAssignable(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetRawTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable_TypeVariable() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void test_isAssignable() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeVarAssigns(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testUnrollVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testGetTypeArguments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.getTypeArguments(TreeSet.class, iterableType); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testNullToEmptyByteObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null)); [EOL]     final Byte[] original = new Byte[] { 2, 3 }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Byte[] empty = new Byte[] {}; [EOL]     final Byte[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testNullToEmptyByteObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null)); [EOL]     final Byte[] original = new Byte[] { 2, 3 }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Byte[] empty = new Byte[] {}; [EOL]     final Byte[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testNullToEmptyByteObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null)); [EOL]     final Byte[] original = new Byte[] { 2, 6 }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Byte[] empty = new Byte[] {}; [EOL]     final Byte[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testMidStringIntInt() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(1, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(0, 1)); [EOL]     assertEquals("", sb.midString(1, 2)); [EOL]     assertEquals("", sb.midString(2, -1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(0, 20)); [EOL]     assertEquals("", sb.midString(-1, 20)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL] }
@Test [EOL] public void testMidStringIntInt() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(1, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(0, 1)); [EOL]     assertEquals("", sb.midString(1, 2)); [EOL]     assertEquals("", sb.midString(2, -1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(0, 20)); [EOL]     assertEquals("", sb.midString(-1, 20)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL] }
@Test [EOL] public void testMidStringIntInt() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(1, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(0, 1)); [EOL]     assertEquals("", sb.midString(1, 2)); [EOL]     assertEquals("", sb.midString(2, -1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(0, 20)); [EOL]     assertEquals("", sb.midString(-1, 20)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL] }
@Test [EOL] public void testMidStringIntInt() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(1, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(0, 1)); [EOL]     assertEquals("", sb.midString(1, 2)); [EOL]     assertEquals("", sb.midString(2, -1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(5, 4)); [EOL]     assertEquals("a", sb.midString(6, -1)); [EOL]     assertEquals("ab", sb.midString(6, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(-1, 1)); [EOL] }
@Test [EOL] public void testMidStringIntInt() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(1, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(0, 1)); [EOL]     assertEquals("", sb.midString(1, 2)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(0, 4)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 2)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL] }
@Test [EOL] public void testMidStringIntInt() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(1, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(0, 1)); [EOL]     assertEquals("", sb.midString(1, 2)); [EOL]     assertEquals("", sb.midString(2, -1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("b", sb.midString(3, 2)); [EOL]     assertEquals("", sb.midString(-1, 1)); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 1000)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(1, 2)); [EOL]     assertEquals("", sb.midString(-1, 1)); [EOL]     assertEquals("", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(2, 2)); [EOL]     assertEquals("", sb.midString(4, 1)); [EOL]     assertEquals("", sb.midString(4, -1)); [EOL] }
@Test [EOL] public void testMidStringIntInt() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(1, 0)); [EOL]     assertEquals("", sb.midString(-1, 0)); [EOL]     assertEquals("", sb.midString(0, 1)); [EOL]     assertEquals("", sb.midString(1, 2)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(4, 1)); [EOL]     assertEquals("", sb.midString(0, -1)); [EOL]     assertEquals("", sb.midString(0, 0)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(1, 1)); [EOL]     assertEquals("b", sb.midString(2, 1)); [EOL]     assertEquals("", sb.midString(3, 1)); [EOL]     assertEquals("", sb.midString(-1, 2)); [EOL]     assertEquals("", sb.midString(4, 1)); [EOL]     assertEquals("", sb.midString(5, 4)); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] }
@Test [EOL] public void testIsAlphaSpace() { [EOL]     assertFalse(StringUtils.isAlphaSpace(null)); [EOL]     assertTrue(StringUtils.isAlphaSpace("")); [EOL]     assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]     assertFalse(StringUtils.isAlphaSpace("a")); [EOL]     assertFalse(StringUtils.isAlphaSpace("A")); [EOL]     assertFalse(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isAlphaSpace("ham kso")); [EOL]     assertTrue(StringUtils.isAlphaSpace("1")); [EOL]     assertTrue(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isAlphaSpace("_")); [EOL]     assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsAlphaSpace() { [EOL]     assertFalse(StringUtils.isAlphaSpace(null)); [EOL]     assertTrue(StringUtils.isAlphaSpace("")); [EOL]     assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]     assertFalse(StringUtils.isAlphaSpace("a")); [EOL]     assertFalse(StringUtils.isAlphaSpace("A")); [EOL]     assertFalse(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isAlphaSpace("ham kso")); [EOL]     assertTrue(StringUtils.isAlphaSpace("1")); [EOL]     assertTrue(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isAlphaSpace("_")); [EOL]     assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsAlphaSpace() { [EOL]     assertFalse(StringUtils.isAlphaSpace(null)); [EOL]     assertTrue(StringUtils.isAlphaSpace("")); [EOL]     assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]     assertFalse(StringUtils.isAlphaSpace("a")); [EOL]     assertFalse(StringUtils.isAlphaSpace("A")); [EOL]     assertFalse(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isAlphaSpace("ham kso")); [EOL]     assertTrue(StringUtils.isAlphaSpace("1")); [EOL]     assertTrue(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isAlphaSpace("_")); [EOL]     assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsAlphaSpace() { [EOL]     assertFalse(StringUtils.isAlphaSpace(null)); [EOL]     assertTrue(StringUtils.isAlphaSpace("")); [EOL]     assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]     assertFalse(StringUtils.isAlphaSpace("a")); [EOL]     assertFalse(StringUtils.isAlphaSpace("A")); [EOL]     assertFalse(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isAlphaSpace("ham kso")); [EOL]     assertTrue(StringUtils.isAlphaSpace("1")); [EOL]     assertTrue(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isAlphaSpace("_")); [EOL]     assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsAlphaSpace() { [EOL]     assertFalse(StringUtils.isAlphaSpace(null)); [EOL]     assertTrue(StringUtils.isAlphaSpace("")); [EOL]     assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]     assertFalse(StringUtils.isAlphaSpace("a")); [EOL]     assertFalse(StringUtils.isAlphaSpace("A")); [EOL]     assertFalse(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isAlphaSpace("ham kso")); [EOL]     assertTrue(StringUtils.isAlphaSpace("1")); [EOL]     assertTrue(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isAlphaSpace("_")); [EOL]     assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsAlphaSpace() { [EOL]     assertFalse(StringUtils.isAlphaSpace(null)); [EOL]     assertTrue(StringUtils.isAlphaSpace("")); [EOL]     assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]     assertFalse(StringUtils.isAlphaSpace("a")); [EOL]     assertFalse(StringUtils.isAlphaSpace("A")); [EOL]     assertFalse(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isAlphaSpace("ham kso")); [EOL]     assertTrue(StringUtils.isAlphaSpace("1")); [EOL]     assertTrue(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isAlphaSpace("_")); [EOL]     assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsAlphaSpace() { [EOL]     assertFalse(StringUtils.isAlphaSpace(null)); [EOL]     assertTrue(StringUtils.isAlphaSpace("")); [EOL]     assertTrue(StringUtils.isAlphaSpace(" ")); [EOL]     assertFalse(StringUtils.isAlphaSpace("a")); [EOL]     assertFalse(StringUtils.isAlphaSpace("A")); [EOL]     assertFalse(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isAlphaSpace("ham kso")); [EOL]     assertTrue(StringUtils.isAlphaSpace("1")); [EOL]     assertTrue(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isAlphaSpace("_")); [EOL]     assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); [EOL]     } catch (final StringIndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testIntToHexDigitMsb0() { [EOL]     assertEquals('0', Conversion.intToHexDigitMsb0(0)); [EOL]     assertEquals('1', Conversion.intToHexDigitMsb0(1)); [EOL]     assertEquals('2', Conversion.intToHexDigitMsb0(2)); [EOL]     assertEquals('3', Conversion.intToHexDigitMsb0(3)); [EOL]     assertEquals('4', Conversion.intToHexDigitMsb0(4)); [EOL]     assertEquals('5', Conversion.intToHexDigitMsb0(5)); [EOL]     assertEquals('6', Conversion.intToHexDigitMsb0(6)); [EOL]     assertEquals('7', Conversion.intToHexDigitMsb0(7)); [EOL]     assertEquals('8', Conversion.intToHexDigitMsb0(8)); [EOL]     assertEquals('9', Conversion.intToHexDigitMsb0(9)); [EOL]     assertEquals('a', Conversion.intToHexDigitMsb0(10)); [EOL]     assertEquals('b', Conversion.intToHexDigitMsb0(11)); [EOL]     assertEquals('c', Conversion.intToHexDigitMsb0(12)); [EOL]     assertEquals('d', Conversion.intToHexDigitMsb0(13)); [EOL]     assertEquals('e', Conversion.intToHexDigitMsb0(14)); [EOL]     assertEquals('f', Conversion.intToHexDigitMsb0(15)); [EOL]     try { [EOL]         Conversion.intToHexDigitMsb0(16); [EOL]         fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteAll_String() { [EOL]     StrBuilder sb = new StrBuilder("abcba"); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder(""); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteAll_String() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.deleteAll("a"); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder(""); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteAll_String() { [EOL]     StrBuilder sb = new StrBuilder("abcba"); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder(""); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteAll_String() { [EOL]     StrBuilder sb = new StrBuilder("abcba"); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder(""); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteAll_String() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.deleteAll("a"); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder(""); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteIntInt() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.delete(1, 2); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.delete(0, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000); [EOL]     assertEquals("", sb.toString()); [EOL]     try { [EOL]         sb.delete(1, 2); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.delete(-1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb = new StrBuilder("anything"); [EOL]     try { [EOL]         sb.delete(2, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteIntIntInt() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.delete(0, 1, 2); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.delete(1, 2, 1); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.delete(0, 1, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder("atext"); [EOL]     sb.delete(1, 1, 1); [EOL]     assertEquals("pet", sb.toString()); [EOL]     try { [EOL]         sb.delete(-1, 1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.delete(2, 1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb = new StrBuilder("anything"); [EOL]     try { [EOL]         sb.delete(4, -1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteAll_String() { [EOL]     StrBuilder sb = new StrBuilder("abcba"); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder(""); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteAll_String() { [EOL]     StrBuilder sb = new StrBuilder("abcba"); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("abcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bcba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("bba", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder(""); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDeleteIntInt() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.delete(0, 1, 2); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.delete(1, 2, 1); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.delete(0, 1, 2); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000, 1); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.delete(0, 1000, 2); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder("atext"); [EOL]     sb.delete(1, 1, 1); [EOL]     assertEquals("pet", sb.toString()); [EOL]     try { [EOL]         sb.delete(-1, 1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         sb.delete(2, 1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     sb = new StrBuilder("anything"); [EOL]     try { [EOL]         sb.delete(4, -1, 1); [EOL]         fail("Expected IndexOutOfBoundsException"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testDeleteAll_String() { [EOL]     StrBuilder sb = new StrBuilder("abc"); [EOL]     sb.deleteAll("a"); [EOL]     assertEquals("bc", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("b", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL]     sb = new StrBuilder(""); [EOL]     sb.deleteAll(""); [EOL]     assertEquals("", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testReplaceAll_String_String() { [EOL]     StrBuilder sb = new StrBuilder("abcbccba"); [EOL]     sb.replaceAll((String) null, null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll((String) null, "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", null); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("", "anything"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("x", "y"); [EOL]     assertEquals("abcbccba", sb.toString()); [EOL]     sb.replaceAll("a", "d"); [EOL]     assertEquals("dbcbccbd", sb.toString()); [EOL]     sb.replaceAll("d", null); [EOL]     assertEquals("bcbccb", sb.toString()); [EOL]     sb.replaceAll("cb", "-"); [EOL]     assertEquals("b-c-", sb.toString()); [EOL]     sb = new StrBuilder("abcba"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("axbxcxbxa", sb.toString()); [EOL]     sb = new StrBuilder("bb"); [EOL]     sb.replaceAll("b", "xbx"); [EOL]     assertEquals("xbxxbx", sb.toString()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testMultiLongArray() { [EOL]     final long[][] array1 = new long[2][2]; [EOL]     final long[][] array2 = new long[2][2]; [EOL]     for (int i = 0; i < array1.length; ++i) { [EOL]         for (int j = 0; j < array1[0].length; j++) { [EOL]             array1[i][j] = (i + 1) * (j + 1); [EOL]             array2[i][j] = (i + 1) * (j + 1); [EOL]         } [EOL]     } [EOL]     assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     array1[1][1] = 0; [EOL]     assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(null, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testMultiLongArray() { [EOL]     final long[][] array1 = new long[2][2]; [EOL]     final long[][] array2 = new long[2][2]; [EOL]     for (int i = 0; i < array1.length; ++i) { [EOL]         for (int j = 0; j < array1[0].length; j++) { [EOL]             array1[i][j] = (i + 1) * (j + 1); [EOL]             array2[i][j] = (i + 1) * (j + 1); [EOL]         } [EOL]     } [EOL]     assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     array1[1][1] = 0; [EOL]     assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArrayHiddenByObject() { [EOL]     final double[] array1 = new double[2]; [EOL]     array1[0] = 5; [EOL]     array1[1] = 6; [EOL]     final double[] array2 = new double[2]; [EOL]     array2[0] = 5; [EOL]     array2[1] = 6; [EOL]     final double[] array3 = new double[3]; [EOL]     array3[0] = 5; [EOL]     array3[1] = 6; [EOL]     array3[2] = 7; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj3).isEquals()); [EOL]     array1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj3).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArrayHiddenByObject() { [EOL]     final double[] array1 = new double[2]; [EOL]     array1[0] = 5; [EOL]     array1[1] = 6; [EOL]     final double[] array2 = new double[2]; [EOL]     array2[0] = 5; [EOL]     array2[1] = 6; [EOL]     final double[] array3 = new double[3]; [EOL]     array3[0] = 5; [EOL]     array3[1] = 6; [EOL]     array3[2] = 7; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj3).isEquals()); [EOL]     array1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj3).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArrayHiddenByObject() { [EOL]     final double[] array1 = new double[2]; [EOL]     array1[0] = 5; [EOL]     array1[1] = 6; [EOL]     final double[] array2 = new double[2]; [EOL]     array2[0] = 5; [EOL]     array2[1] = 6; [EOL]     final double[] array3 = new double[3]; [EOL]     array3[0] = 5; [EOL]     array3[1] = 6; [EOL]     array3[2] = 7; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj3).isEquals()); [EOL]     array1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj3).isEquals()); [EOL] }
@Test [EOL] public void testConstructor() { [EOL]     assertNotNull(new EqualsBuilder()); [EOL]     final Constructor<?>[] cons = EqualsBuilder.class.getDeclaredConstructors(); [EOL]     assertEquals(1, cons.length); [EOL]     assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]     assertTrue(Modifier.isPublic(EqualsBuilder.class.getModifiers())); [EOL]     assertFalse(Modifier.isFinal(EqualsBuilder.class.getModifiers())); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertFalse(new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertFalse(new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     o2.setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, this).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testSuper() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals()); [EOL]     assertFalse(new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals()); [EOL]     assertFalse(new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals()); [EOL]     assertFalse(new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testMultiLongArray() { [EOL]     final long[][] array1 = new long[2][2]; [EOL]     final long[][] array2 = new long[2][2]; [EOL]     for (int i = 0; i < array1.length; ++i) { [EOL]         for (int j = 0; j < array1[0].length; j++) { [EOL]             array1[i][j] = (i + 1) * (j + 1); [EOL]             array2[i][j] = (i + 1) * (j + 1); [EOL]         } [EOL]     } [EOL]     assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     array1[1][1] = 0; [EOL]     assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testDoubleArray() { [EOL]     double[] obj1 = new double[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     double[] obj2 = new double[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1[1] = 7; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj2 = null; [EOL]     assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     obj1 = null; [EOL]     assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL] }
@Test [EOL] public void testMultiLongArray() { [EOL]     final long[][] array1 = new long[2][2]; [EOL]     final long[][] array2 = new long[2][2]; [EOL]     for (int i = 0; i < array1.length; ++i) { [EOL]         for (int j = 0; j < array1[0].length; j++) { [EOL]             array1[i][j] = (i + 1) * (j + 1); [EOL]             array2[i][j] = (i + 1) * (j + 1); [EOL]         } [EOL]     } [EOL]     assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     array1[1][1] = 0; [EOL]     assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); [EOL]     assertFalse(new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertFalse(new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     o2.setA(6); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, this).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append(o1, null).isEquals()); [EOL]     assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); [EOL] }
@Test [EOL] public void testByteArray() { [EOL]     byte[] array = new byte[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testByteArray() { [EOL]     byte[] array = new byte[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testReflectionStatics() { [EOL]     final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testByteArray() { [EOL]     byte[] array = new byte[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testByteArray() { [EOL]     byte[] array = new byte[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testInheritedReflectionStatics() { [EOL]     final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testByteArray() { [EOL]     byte[] array = new byte[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testByte() { [EOL]     assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]     assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]     assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testByteArray() { [EOL]     byte[] array = new byte[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testByteArray() { [EOL]     byte[] array = new byte[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testByteArray() { [EOL]     byte[] array = new byte[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testReflectionStatics() { [EOL]     final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     assertEquals(this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL] }
@Test [EOL] public void testByte() { [EOL]     assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]     assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]     assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testToPrimitive_long_long() { [EOL]     final Long[] l = null; [EOL]     assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); [EOL]     assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999) }, 1))); [EOL]     assertTrue(Arrays.equals(new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }, ArrayUtils.toPrimitive(new Long[] { Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999) }, Long.MAX_VALUE))); [EOL] }
@Test [EOL] public void testCloneReset() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset(input); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertEquals("c", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testCloneNotSupportedException() { [EOL]     final Object notCloned = new StrTokenizer() { [EOL]  [EOL]         @Override [EOL]         Object cloneReset() throws CloneNotSupportedException { [EOL]             throw new CloneNotSupportedException("test"); [EOL]         } [EOL]     }.clone(); [EOL]     assertNull(notCloned); [EOL] }
@Test [EOL] public void testCSVSimple() { [EOL]     this.testCSV(CSV_SIMPLE_FIXTURE); [EOL] }
@Test [EOL] public void testCSVSimple() { [EOL]     this.testCSV(CSV_SIMPLE_FIXTURE); [EOL] }
@Test [EOL] public void testTSV() { [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE)); [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray())); [EOL] }
@Test [EOL] public void testCloneReset() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset(input); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testCSVSimple() { [EOL]     this.testCSV(CSV_SIMPLE_FIXTURE); [EOL] }
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testCSVSimple() { [EOL]     this.testCSV(CSV_SIMPLE_FIXTURE); [EOL] }
@Test [EOL] public void testTSV() { [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE)); [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray())); [EOL] }
@Test [EOL] public void testCSVSimple() { [EOL]     this.testCSV(CSV_SIMPLE_FIXTURE); [EOL] }
@Test [EOL] public void testTSV() { [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE)); [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray())); [EOL] }
@Test [EOL] public void testTSV() { [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE)); [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray())); [EOL] }
@Test [EOL] public void testTSV() { [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE)); [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray())); [EOL] }
@Test [EOL] public void testCloneReset() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset(input); [EOL]     assertEquals(input, tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testIteration() { [EOL]     final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]         tkn.previous(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.remove(); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("x"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("y"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("z"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testTSV() { [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE)); [EOL]     this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray())); [EOL] }
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testCloneReset() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset(input); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertEquals("c", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testCloneReset() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset(input); [EOL]     assertEquals(input, tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testIteration() { [EOL]     final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]         tkn.previous(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.remove(); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("x"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("y"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("z"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIteration() { [EOL]     final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]         tkn.previous(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasNext()); [EOL]     assertEquals("a", tkn.next()); [EOL]     try { [EOL]         tkn.remove(); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("x"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("y"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("z"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("a b c"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertTrue(tkn.hasNext()); [EOL]     assertEquals("b", tkn.next()); [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertFalse(tkn.hasNext()); [EOL]     try { [EOL]         tkn.next(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertFalse(tkn.hasNext()); [EOL]     try { [EOL]         tkn.next(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testCSVSimple() { [EOL]     this.testCSV(CSV_SIMPLE_FIXTURE); [EOL] }
@Test [EOL] public void testCSVSimple() { [EOL]     this.testCSV(CSV_SIMPLE_FIXTURE); [EOL] }
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testIteration() { [EOL]     final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]         tkn.previous(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasNext()); [EOL]     assertEquals("a", tkn.next()); [EOL]     try { [EOL]         tkn.remove(); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("x"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("y"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("z"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("a b c"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertTrue(tkn.hasNext()); [EOL]     assertEquals("b", tkn.next()); [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertFalse(tkn.hasNext()); [EOL]     try { [EOL]         tkn.next(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertFalse(tkn.hasNext()); [EOL]     try { [EOL]         tkn.next(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]
@Test [EOL] public void testIteration() { [EOL]     final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]         tkn.previous(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasNext()); [EOL]     assertEquals("a", tkn.next()); [EOL]     try { [EOL]         tkn.remove(); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("x"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("y"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("z"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("a b c"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertTrue(tkn.hasNext()); [EOL]     assertEquals("b", tkn.next()); [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertFalse(tkn.hasNext()); [EOL]     try { [EOL]         tkn.next(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertFalse(tkn.hasNext()); [EOL]     try { [EOL]         tkn.next(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]
@Test [EOL] public void testIteration() { [EOL]     final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]         tkn.previous(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasNext()); [EOL]     assertEquals("a", tkn.next()); [EOL]     try { [EOL]         tkn.remove(); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("x"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("y"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("z"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("a b c"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertTrue(tkn.hasNext()); [EOL]     assertEquals("b", tkn.next()); [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertFalse(tkn.hasNext()); [EOL]     try { [EOL]         tkn.next(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertTrue(tkn.hasPrevious()); [EOL]     assertFalse(tkn.hasNext()); [EOL]     try { [EOL]         tkn.next(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]
@Test [EOL] public void testIteration() { [EOL]     final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]     assertFalse(tkn.hasPrevious()); [EOL]     try { [EOL]         tkn.previous(); [EOL]         fail(); [EOL]     } catch (final NoSuchElementException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.remove(); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("x"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("y"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL]     try { [EOL]         tkn.add("z"); [EOL]         fail(); [EOL]     } catch (final UnsupportedOperationException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testReset_String() { [EOL]     final String input = "a   b c \"d e\" f "; [EOL]     StrTokenizer tok = new StrTokenizer(input); [EOL]     tok.reset("d e"); [EOL]     assertEquals("d", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok.reset((String) null); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testHexToInt() { [EOL]     final String src = "CDF1F0C10F12345678"; [EOL]     assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x1C0F1FDCL, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]     assertEquals(0x01C0F1FDL, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); [EOL]     assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 4, 3)); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DateParser parser1 = getInstance(YMD_SLASH); [EOL]     final DateParser parser2 = getInstance(YMD_SLASH); [EOL]     assertEquals(parser1, parser2); [EOL]     assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]     assertFalse(parser1.equals(new Object())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DateParser parser1 = getInstance(YMD_SLASH); [EOL]     final DateParser parser2 = getInstance(YMD_SLASH); [EOL]     assertEquals(parser1, parser2); [EOL]     assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]     assertFalse(parser1.equals(new Object())); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DateParser parser1 = getInstance(YMD_SLASH); [EOL]     final DateParser parser2 = getInstance(YMD_SLASH); [EOL]     assertEquals(parser1, parser2); [EOL]     assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]     assertFalse(parser1.equals(new Object())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final DateParser parser1 = getInstance(YMD_SLASH); [EOL]     final DateParser parser2 = getInstance(YMD_SLASH); [EOL]     assertEquals(parser1, parser2); [EOL]     assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]     assertFalse(parser1.equals(new Object())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testTimeDateDefaults() { [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]     assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testJoin_IterableChar() { [EOL]     assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); [EOL]     assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); [EOL]     assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); [EOL] }
@Test [EOL] public void testBasicQuotedTrimmed1() { [EOL]     final String input = "a: 'b' :"; [EOL]     final StrTokenizer tok = new StrTokenizer(input, ':', '\''); [EOL]     tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]     tok.setIgnoreEmptyTokens(false); [EOL]     tok.setEmptyTokenAsNull(true); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertEquals(null, tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testBasicQuotedTrimmed1() { [EOL]     final String input = "a: 'b' :"; [EOL]     final StrTokenizer tok = new StrTokenizer(input, ':', '\''); [EOL]     tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]     tok.setIgnoreEmptyTokens(false); [EOL]     tok.setEmptyTokenAsNull(true); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertEquals(null, tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testConstructor_String_charArray_char_char() { [EOL]     StrTokenizer tok = new StrTokenizer("a b".toCharArray(), ' ', '"'); [EOL]     assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1)); [EOL]     assertEquals(1, tok.getQuoteMatcher().isMatch("\"".toCharArray(), 0, 0, 1)); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok = new StrTokenizer(new char[0], ' ', '"'); [EOL]     assertFalse(tok.hasNext()); [EOL]     tok = new StrTokenizer((String) null, ' ', '"'); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testBasicQuotedTrimmed1() { [EOL]     final String input = "a: 'b' :"; [EOL]     final StrTokenizer tok = new StrTokenizer(input, ':', '\''); [EOL]     tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]     tok.setIgnoreEmptyTokens(false); [EOL]     tok.setEmptyTokenAsNull(true); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertEquals(null, tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testBasicQuotedTrimmed1() { [EOL]     final String input = "a: 'b' :"; [EOL]     final StrTokenizer tok = new StrTokenizer(input, ':', '\''); [EOL]     tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]     tok.setIgnoreEmptyTokens(false); [EOL]     tok.setEmptyTokenAsNull(true); [EOL]     assertEquals("a", tok.next()); [EOL]     assertEquals("b", tok.next()); [EOL]     assertEquals(null, tok.next()); [EOL]     assertFalse(tok.hasNext()); [EOL] }
@Test [EOL] public void testAppendWithSeparators_Iterator() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     sb.appendWithSeparators((Iterator<?>) null, ","); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ","); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", "bar", "baz" }).iterator(), ","); [EOL]     assertEquals("foo,bar,baz", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", "bar", "baz" }).iterator(), null); [EOL]     assertEquals("foobarbaz", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", null, "baz" }).iterator(), ","); [EOL]     assertEquals("foo,,baz", sb.toString()); [EOL] }
@Test [EOL] public void testAppendln_String_Object() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final String str) { [EOL]             count[0]++; [EOL]             return super.append(str); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln("foo", "bar"); [EOL]     assertEquals("foo" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testAppendln_String_int_int() { [EOL]     final int[] count = new int[2]; [EOL]     final StrBuilder sb = new StrBuilder() { [EOL]  [EOL]         @Override [EOL]         public StrBuilder append(final String str, final int startIndex, final int length) { [EOL]             count[0]++; [EOL]             return super.append(str, startIndex, length); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public StrBuilder appendNewLine() { [EOL]             count[1]++; [EOL]             return super.appendNewLine(); [EOL]         } [EOL]     }; [EOL]     sb.appendln("foo", 0, 3); [EOL]     assertEquals("foo" + SEP, sb.toString()); [EOL]     assertEquals(1, count[0]); [EOL]     assertEquals(1, count[1]); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("[-25,50]", longRange.toString(new String[] { "25", "50" })); [EOL]     assertEquals("-30,50]", floatRange.toString(new String[] { "-30", "50" })); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("[-25,50]", longRange.toString(new String[] { "25", "50" })); [EOL]     assertEquals("-30,50]", floatRange.toString(new String[] { "-30", "50" })); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[12,15]", intRange.toString("MM", null)); [EOL]     assertEquals("[12,15,20]", longRange.toString("MM", null)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", null)); [EOL]     assertEquals("[12,15,20,30]", longRange.toString("MM", null)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", null)); [EOL]     assertEquals("[12,15,20,30]", longRange.toString("MM", "15", 20)); [EOL]     assertEquals("[12,15,20,30]", longRange.toString("MM", "20", 30)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", "15", 20, 30)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", "20", 20, 30)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", "20", 20, 30)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", "20", 20, 30)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", "20", 20, 30)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", "20", 20, 30)); [EOL]     assertEquals("[12,15,20,30]", floatRange.toString("MM", "20", 20, 30)); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("-30,50]", longRange.toString(new String[] { "-30", "50" })); [EOL]     assertEquals("-40,50", doubleRange.toString(new String[] { "-40", "50" })); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("[-25,50]", longRange.toString(new String[] { "25", "50" })); [EOL]     assertEquals("-30,50]", floatRange.toString(new String[] { "-30", "50" })); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("-30,50]", longRange.toString(new String[] { "-30", "50" })); [EOL]     assertEquals("-40,50", doubleRange.toString(new String[] { "-40", "50" })); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("-30,50]", longRange.toString(new String[] { "-30", "50" })); [EOL]     assertEquals("-40,50", doubleRange.toString(new String[] { "-40", "50" })); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("[-25,50]", longRange.toString(new String[] { "25", "50" })); [EOL]     assertEquals("-30,50]", floatRange.toString(new String[] { "-30", "50" })); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-12,25]", intRange.toString(new String[] { "10", "25" })); [EOL]     assertEquals("[-12,25]", longRange.toString(new String[] { "10", "25" })); [EOL]     assertEquals("[-12,25]", floatRange.toString(new String[] { "10", "25" })); [EOL]     assertEquals("[-12,25]", longRange.toString(new String[] { "10", "25" })); [EOL]     assertEquals("[-12,25]", doubleRange.toString(new String[] { "10", "25" })); [EOL]     assertEquals("[-12,25]", doubleRange.toString(new String[] { "10", "25" })); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[10,15]", intRange.toString(new String[] { "10", "15" })); [EOL]     assertEquals("[10,15,20]", longRange.toString(new String[] { "10", "15", "20" })); [EOL]     assertEquals("[10,15,20,30]", floatRange.toString(new String[] { "10", "15", "20", "30" })); [EOL]     assertEquals("[10,15,20,30]", longRange.toString(new String[] { "10", "15", "20", "30" })); [EOL]     assertEquals("[10,15,20,30]", floatRange.toString(new String[] { "10", "15", "20", "30" })); [EOL]     assertEquals("[10,15,20,30]", longRange.toString(new String[] { "10", "15", "20", "30" })); [EOL]     assertEquals("[10,15,20,30]", longRange.toString(new String[] { "10", "15", "20", "30" })); [EOL]     assertEquals("[10,15,20,30]", longRange.toString(new String[] { "10", "15", "20", "30" })); [EOL]     assertEquals("[10,15,20,30]", floatRange.toString(new String[] { "10", "15", "20", "30" })); [EOL]     assertEquals("[10,15,20,30]", floatRange.toString(new String[] { "10", "15", "20", "30" })); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("[-25,50]", longRange.toString(new String[] { "25", "50" })); [EOL]     assertEquals("-30,50]", floatRange.toString(new String[] { "-30", "50" })); [EOL] }
@Test [EOL] public void testIntersectionWith() { [EOL]     assertSame(intRange, intRange.intersectionWith(intRange)); [EOL]     assertSame(byteRange, byteRange.intersectionWith(byteRange)); [EOL]     assertSame(longRange, longRange.intersectionWith(longRange)); [EOL]     assertSame(floatRange, floatRange.intersectionWith(floatRange)); [EOL]     assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); [EOL]     assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); [EOL] }
@Test [EOL] public void testToStringFormat() { [EOL]     assertEquals("[-10,50]", intRange.toString(new String[] { "10", "50" })); [EOL]     assertEquals("[-15,50]", longRange.toString(new String[] { "15", "50" })); [EOL]     assertEquals("[-20,50]", floatRange.toString(new String[] { "20", "50" })); [EOL]     assertEquals("[-25,50]", longRange.toString(new String[] { "25", "50" })); [EOL]     assertEquals("-30,50]", floatRange.toString(new String[] { "-30", "50" })); [EOL] }
@Test [EOL] public void testAsReader() throws Exception { [EOL]     final StrBuilder sb = new StrBuilder("some text"); [EOL]     Reader reader = sb.asReader(); [EOL]     assertTrue(reader.ready()); [EOL]     final char[] buf = new char[40]; [EOL]     assertEquals(9, reader.read(buf)); [EOL]     assertEquals("some text", new String(buf, 0, 9)); [EOL]     assertEquals(-1, reader.read()); [EOL]     assertFalse(reader.ready()); [EOL]     assertEquals(0, reader.skip(2)); [EOL]     assertEquals(0, reader.skip(-1)); [EOL]     assertTrue(reader.markSupported()); [EOL]     reader = sb.asReader(); [EOL]     assertEquals('s', reader.read()); [EOL]     reader.mark(-1); [EOL]     char[] array = new char[3]; [EOL]     assertEquals(3, reader.read(array, 0, 3)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('m', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     reader.reset(); [EOL]     assertEquals(1, reader.read(array, 1, 1)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('o', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     assertEquals(2, reader.skip(2)); [EOL]     assertEquals(' ', reader.read()); [EOL]     assertTrue(reader.ready()); [EOL]     reader.close(); [EOL]     assertTrue(reader.ready()); [EOL]     reader = sb.asReader(); [EOL]     array = new char[3]; [EOL]     try { [EOL]         reader.read(array, -1, 0); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex) { [EOL]     } [EOL]     try { [EOL]         reader.read(array, 0, -1); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex
@Test [EOL] public void testAsReader() throws Exception { [EOL]     final StrBuilder sb = new StrBuilder("some text"); [EOL]     Reader reader = sb.asReader(); [EOL]     assertTrue(reader.ready()); [EOL]     final char[] buf = new char[40]; [EOL]     assertEquals(9, reader.read(buf)); [EOL]     assertEquals("some text", new String(buf, 0, 9)); [EOL]     assertEquals(-1, reader.read()); [EOL]     assertFalse(reader.ready()); [EOL]     assertEquals(0, reader.skip(2)); [EOL]     assertEquals(0, reader.skip(-1)); [EOL]     assertTrue(reader.markSupported()); [EOL]     reader = sb.asReader(); [EOL]     assertEquals('s', reader.read()); [EOL]     reader.mark(-1); [EOL]     char[] array = new char[3]; [EOL]     assertEquals(3, reader.read(array, 0, 3)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('m', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     reader.reset(); [EOL]     assertEquals(1, reader.read(array, 1, 1)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('o', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     assertEquals(2, reader.skip(2)); [EOL]     assertEquals(' ', reader.read()); [EOL]     assertTrue(reader.ready()); [EOL]     reader.close(); [EOL]     assertTrue(reader.ready()); [EOL]     reader = sb.asReader(); [EOL]     array = new char[3]; [EOL]     try { [EOL]         reader.read(array, -1, 0); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex) { [EOL]     } [EOL]     try { [EOL]         reader.read(array, 0, -1); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex
@Test [EOL] public void testAsReader() throws Exception { [EOL]     final StrBuilder sb = new StrBuilder("some text"); [EOL]     Reader reader = sb.asReader(); [EOL]     assertTrue(reader.ready()); [EOL]     final char[] buf = new char[40]; [EOL]     assertEquals(9, reader.read(buf)); [EOL]     assertEquals("some text", new String(buf, 0, 9)); [EOL]     assertEquals(-1, reader.read()); [EOL]     assertFalse(reader.ready()); [EOL]     assertEquals(0, reader.skip(2)); [EOL]     assertEquals(0, reader.skip(-1)); [EOL]     assertTrue(reader.markSupported()); [EOL]     reader = sb.asReader(); [EOL]     assertEquals('s', reader.read()); [EOL]     reader.mark(-1); [EOL]     char[] array = new char[3]; [EOL]     assertEquals(3, reader.read(array, 0, 3)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('m', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     reader.reset(); [EOL]     assertEquals(1, reader.read(array, 1, 1)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('o', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     assertEquals(2, reader.skip(2)); [EOL]     assertEquals(' ', reader.read()); [EOL]     assertTrue(reader.ready()); [EOL]     reader.close(); [EOL]     assertTrue(reader.ready()); [EOL]     reader = sb.asReader(); [EOL]     array = new char[3]; [EOL]     try { [EOL]         reader.read(array, -1, 0); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex) { [EOL]     } [EOL]     try { [EOL]         reader.read(array, 0, -1); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex
@Test [EOL] public void testAsReader() throws Exception { [EOL]     final StrBuilder sb = new StrBuilder("some text"); [EOL]     Reader reader = sb.asReader(); [EOL]     assertTrue(reader.ready()); [EOL]     final char[] buf = new char[40]; [EOL]     assertEquals(9, reader.read(buf)); [EOL]     assertEquals("some text", new String(buf, 0, 9)); [EOL]     assertEquals(-1, reader.read()); [EOL]     assertFalse(reader.ready()); [EOL]     assertEquals(0, reader.skip(2)); [EOL]     assertEquals(0, reader.skip(-1)); [EOL]     assertTrue(reader.markSupported()); [EOL]     reader = sb.asReader(); [EOL]     assertEquals('s', reader.read()); [EOL]     reader.mark(-1); [EOL]     char[] array = new char[3]; [EOL]     assertEquals(3, reader.read(array, 0, 3)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('m', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     reader.reset(); [EOL]     assertEquals(1, reader.read(array, 1, 1)); [EOL]     assertEquals('o', array[0]); [EOL]     assertEquals('o', array[1]); [EOL]     assertEquals('e', array[2]); [EOL]     assertEquals(2, reader.skip(2)); [EOL]     assertEquals(' ', reader.read()); [EOL]     assertTrue(reader.ready()); [EOL]     reader.close(); [EOL]     assertTrue(reader.ready()); [EOL]     reader = sb.asReader(); [EOL]     array = new char[3]; [EOL]     try { [EOL]         reader.read(array, -1, 0); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex) { [EOL]     } [EOL]     try { [EOL]         reader.read(array, 0, -1); [EOL]         fail(); [EOL]     } catch (final IndexOutOfBoundsException ex
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.0")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.0")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("0.0")); [EOL]     assertEquals(null, JAVAVersion.get("1.0")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("1.8
@Test [EOL] public void testGetJavaVersion() { [EOL]     assertEquals("1.2", JAVA_1_2, getJavaVersion("1.2")); [EOL]     assertEquals("1.5", JAVA_1_6, getJavaVersion("1.5")); [EOL]     assertEquals("1.6", JAVA_1_7, getJavaVersion("1.6")); [EOL]     assertEquals("1.7", JAVA_1_8, getJavaVersion("1.7")); [EOL]     assertEquals("1.8", JAVA_1_9, getJavaVersion("1.8")); [EOL]     assertEquals("1.9", JAVA_1_10, getJavaVersion("1.9")); [EOL]     assertEquals("1.0", JAVA_1_11, getJavaVersion("1.0")); [EOL]     assertEquals("1.1", JAVA_1_12, getJavaVersion("1.1")); [EOL]     assertEquals("1.2", JAVA_1_6, getJavaVersion("1.2")); [EOL]     assertEquals("1.3", JAVA_1_7, getJavaVersion("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, getJavaVersion("1.5")); [EOL]     assertEquals("1.6", JAVA_1_7, getJavaVersion("1.6")); [EOL] }
@Test [EOL] public void testGetJavaVersion() { [EOL]     assertEquals("1.2", JAVA_1_2, getJavaVersion("1.2")); [EOL]     assertEquals("1.2", JAVA_1_3, getJavaVersion("1.2")); [EOL]     assertEquals("1.2", JAVA_1_4, getJavaVersion("1.2")); [EOL]     assertEquals("1.3", JAVA_1_5, getJavaVersion("1.3")); [EOL]     assertEquals("1.6", JAVA_1_6, getJavaVersion("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, getJavaVersion("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, getJavaVersion("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, getJavaVersion("1.9")); [EOL]     assertEquals("1.10", JAVA_1_10, getJavaVersion("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, getJavaVersion("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, getJavaVersion("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, getJavaVersion("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, getJavaVersion("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, getJavaVersion("1.15")); [EOL]     assertEquals("1.16", JAVA_1_16, getJavaVersion("1.16")); [EOL]     assertEquals("1.17", JAVA_1_17, getJavaVersion("1.17")); [EOL] }
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("1.10")); [EOL]     assertEquals(null, JAVAVersion.get("1.10")); [EOL]     assertEquals(null, JAVAVersion.get("1.11")); [EOL]     assertEquals(null, JAVAVersion.get("1.11")); [EOL]     assertEquals(null, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_8, JAVAVersion.get("1.10")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.11")); [EOL]     assertEquals(JAVA_7, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("1.10")); [EOL]     assertEquals(null, JAVAVersion.get("1.11")); [EOL]     assertEquals(null, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_8, JAVAVersion.get("1.10")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.11")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("1.10")); [EOL]     assertEquals(null, JAVAVersion.get("1.11")); [EOL]     assertEquals(null, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_8, JAVAVersion.get("1.10")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.11")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("1.10")); [EOL]     assertEquals(null, JAVAVersion.get("1.11")); [EOL]     assertEquals(null, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_8, JAVAVersion.get("1.10")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.11")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("1.10")); [EOL]     assertEquals(null, JAVAVersion.get("1.11")); [EOL]     assertEquals(null, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_8, JAVAVersion.get("1.10")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.11")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals(null, JAVAVersion.get("1.15")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals(null, JAVAVersion.get("1.15")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals(null, JAVAVersion.get("1.15")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals(null, JAVAVersion.get("1.15")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_8, JAVAVersion.get("1.10")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.11")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("1.10")); [EOL]     assertEquals(null, JAVAVersion.get("1.11")); [EOL]     assertEquals(null, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_8, JAVAVersion.get("1.10")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.11")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(null, JAVAVersion.get("1.10")); [EOL]     assertEquals(null, JAVAVersion.get("1.11")); [EOL]     assertEquals(null, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testGet() { [EOL]     assertEquals(JAVA_0_9, JAVAVersion.get("0.9")); [EOL]     assertEquals(JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals(JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals(JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals(JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals(JAVA_1_5, JAVAVersion.get("1.5")); [EOL]     assertEquals(JAVA_1_6, JAVAVersion.get("1.6")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals(null, JAVAVersion.get("1.8")); [EOL]     assertEquals(null, JAVAVersion.get("1.9")); [EOL]     assertEquals(JAVA_1_8, JAVAVersion.get("1.10")); [EOL]     assertEquals(JAVA_1_9, JAVAVersion.get("1.11")); [EOL]     assertEquals(JAVA_1_7, JAVAVersion.get("1.12")); [EOL]     assertEquals(null, JAVAVersion.get("1.13")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals(null, JAVAVersion.get("1.15")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals(null, JAVAVersion.get("1.15")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals(null, JAVAVersion.get("1.15")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals(null, JAVAVersion.get("1.15")); [EOL]     assertEquals(null, JAVAVersion.get("1.14")); [EOL]     assertEquals
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.1", JAVA_1_1, JAVAVersion.get("1.1")); [EOL]     assertEquals("1.2", JAVA_1_2, JAVAVersion.get("1.2")); [EOL]     assertEquals("1.3", JAVA_1_3, JAVAVersion.get("1.3")); [EOL]     assertEquals("1.4", JAVA_1_4, JAVAVersion.get("1.4")); [EOL]     assertEquals("1.5", JAVA_1_5, JAVAVersion.get("1.6")); [EOL]     assertEquals("1.7", JAVA_1_7, JAVAVersion.get("1.7")); [EOL]     assertEquals("1.8", JAVA_1_8, JAVAVersion.get("1.8")); [EOL]     assertEquals("1.9", JAVA_1_9, JAVAVersion.get("1.9")); [EOL]     assertEquals("1.10", JAVA_1_5, JAVAVersion.get("1.10")); [EOL]     assertEquals("1.11", JAVA_1_11, JAVAVersion.get("1.11")); [EOL]     assertEquals("1.12", JAVA_1_12, JAVAVersion.get("1.12")); [EOL]     assertEquals("1.13", JAVA_1_13, JAVAVersion.get("1.13")); [EOL]     assertEquals("1.14", JAVA_1_14, JAVA_Version.get("1.14")); [EOL]     assertEquals("1.15", JAVA_1_15, JAVA_Version.get("1.15")); [EOL]     assertEquals("1.14", JAVA_1_14,
@Test [EOL] public void testNullToEmptyLongObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Long[]) null)); [EOL]     final Long[] original = new Long[] { 1L, 2L }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Long[] empty = new Long[] {}; [EOL]     final Long[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testNullToEmptyLongObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Long[]) null)); [EOL]     final Long[] original = new Long[] { 1L, 2L }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Long[] empty = new Long[] {}; [EOL]     final Long[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testNullToEmptyLongObject() { [EOL]     assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Long[]) null)); [EOL]     final Long[] original = new Long[] { 1L, 2L }; [EOL]     assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]     final Long[] empty = new Long[] {}; [EOL]     final Long[] result = ArrayUtils.nullToEmpty(empty); [EOL]     assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, result); [EOL]     assertTrue(empty != result); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0); [EOL]     o2.setA(4); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, this).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0); [EOL]     o2.setA(6); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, this).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL] }
@Test(expected = ClassCastException.class) [EOL] public void testReflectionCompareEx2() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final Object o2 = new Object(); [EOL]     CompareToBuilder.reflectionCompare(o1, o2); [EOL] }
@Test(expected = ClassCastException.class) [EOL] public void testReflectionCompareEx2() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final Object o2 = new Object(); [EOL]     CompareToBuilder.reflectionCompare(o1, o2); [EOL] }
@Test(expected = ClassCastException.class) [EOL] public void testReflectionCompareEx2() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final Object o2 = new Object(); [EOL]     CompareToBuilder.reflectionCompare(o1, o2); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0); [EOL]     o2.setA(4); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, this).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     final TestObject o3 = new TestObject(6); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o3, o1).toComparison() > 0); [EOL]     o2.setA(5); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o2, o1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL] }
@Test(expected = ClassCastException.class) [EOL] public void testReflectionCompareEx2() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final Object o2 = new Object(); [EOL]     CompareToBuilder.reflectionCompare(o1, o2); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0); [EOL]     o2.setA(4); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, this).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL] }
@Test(expected = ClassCastException.class) [EOL] public void testReflectionCompareEx2() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final Object o2 = new Object(); [EOL]     CompareToBuilder.reflectionCompare(o1, o2); [EOL] }
@Test(expected = ClassCastException.class) [EOL] public void testReflectionCompareEx2() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final Object o2 = new Object(); [EOL]     CompareToBuilder.reflectionCompare(o1, o2); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL] }
@Test [EOL] public void testReflectionObjectCycle() { [EOL]     final ReflectionTestCycleA a = new ReflectionTestCycleA(); [EOL]     final ReflectionTestCycleB b = new ReflectionTestCycleB(); [EOL]     a.b = b; [EOL]     b.a = a; [EOL]     a.hashCode(); [EOL]     assertTrue(new CompareToBuilder().append(a).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(a).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(b).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(a).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(b).toComparison() > 0); [EOL]     a.hashCode(); [EOL]     assertTrue(new CompareToBuilder().append(a).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(b).toComparison() > 0); [EOL]     a.hashCode(); [EOL]     assertTrue(new CompareToBuilder().append(a).toComparison() < 0); [EOL] }
@Test [EOL] public void testReflectionAppend() { [EOL]     final TestObject o1 = new TestObject(4); [EOL]     final TestObject o2 = new TestObject(5); [EOL]     assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0); [EOL]     o2.setA(4); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, this).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); [EOL] }
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testRemoveElementByteArray() { [EOL]     byte[] array; [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]     assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]     assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEachRepeatedly(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", null), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[] { null }, new String[] { "b" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[] { "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[] { "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEachRepeatedly("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEachRepeatedly("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplaceEachRepeatedly_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEachRepeatedly(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[] { null }, new String[] { "b" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[] { "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[] { "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEachRepeatedly("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEachRepeatedly("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEachRepeatedly("d216.102oren", new String[] { "a", "b", "c", "d", "e",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "b" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL] }
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "c", "d" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("aba", new String[] { "ab", "d" }, new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("abc", new String[] { "d", "e", "f", "g" })); [EOL]     assertEquals("q651.506bera", StringUtils
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null }, new String[] { "b" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "wcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "
@Test [EOL] public void testReplace_StringStringArrayStringArray() { [EOL]     assertNull(StringUtils.replaceEach(null, new String[] { "a" }, new String[] { "b" })); [EOL]     assertEquals(StringUtils.replaceEach("", new String[] { "a" }, new String[] { "b" }), ""); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, null), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { null, "a" }, new String[] { "" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("aba", new String[] { "a" }, new String[] { "a" }), "aba"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "w", "t" }), "wcte"); [EOL]     assertEquals(StringUtils.replaceEach("abcde", new String[] { "ab", "d" }, new String[] { "d", "t" }), "dcte"); [EOL]     assertEquals("bcc", StringUtils.replaceEach("abc", new String[] { "a", "b" }, new String[] { "b", "c" })); [EOL]     assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testLexx() { [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx("yMdHmsS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]     assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testEdgeDurations() { [EOL]     assertEqualDuration("01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); [EOL]     assertEqualDuration("09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM"); [EOL]     assertEqualDuration("12 00", new int[] { 2006, 0, 1, 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testBugzilla38401() { [EOL]     assertEqualDuration("0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); [EOL] }
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testNotBlankMsgBlankStringShouldThrow() { [EOL]     final String string = " \n \t \r \n "; [EOL]     try { [EOL]         Validate.notBlank(string, "Message"); [EOL]         fail("Expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]         assertEquals("Message", e.getMessage()); [EOL]     } [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testCountMatches_StringString() { [EOL]     assertEquals(0, StringUtils.countMatches(null, null)); [EOL]     assertEquals(0, StringUtils.countMatches(null, "")); [EOL]     assertEquals(0, StringUtils.countMatches("", null)); [EOL]     assertEquals(0, StringUtils.countMatches("", "a")); [EOL]     assertEquals(0, StringUtils.countMatches("", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "a")); [EOL]     assertEquals(2, StringUtils.countMatches("hello", "ab")); [EOL]     assertEquals(1, StringUtils.countMatches("hello", "z")); [EOL] }
@Test [EOL] public void testBitField() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testBitFieldInt() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testSetByte() { [EOL]     assertEquals(bf_multi.setByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_single.setByte((byte) 0), (byte) 1); [EOL]     assertEquals(bf_zero.setByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_multi.clearByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_single.clearByte((byte) 1), (byte) 0); [EOL]     assertEquals(bf_zero.clearByte((byte) 0), (byte) 0); [EOL] }
@Test [EOL] public void testBitField() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testBitField() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testBitField() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testSetByteBoolean() { [EOL]     assertEquals(bf_multi.setByte(0), bf_multi.setByteBoolean((byte) 0, true)); [EOL]     assertEquals(bf_single.setByte(0), bf_single.setByteBoolean((byte) 0, true)); [EOL]     assertEquals(bf_zero.setByte((byte) 0), bf_zero.setByteBoolean((byte) 0, true)); [EOL]     assertEquals(bf_multi.clearByte((byte) 0), bf_multi.setByteBoolean((byte) 0, false)); [EOL]     assertEquals(bf_single.clearByte((byte) 0), bf_single.setByteBoolean((byte) 0, true)); [EOL]     assertEquals(bf_zero.clearByte((byte) 0), bf_zero.setByteBoolean((byte) 0, false)); [EOL] }
@Test [EOL] public void testBitField() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testSetByte() { [EOL]     assertEquals(bf_multi.setByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_single.setByte((byte) 0), (byte) 1); [EOL]     assertEquals(bf_zero.setByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_multi.clearByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_single.clearByte((byte) 1), (byte) 0); [EOL]     assertEquals(bf_zero.clearByte((byte) 0), (byte) 0); [EOL] }
@Test [EOL] public void testSetByte() { [EOL]     assertEquals(bf_multi.setByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_single.setByte((byte) 0), (byte) 1); [EOL]     assertEquals(bf_zero.setByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_multi.clearByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_single.clearByte((byte) 1), (byte) 0); [EOL]     assertEquals(bf_zero.clearByte((byte) -1), (byte) 0); [EOL] }
@Test [EOL] public void testBitFieldInt() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testSetByte() { [EOL]     assertEquals(bf_multi.setByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_single.setByte((byte) 0), (byte) 1); [EOL]     assertEquals(bf_zero.setByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_multi.clearByte((byte) 0), (byte) 0); [EOL]     assertEquals(bf_single.clearByte((byte) 1), (byte) 0); [EOL]     assertEquals(bf_zero.clearByte((byte) -1), (byte) 0); [EOL] }
@Test [EOL] public void testBitField() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testBitField() { [EOL]     assertEquals(bf_multi.set(0), bf_multi.set(0)); [EOL]     assertEquals(bf_single.set(0), bf_single.set(0)); [EOL]     assertEquals(bf_zero.set(0), bf_zero.set(0)); [EOL]     assertEquals(bf_multi.clear(-1), bf_multi.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_single.set(1)); [EOL]     assertEquals(bf_zero.clear(-1), bf_zero.set(0)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(1)); [EOL]     assertEquals(bf_single.clear(-1), bf_zero.set(-1)); [EOL] }
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void testHexDigitToBinary() { [EOL]     assertBinaryEquals(new boolean[] { false, false, false, false }, Conversion.hexDigitToBinary('0')); [EOL]     assertBinaryEquals(new boolean[] { false, false, false, true }, Conversion.hexDigitToBinary('1')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, false }, Conversion.hexDigitToBinary('2')); [EOL]     assertBinaryEquals(new boolean[] { false, false, true, true }, Conversion.hexDigitToBinary('3')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, false }, Conversion.hexDigitToBinary('4')); [EOL]     assertBinaryEquals(new boolean[] { false, true, false, true }, Conversion.hexDigitToBinary('5')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, false }, Conversion.hexDigitToBinary('6')); [EOL]     assertBinaryEquals(new boolean[] { false, true, true, true }, Conversion.hexDigitToBinary('7')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, false }, Conversion.hexDigitToBinary('8')); [EOL]     assertBinaryEquals(new boolean[] { true, false, false, true }, Conversion.hexDigitToBinary('9')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('A')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('a')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, false }, Conversion.hexDigitToBinary('B')); [EOL]     assertBinaryEquals(new boolean[] { true, false, true, true }, Conversion.hexDigitToBinary('b')); [EOL]     assertBinaryEquals(new boolean[] { true, true, false, false
@Test [EOL] public void test_getPackageName_Class() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class)); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getPackageName((Class<?>) null)); [EOL]     assertEquals("", ClassUtils.getPackageName(Map.Entry[].class)); [EOL] }
@Test [EOL] public void test_getPackageName_String() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class.getName())); [EOL]     assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getPackageName((String) null)); [EOL] }
@Test [EOL] public void test_getPackageName_Class() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class)); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getPackageName((Class<?>) null)); [EOL]     assertEquals("", ClassUtils.getPackageName(Map.Entry[].class)); [EOL] }
@Test [EOL] public void test_getPackageName_Class() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class)); [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getPackageName((Class<?>) null)); [EOL]     assertEquals("", ClassUtils.getPackageName(Map.Entry[].class)); [EOL] }
@Test [EOL] public void test_getPackageName_String() { [EOL]     assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class.getName())); [EOL]     assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getPackageName((String) null)); [EOL] }
@Test [EOL] public void testToIntValue_CharacterInt() { [EOL]     assertTrue(CharUtils.toIntValue(new Character('0'), 0) == 0); [EOL]     assertTrue(CharUtils.toIntValue(new Character('1'), 0) == 1); [EOL]     assertTrue(CharUtils.toIntValue(new Character('2'), 0) == 2); [EOL]     assertTrue(CharUtils.toIntValue(new Character('3'), 0) == 3); [EOL]     assertTrue(CharUtils.toIntValue(new Character('4'), 0) == 4); [EOL]     assertTrue(CharUtils.toIntValue(new Character('5'), 0) == 5); [EOL]     assertTrue(CharUtils.toIntValue(new Character('6'), 0) == 6); [EOL] }
@Test [EOL] public void testIsAsciiNumeric_char() { [EOL]     assertTrue(CharUtils.isAsciiNumeric('a')); [EOL]     assertFalse(CharUtils.isAsciiNumeric('A')); [EOL]     assertFalse(CharUtils.isAsciiNumeric('3')); [EOL]     assertFalse(CharUtils.isAsciiNumeric('-')); [EOL]     assertFalse(CharUtils.isAsciiNumeric('\n')); [EOL]     assertFalse(CharUtils.isAsciiNumeric(CHAR_COPY)); [EOL]     for (int i = 0; i < 196; i++) { [EOL]         if (i >= '0' && i <= '9')) { [EOL]             assertTrue(CharUtils.isAsciiNumeric((char) i)); [EOL]         } else { [EOL]             assertFalse(CharUtils.isAsciiNumeric((char) i)); [EOL]         } [EOL]     } [EOL] }
@Test [EOL] public void testToIntValue_Character() { [EOL]     assertEquals(0, CharUtils.toIntValue(new Character('0'))); [EOL]     assertEquals(3, CharUtils.toIntValue(new Character('3'))); [EOL]     assertEquals(2, CharUtils.toIntValue(new Character('2'))); [EOL]     assertEquals(4, CharUtils.toIntValue(new Character('4'))); [EOL]     assertEquals(-1, CharUtils.toIntValue(null)); [EOL] }
@Test [EOL] public void testToIntValue_Character() { [EOL]     assertTrue(CharUtils.toIntValue(new Character('0')) == 0); [EOL]     assertTrue(CharUtils.toIntValue(new Character('1'), 0) == 1); [EOL]     assertTrue(CharUtils.toIntValue(new Character('2'), 0) == 2); [EOL]     assertTrue(CharUtils.toIntValue(new Character('3'), 0) == 3); [EOL]     assertTrue(CharUtils.toIntValue(new Character('4'), 0) == 4); [EOL]     assertTrue(CharUtils.toIntValue(new Character('5'), 0) == 5); [EOL]     assertTrue(CharUtils.toIntValue(new Character('6'), 0) == 6); [EOL] }
@Test [EOL] public void testToIntValue_CharacterInt() { [EOL]     assertTrue(CharUtils.toIntValue(new Character('0'), 0) == 0); [EOL]     assertTrue(CharUtils.toIntValue(new Character('1'), 0) == 1); [EOL]     assertTrue(CharUtils.toIntValue(new Character('2'), 0) == 2); [EOL]     assertTrue(CharUtils.toIntValue(new Character('3'), 0) == 3); [EOL]     try { [EOL]         CharUtils.toIntValue(null, 0); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testToIntValue_CharacterInt() { [EOL]     assertTrue(CharUtils.toIntValue(new Character('0'), 0) == 0); [EOL]     assertTrue(CharUtils.toIntValue(new Character('1'), 0) == 1); [EOL]     assertTrue(CharUtils.toIntValue(new Character('2'), 0) == 2); [EOL]     assertTrue(CharUtils.toIntValue(new Character('3'), 0) == 3); [EOL]     try { [EOL]         CharUtils.toIntValue(null, 0); [EOL]     } catch (final NullPointerException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testToIntValue_Character() { [EOL]     assertTrue(CharUtils.toIntValue(new Character('0')) == 0); [EOL]     assertTrue(CharUtils.toIntValue(new Character('1'), 0) == 1); [EOL]     assertTrue(CharUtils.toIntValue(new Character('2'), 0) == 2); [EOL]     assertTrue(CharUtils.toIntValue(new Character('3'), 0) == 3); [EOL]     assertTrue(CharUtils.toIntValue(new Character('4'), 0) == 4); [EOL]     assertTrue(CharUtils.toIntValue(new Character('5'), 0) == 5); [EOL]     assertTrue(CharUtils.toIntValue(new Character('6'), 0) == 6); [EOL] }
@Test [EOL] public void testToIntValue_Character() { [EOL]     assertEquals(0, CharUtils.toIntValue(new Character('0'))); [EOL]     assertEquals(3, CharUtils.toIntValue(new Character('3'))); [EOL]     assertEquals(2, CharUtils.toIntValue(new Character('2'))); [EOL]     assertEquals(4, CharUtils.toIntValue(new Character('4'))); [EOL]     assertFalse(CharUtils.toIntValue(new Character('5'))); [EOL] }
@Test [EOL] public void testIsAsciiNumeric_char() { [EOL]     assertTrue(CharUtils.isAsciiNumeric('a')); [EOL]     assertFalse(CharUtils.isAsciiNumeric('A')); [EOL]     assertFalse(CharUtils.isAsciiNumeric('3')); [EOL]     assertFalse(CharUtils.isAsciiNumeric('-')); [EOL]     assertFalse(CharUtils.isAsciiNumeric('\n')); [EOL]     assertFalse(CharUtils.isAsciiNumeric(CHAR_COPY)); [EOL]     for (int i = 0; i < 196; i++) { [EOL]         if (i >= '0' && i <= '9') || (i >= '0' && i <= '9')) { [EOL]             assertTrue(CharUtils.isAsciiNumeric((char) i)); [EOL]         } else { [EOL]             assertFalse(CharUtils.isAsciiNumeric((char) i)); [EOL]         } [EOL]     } [EOL] }
@Test [EOL] public void testGetSetNullText() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals(null, sb.getNullText()); [EOL]     sb.setNullText("null"); [EOL]     assertEquals("null", sb.getNullText()); [EOL]     sb.setNullText(""); [EOL]     assertEquals(null, sb.getNullText()); [EOL]     sb.setNullText((String) null); [EOL]     assertEquals(null, sb.getNullText()); [EOL] }
@Test [EOL] public void testGetSetNullText() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals(null, sb.getNullText()); [EOL]     sb.setNullText("null"); [EOL]     assertEquals("null", sb.getNullText()); [EOL]     sb.setNullText(""); [EOL]     assertEquals(null, sb.getNullText()); [EOL]     sb.setNullText((String) null); [EOL]     assertEquals(null, sb.getNullText()); [EOL] }
@Test [EOL] public void testCapacity() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     assertEquals(sb.buffer.length, sb.capacity()); [EOL]     sb.append("HelloWorldHelloWorldHelloWorldHelloWorld"); [EOL]     assertEquals(sb.buffer.length, sb.capacity()); [EOL] }
@Test [EOL] public void testAppendWithSeparators_Iterator() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     sb.appendWithSeparators((Iterator<?>) null, ","); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ","); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", "bar", "baz" }).iterator(), ","); [EOL]     assertEquals("foo,bar,baz", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", null, "baz" }).iterator(), null); [EOL]     assertEquals("foobarbaz", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", "bar", "baz" }).iterator(), ","); [EOL]     assertEquals("foo,,baz", sb.toString()); [EOL] }
@Test [EOL] public void testAppendFixedWidthPadLeft() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     sb.appendFixedWidthPadLeft("foo", -1, '-'); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendFixedWidthPadLeft("foo", 0, '-'); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendFixedWidthPadLeft("foo", 1, '-'); [EOL]     assertEquals("f", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendFixedWidthPadLeft("foo", 2, '-'); [EOL]     assertEquals("o", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendFixedWidthPadLeft("foo", 3, '-'); [EOL]     assertEquals("o", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendFixedWidthPadLeft("foo", 4, '-'); [EOL]     assertEquals("-foo", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendFixedWidthPadLeft("foo", 10, '-'); [EOL]     assertEquals(10, sb.length()); [EOL]     assertEquals("-------foo", sb.toString()); [EOL] }
@Test [EOL] public void testAppendWithSeparators_Iterator() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     sb.appendWithSeparators((Iterator<?>) null, ","); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ","); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", "bar", "baz" }).iterator(), ","); [EOL]     assertEquals("foo,bar,baz", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", null, "baz" }).iterator(), null); [EOL]     assertEquals("foobarbaz", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", "bar", "baz" }).iterator(), ","); [EOL]     assertEquals("foo,,baz", sb.toString()); [EOL] }
@Test [EOL] public void testAppendWithSeparators_Iterator() { [EOL]     final StrBuilder sb = new StrBuilder(); [EOL]     sb.appendWithSeparators((Iterator<?>) null, ","); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ","); [EOL]     assertEquals("", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", "bar", "baz" }).iterator(), ","); [EOL]     assertEquals("foo,bar,baz", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", null, "baz" }).iterator(), null); [EOL]     assertEquals("foobarbaz", sb.toString()); [EOL]     sb.clear(); [EOL]     sb.appendWithSeparators(Arrays.asList(new Object[] { "foo", "bar", "baz" }).iterator(), ","); [EOL]     assertEquals("foo,,baz", sb.toString()); [EOL] }
@Test [EOL] public void testWeekIterator() throws Exception { [EOL]     final Calendar now = Calendar.getInstance(); [EOL]     for (int i = 0; i < 7; i++) { [EOL]         final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]         final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]         sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]         final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]         if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]             monday.add(Calendar.DATE, -6); [EOL]         } else { [EOL]             monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]         } [EOL]         final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]         centered.add(Calendar.DATE, -3); [EOL]         Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]         assertWeekIterator(it, sunday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]         assertWeekIterator(it, monday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]         assertWeekIterator(it, today); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         try { [EOL]             it.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {
@Test [EOL] public void testSetSeconds() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.setSeconds(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 999); [EOL]     result = DateUtils.setSeconds(base, 999); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 999); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 999); [EOL]     try { [EOL]         result = DateUtils.setSeconds(base, 999); [EOL]         fail("DateUtils.setSeconds did not throw an expected IllegalArguementException."); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testWeekIterator() throws Exception { [EOL]     final Calendar now = Calendar.getInstance(); [EOL]     for (int i = 0; i < 7; i++) { [EOL]         final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]         final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]         sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]         final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]         if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]             monday.add(Calendar.DATE, -6); [EOL]         } else { [EOL]             monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]         } [EOL]         final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]         centered.add(Calendar.DATE, -3); [EOL]         Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]         assertWeekIterator(it, sunday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]         assertWeekIterator(it, monday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]         assertWeekIterator(it, today); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         try { [EOL]             it.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {
@Test [EOL] public void testSetDate() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.setDate(base, Calendar.DATE); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.setDate(base, Calendar.DATE); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     try { [EOL]         result = DateUtils.setDate(base, Calendar.DATE); [EOL]         fail("DateUtils.setDate did not throw an expected IllegalArguementException."); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testWeekIterator() throws Exception { [EOL]     final Calendar now = Calendar.getInstance(); [EOL]     for (int i = 0; i < 7; i++) { [EOL]         final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]         final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]         sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]         final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]         if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]             monday.add(Calendar.DATE, -6); [EOL]         } else { [EOL]             monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]         } [EOL]         final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]         centered.add(Calendar.DATE, -3); [EOL]         Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]         assertWeekIterator(it, sunday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]         assertWeekIterator(it, monday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]         assertWeekIterator(it, today); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         try { [EOL]             it.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {
@Test [EOL] public void testWeekIterator() throws Exception { [EOL]     final Calendar now = Calendar.getInstance(); [EOL]     for (int i = 0; i < 7; i++) { [EOL]         final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]         final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]         sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]         final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]         if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]             monday.add(Calendar.DATE, -6); [EOL]         } else { [EOL]             monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]         } [EOL]         final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]         centered.add(Calendar.DATE, -3); [EOL]         Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]         assertWeekIterator(it, sunday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]         assertWeekIterator(it, monday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]         assertWeekIterator(it, today); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         try { [EOL]             it.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {
@Test [EOL] public void testWeekIterator() throws Exception { [EOL]     final Calendar now = Calendar.getInstance(); [EOL]     for (int i = 0; i < 7; i++) { [EOL]         final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]         final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]         sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]         final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]         if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]             monday.add(Calendar.DATE, -6); [EOL]         } else { [EOL]             monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]         } [EOL]         final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]         centered.add(Calendar.DATE, -3); [EOL]         Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]         assertWeekIterator(it, sunday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]         assertWeekIterator(it, monday); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]         assertWeekIterator(it, today); [EOL]         it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]         assertWeekIterator(it, centered); [EOL]         try { [EOL]             it.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {
@Test [EOL] public void testSetSeconds() throws Exception { [EOL]     final Date base = new Date(MILLIS_TEST); [EOL]     Date result = DateUtils.setSeconds(base, 0); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     result = DateUtils.setSeconds(base, 999); [EOL]     assertNotSame(base, result); [EOL]     assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]     assertDate(result, 2000, 6, 5, 4, 3, 2, 999); [EOL]     try { [EOL]         result = DateUtils.setSeconds(base, 999); [EOL]         fail("DateUtils.setSeconds did not throw an expected IllegalArguementException."); [EOL]     } catch (final IllegalArgumentException e) { [EOL]     } [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testFormat() { [EOL]     final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL]     c.set(2005, 0, 1, 12, 0, 0); [EOL]     c.setTimeZone(TimeZone.getDefault()); [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     final int year = c.get(Calendar.YEAR); [EOL]     final int month = c.get(Calendar.MONTH) + 1; [EOL]     final int day = c.get(Calendar.DAY_OF_MONTH); [EOL]     final int hour = c.get(Calendar.HOUR_OF_DAY); [EOL]     buffer.append(year); [EOL]     buffer.append(month); [EOL]     buffer.append(day); [EOL]     buffer.append(hour); [EOL]     buffer.append(day); [EOL]     buffer.append(hour); [EOL]     assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH")); [EOL]     assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), "yyyyMdH")); [EOL]     assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH")); [EOL]     assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), "yyyyMdH")); [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testSMTP() { [EOL]     final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]     final Calendar cal = Calendar.getInstance(timeZone); [EOL]     cal.set(2003, 5, 8, 10, 11, 12); [EOL]     String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); [EOL]     text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL]     text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); [EOL]     assertEquals("Sun, 08 Jun 2003 13:11:12 -0300", text); [EOL] }
@Test [EOL] public void testExclusiveBetween_withMessage() { [EOL]     Validate.exclusiveBetween("a", "c", "b"); [EOL]     Validate.exclusiveBetween(0, 2, 1); [EOL]     Validate.exclusiveBetween(0, 2, 2); [EOL]     try { [EOL]         Validate.exclusiveBetween(0, 5, 6); [EOL]         fail("Expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]         assertEquals("The value 6 is not in the specified inclusive range of 0 to 5", e.getMessage()); [EOL]     } [EOL] }
@Test [EOL] public void testExclusiveBetween_withMessage() { [EOL]     Validate.exclusiveBetween("a", "c", "b"); [EOL]     Validate.exclusiveBetween(0, 2, 1); [EOL]     try { [EOL]         Validate.exclusiveBetween(0, 5, 6); [EOL]         fail("Expecting IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException e) { [EOL]         assertEquals("The value 6 is not in the specified inclusive range of 0 to 5", e.getMessage()); [EOL]     } [EOL] }
@Test [EOL] public void testDecrement() { [EOL]     final MutableFloat mutNum = new MutableFloat(1); [EOL]     mutNum.decrement(); [EOL]     assertEquals(0, mutNum.intValue()); [EOL]     assertEquals(0L, mutNum.longValue()); [EOL] }
@Test [EOL] public void testDecrement() { [EOL]     final MutableFloat mutNum = new MutableFloat(1); [EOL]     mutNum.decrement(); [EOL]     assertEquals(0, mutNum.intValue()); [EOL]     assertEquals(0L, mutNum.longValue()); [EOL] }
@Test [EOL] public void testDecrement() { [EOL]     final MutableFloat mutNum = new MutableFloat(1); [EOL]     mutNum.decrement(); [EOL]     assertEquals(0, mutNum.intValue()); [EOL]     assertEquals(0L, mutNum.longValue()); [EOL] }
@Test [EOL] public void testDecrement() { [EOL]     final MutableFloat mutNum = new MutableFloat(1); [EOL]     mutNum.decrement(); [EOL]     assertEquals(0, mutNum.intValue()); [EOL]     assertEquals(0L, mutNum.longValue()); [EOL] }
@Test [EOL] public void testDecrement() { [EOL]     final MutableFloat mutNum = new MutableFloat(1); [EOL]     mutNum.decrement(); [EOL]     assertEquals(0, mutNum.intValue()); [EOL]     assertEquals(0L, mutNum.longValue()); [EOL] }
@Test [EOL] public void testIsBeforeRange() { [EOL]     assertFalse(intRange.isBeforeRange(null)); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 9))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(15, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(21, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(25, 25))); [EOL] }
@Test [EOL] public void testIsBeforeRange() { [EOL]     assertFalse(intRange.isBeforeRange(null)); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 9))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(15, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(21, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(25, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(21, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(25, 25))); [EOL] }
@Test [EOL] public void testIsBeforeRange() { [EOL]     assertFalse(intRange.isBeforeRange(null)); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 9))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(15, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(21, 25))); [EOL]     assertFalse(intRange.isBeforeRange(Range.between(25, 25))); [EOL] }
@Test [EOL] public void testSerialization() throws Exception { [EOL]     final Triple<String, String, String> triple1 = Triple.of("A", "A", "D"); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(triple1); [EOL]     final Triple<String, String, String> deserializedTriple = (Triple<String, String, String>) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(triple1, deserializedTriple); [EOL]     assertEquals(triple1.hashCode(), deserializedTriple.hashCode()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testSerialization() throws Exception { [EOL]     final Triple<String, String, String> triple1 = Triple.of("A", "A", "D"); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(triple1); [EOL]     final Triple<String, String, String> deserializedTriple = (Triple<String, String, String>) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(triple1, deserializedTriple); [EOL]     assertEquals(triple1.hashCode(), deserializedTriple.hashCode()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testSerialization() throws Exception { [EOL]     final Triple<String, String, String> triple1 = Triple.of("A", "A", "D"); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(triple1); [EOL]     final Triple<String, String, String> deserializedTriple = (Triple<String, String, String>) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(triple1, deserializedTriple); [EOL]     assertEquals(triple1.hashCode(), deserializedTriple.hashCode()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] @SuppressWarnings("unchecked") [EOL] public void testSerialization() throws Exception { [EOL]     final Triple<String, String, String> triple1 = Triple.of("A", "A", "D"); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(triple1); [EOL]     final Triple<String, String, String> deserializedTriple = (Triple<String, String, String>) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(triple1, deserializedTriple); [EOL]     assertEquals(triple1.hashCode(), deserializedTriple.hashCode()); [EOL] }
@Test [EOL] public void testToString() throws Exception { [EOL]     assertEquals("(null,null,null)", ImmutableTriple.of(null, null, null).toString()); [EOL]     assertEquals("(null,two,null)", ImmutableTriple.of(null, "two", null).toString()); [EOL]     assertEquals("(one,null,null)", ImmutableTriple.of("one", null, null).toString()); [EOL]     assertEquals("(one,two,null)", ImmutableTriple.of("one", "two", null).toString()); [EOL]     assertEquals("(null,two,three)", ImmutableTriple.of(null, "two", "three").toString()); [EOL]     assertEquals("(one,null,three)", ImmutableTriple.of("one", null, "three").toString()); [EOL]     assertEquals("(one,two,three)", ImmutableTriple.of("one", "two", "three").toString()); [EOL]     assertEquals("(one,two,three)", ImmutableTriple.of("one", "two", "three").toString()); [EOL]     assertEquals("(one,two,three)", ImmutableTriple.of("one", "two", "three").toString()); [EOL] }
@Test [EOL] public void testSerialization() throws Exception { [EOL]     final Triple<String, String, String> triple1 = Triple.of("A", "A", "D"); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(triple1); [EOL]     final Triple<String, String, String> deserializedTriple = (Triple<String, String, String>) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(triple1, deserializedTriple); [EOL]     assertEquals(triple1.hashCode(), deserializedTriple.hashCode()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testSerialization() throws Exception { [EOL]     final Triple<String, String, String> triple1 = Triple.of("A", "A", "D"); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(triple1); [EOL]     final Triple<String, String, String> deserializedTriple = (Triple<String, String, String>) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(triple1, deserializedTriple); [EOL]     assertEquals(triple1.hashCode(), deserializedTriple.hashCode()); [EOL] }
@Test [EOL] public void testToString() throws Exception { [EOL]     assertEquals("(null,null,null)", ImmutableTriple.of(null, null, null).toString()); [EOL]     assertEquals("(null,two,null)", ImmutableTriple.of(null, "two", null).toString()); [EOL]     assertEquals("(one,null,null)", ImmutableTriple.of("one", null, null).toString()); [EOL]     assertEquals("(one,two,null)", ImmutableTriple.of("one", "two", null).toString()); [EOL]     assertEquals("(null,two,three)", ImmutableTriple.of(null, "two", "three").toString()); [EOL]     assertEquals("(one,null,three)", ImmutableTriple.of("one", null, "three").toString()); [EOL]     assertEquals("(one,two,three)", ImmutableTriple.of("one", "two", "three").toString()); [EOL]     assertEquals("(one,two,three)", ImmutableTriple.of("one", "two", "three").toString()); [EOL]     assertEquals("(one,two,three)", ImmutableTriple.of("one", "two", "three").toString()); [EOL]     assertEquals("(one,two,three)", ImmutableTriple.of("one", "two", "three").toString()); [EOL] }
@Test [EOL] public void testSerialization() throws Exception { [EOL]     final Triple<String, String, String> triple1 = Triple.of("A", "A", "D"); [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream out = new ObjectOutputStream(baos); [EOL]     out.writeObject(triple1); [EOL]     final Triple<String, String, String> deserializedTriple = (Triple<String, String, String>) new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())).readObject(); [EOL]     assertEquals(triple1, deserializedTriple); [EOL]     assertEquals(triple1.hashCode(), deserializedTriple.hashCode()); [EOL] }
@Test [EOL] public void testImmutableTriple() throws Exception { [EOL]     final ImmutableTriple<Integer, String, Boolean> triple = new ImmutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testMutate() throws Exception { [EOL]     final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); [EOL]     triple.setLeft(42); [EOL]     triple.setMiddle("bar"); [EOL]     triple.setRight(Boolean.FALSE); [EOL]     assertEquals(42, triple.getLeft().intValue()); [EOL]     assertEquals("bar", triple.getMiddle()); [EOL]     assertEquals(Boolean.FALSE, triple.getRight()); [EOL] }
@Test [EOL] public void testToUnicodeEscaped_Character() { [EOL]     assertEquals(null, CharUtils.unicodeEscaped(null)); [EOL]     assertEquals("\\u0041", CharUtils.unicodeEscaped(CHARACTER_A)); [EOL] }
@Test [EOL] public void testToUnicodeEscaped_Character() { [EOL]     assertEquals(null, CharUtils.unicodeEscaped(null)); [EOL]     assertEquals("\\u0041", CharUtils.unicodeEscaped(CHARACTER_A)); [EOL] }
@Test [EOL] public void testToUnicodeEscaped_Character() { [EOL]     assertEquals(null, CharUtils.unicodeEscaped(null)); [EOL]     assertEquals("\\u0041", CharUtils.unicodeEscaped(CHARACTER_A)); [EOL] }
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, null, 2); [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 1); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAndString
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAndString
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, null, 2); [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 1); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals
@Test [EOL] public void testSplitByWholeStringPreserveAllTokens_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparatorPreserveAllTokens(null, ".")); [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparatorPreserveAllTokens(null, ".", 3)); [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparatorPreserveAllTokens(null, ".", 4)); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "   de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparatorPreserveAllTokens(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparatorPreserveAllTokens(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = { "ab", ":", "cd", ":", "ef" }; [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = { "ab", ":", "cd", ":", "ef" }; [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = { "ab
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAndString
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAndString
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = StringUtils.splitByWholeSeparator("abstemiously", ".", 2); [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = StringUtils.splitByWholeSeparator("abstemiously", ".", 1); [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = StringUtils.splitByWholeSeparator("abstemiously", ".", 4); [EOL]     assertEquals(splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparatorExpectedResults.length); [
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = StringUtils.splitByWholeSeparator("abstemiously", ".", 2); [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = StringUtils.splitByWholeSeparator("abstemiously", ".", 1); [EOL]     final String[] splitWithMultipleSeparatorExpectedResults = StringUtils.splitByWholeSeparator("abstemiously", ".", 4); [EOL]     assertEquals(splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparatorExpectedResults.length); [
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAndString
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "iouy", 1); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "iouy", 1); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAndString
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAndString
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testSplitByWholeString_StringStringIntInt() { [EOL]     assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]     assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]     final String stringToSplitOnNulls = "ab   de fg"; [EOL]     final String[] splitOnNullExpectedResults = { "ab", "de fg" }; [EOL]     final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2); [EOL]     assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length); [EOL]     for (int i = 0; i < splitOnNullExpectedResults.length; i++) { [EOL]         assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]); [EOL]     } [EOL]     final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" }; [EOL]     final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2); [EOL]     assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length); [EOL]     for (int i = 0; i < splitOnStringExpectedResults.length; i++) { [EOL]         assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]); [EOL]     } [EOL]     final String[] splitWithMultipleTokens = "abstemiouslyaeiouyabstemiously"; [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 2); [EOL]     final String[] splitWithMultipleTokensAndString = StringUtils.splitByWholeSeparator("abstemiously", "aeiouy", 1); [EOL]     assertEquals(splitWithMultipleTokensAndStringExpectedResults.length, splitWithMultipleTokensAnd
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0, new MutableInt().intValue()); [EOL]     assertEquals(1, new MutableInt(1).intValue()); [EOL]     assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); [EOL]     assertEquals(3, new MutableInt(new MutableInt(3)).intValue()); [EOL]     assertEquals(2, new MutableInt("2").intValue()); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0, new MutableInt().intValue()); [EOL]     assertEquals(1, new MutableInt(1).intValue()); [EOL]     assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); [EOL]     assertEquals(3, new MutableInt(new MutableInt(3)).intValue()); [EOL]     assertEquals(2, new MutableInt("2").intValue()); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0, new MutableInt().intValue()); [EOL]     assertEquals(1, new MutableInt(1).intValue()); [EOL]     assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); [EOL]     assertEquals(3, new MutableInt(new MutableInt(3)).intValue()); [EOL]     assertEquals(2, new MutableInt("2").intValue()); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0, new MutableInt().intValue()); [EOL]     assertEquals(1, new MutableInt(1).intValue()); [EOL]     assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); [EOL]     assertEquals(3, new MutableInt(new MutableInt(3)).intValue()); [EOL]     assertEquals(2, new MutableInt("2").intValue()); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0, new MutableInt().intValue()); [EOL]     assertEquals(1, new MutableInt(1).intValue()); [EOL]     assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); [EOL]     assertEquals(3, new MutableInt(new MutableInt(3)).intValue()); [EOL]     assertEquals(2, new MutableInt("2").intValue()); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0, new MutableInt().intValue()); [EOL]     assertEquals(1, new MutableInt(1).intValue()); [EOL]     assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); [EOL]     assertEquals(3, new MutableInt(new MutableInt(3)).intValue()); [EOL]     assertEquals(2, new MutableInt("2").intValue()); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0, new MutableInt().intValue()); [EOL]     assertEquals(1, new MutableInt(1).intValue()); [EOL]     assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); [EOL]     assertEquals(3, new MutableInt(new MutableInt(3)).intValue()); [EOL]     assertEquals(2, new MutableInt("2").intValue()); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testContainsBoolean() { [EOL]     boolean[] array = null; [EOL]     assertFalse(ArrayUtils.contains(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertFalse(ArrayUtils.contains(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertTrue(ArrayUtils.contains(array, true)); [EOL]     assertTrue(ArrayUtils.contains(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertFalse(ArrayUtils.contains(array, false)); [EOL] }
@Test [EOL] public void testContainsBoolean() { [EOL]     boolean[] array = null; [EOL]     assertFalse(ArrayUtils.contains(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertFalse(ArrayUtils.contains(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertTrue(ArrayUtils.contains(array, true)); [EOL]     assertTrue(ArrayUtils.contains(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertFalse(ArrayUtils.contains(array, false)); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testIndexOfBoolean() { [EOL]     boolean[] array = null; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[0]; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, true)); [EOL]     array = new boolean[] { true, false, true }; [EOL]     assertEquals(2, ArrayUtils.indexOf(array, true)); [EOL]     assertEquals(1, ArrayUtils.indexOf(array, false)); [EOL]     array = new boolean[] { true, true }; [EOL]     assertEquals(-1, ArrayUtils.indexOf(array, false)); [EOL] }
@Test [EOL] public void testGetContextLabels() { [EOL]     assertEquals(5, exceptionContext.getContextEntries().size()); [EOL]     exceptionContext.addContextValue("test2", "different value"); [EOL]     final Set<String> labels = exceptionContext.getContextLabels(); [EOL]     assertEquals(6, exceptionContext.getContextEntries().size()); [EOL]     assertEquals(5, labels.size()); [EOL]     assertTrue(labels.contains("test1")); [EOL]     assertTrue(labels.contains("test2")); [EOL]     assertTrue(labels.contains("test Date")); [EOL]     assertTrue(labels.contains("test Nbr")); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableLong mutNumA = new MutableLong(0); [EOL]     final MutableLong mutNumB = new MutableLong(0); [EOL]     final MutableLong mutNumC = new MutableLong(1); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals(Long.valueOf(0))); [EOL]     assertFalse(mutNumA.equals("0")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableLong mutNumA = new MutableLong(0); [EOL]     final MutableLong mutNumB = new MutableLong(0); [EOL]     final MutableLong mutNumC = new MutableLong(1); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals(Long.valueOf(0))); [EOL]     assertFalse(mutNumA.equals("0")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableLong mutNumA = new MutableLong(0); [EOL]     final MutableLong mutNumB = new MutableLong(0); [EOL]     final MutableLong mutNumC = new MutableLong(1); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals(Long.valueOf(0))); [EOL]     assertFalse(mutNumA.equals("0")); [EOL] }
@Test [EOL] public void test_generateBitVectorsFromArray() { [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class), 0L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED), 1L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER), 2L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.GREEN), 4L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER), 3L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.GREEN), 5L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN), 6L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L); [EOL] }
@Test [EOL] public void test_generateBitVector() { [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.noneOf(Traffic.class)), 0L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED)), 1L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER)), 2L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.GREEN)), 4L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER)), 3L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN)), 5L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN)), 6L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)), 7L); [EOL] }
@Test [EOL] public void test_generateBitVector() { [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class), 0L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 1L), 1L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 2L), 2L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 3L), 3L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 4L), 4L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 5L), 5L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 6L), 6L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 7L), 7L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 8L), 8L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 9L), 9L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 10L), 10L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 11L), 11L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 12L), 12L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 13L), 13L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 14L), 14L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, 15L), 15L); [EOL] }
@Test [EOL] public void test_generateBitVectorsFromArray() { [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class), 0L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED), 1L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER), 2L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.GREEN), 4L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER), 3L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.GREEN), 5L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN), 6L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L); [EOL] }
@Test [EOL] public void test_generateBitVector() { [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.noneOf(Traffic.class)), 0L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED)), 1L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER)), 2L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.GREEN)), 4L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER)), 3L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN)), 5L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN)), 6L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)), 7L); [EOL] }
@Test [EOL] public void test_generateBitVectorsFromArray() { [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class), 0L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED), 1L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER), 2L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.GREEN), 4L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER), 3L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.GREEN), 5L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN), 6L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L); [EOL]     assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L); [EOL] }
@Test [EOL] public void test_generateBitVector() { [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.noneOf(Traffic.class)), 0L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED)), 1L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER)), 2L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.GREEN)), 4L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER)), 3L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN)), 5L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN)), 6L); [EOL]     assertEquals(EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)), 7L); [EOL] }
@Test [EOL] public void testNormalizeUpperBounds() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Type[] iterableTypeVarAssigns = TypeUtils.normalizeUpperBounds(TreeSet.class.getTypeParameters()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(Arrays.equals(iterableTypeVarAssigns, iterableType)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], iterableType.getActualTypeArguments()[0]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[1], iterableType.getActualTypeArguments()[1]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[2], iterableType.getActualTypeArguments()[2]); [EOL] }
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]     final Type[] types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(types.length == 2); [EOL]     Assert.assertTrue(types[0].equals(treeSetTypeVar)); [EOL]     Assert.assertTrue(types[1].equals(treeSetTypeVar)); [EOL]     Assert.assertTrue(types[2].equals(treeSetTypeVar)); [EOL]     types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     Assert.assertTrue(types.length == 2); [EOL]     Assert.assertTrue(types[0].equals(types[1])); [EOL]     Assert.assertTrue(types[1].equals(types[2])); [EOL]     types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     Assert.assertTrue(types.length == 4); [EOL]     Assert.assertTrue(types[0].equals(types[1])); [EOL]     Assert.assertTrue(types[1].equals(types[2])); [EOL]     Assert.assertTrue(types[2].equals(types[3])); [EOL]     Assert.assertTrue(types[3].equals(types[4])); [EOL]     types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     Assert.assertTrue(types.length == 4); [EOL]     Assert.assertTrue(types[0].equals(types[1])); [EOL]     Assert.assertTrue(types[1].equals(types[2])); [EOL]     Assert.assertTrue(types[2
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.normalizeUpperBounds(TreeSet.class.getTypeParameters()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns.get(treeSetTypeVar)); [EOL] }
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]     final Type[] types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(types.length == 2); [EOL]     Assert.assertEquals(treeSetTypeVar, types[0]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[1]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[2]); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[1]; [EOL]     Assert.assertTrue(types.length == 3); [EOL]     Assert.assertEquals(treeSetTypeVar, types[3]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[4]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[5]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[6]); [EOL]     Assert.assertEquals(treeSetTypeVar, types[7]); [EOL]     Assert.assertEquals(types[8], types[9]); [EOL]     Assert.assertEquals(types[10], types[11]); [EOL]     Assert.assertEquals(types[12], types[13]); [EOL]     Assert.assertEquals(types[13], types[14]); [EOL]     Assert.assertEquals(types[14], types[15]); [EOL]     Assert.assertEquals(types[15], types[16]); [EOL]     Assert.assertEquals(types[16], types[17]); [EOL]     Assert.assertEquals(types[17], types[18]); [EOL]     Assert.assertEquals(types[18], types[19]); [EOL] }
@Test [EOL] public void testNormalizeUpperBounds() throws Exception { [EOL]     final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); [EOL]     final Type[] types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(types.length == 2); [EOL]     Assert.assertTrue(types[0].equals(treeSetTypeVar)); [EOL]     Assert.assertTrue(types[1].equals(treeSetTypeVar)); [EOL]     Assert.assertTrue(types[2].equals(treeSetTypeVar)); [EOL]     types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     Assert.assertTrue(types.length == 2); [EOL]     Assert.assertTrue(types[0].equals(treeSetTypeVar)); [EOL]     Assert.assertTrue(types[1].equals(treeSetTypeVar)); [EOL]     Assert.assertTrue(types[2].equals(treeSetTypeVar)); [EOL]     types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     Assert.assertTrue(types.length == 4); [EOL]     Assert.assertTrue(types[0].equals(types[1])); [EOL]     Assert.assertTrue(types[1].equals(types[2])); [EOL]     Assert.assertTrue(types[2].equals(types[3])); [EOL]     Assert.assertTrue(types[3].equals(types[4])); [EOL]     types = TypeUtils.normalizeUpperBounds(method.getGenericParameterTypes()); [EOL]     Assert.assertTrue(types.length == 4); [EOL]     Assert.assertTrue(types[0].equals(types[1])); [EOL]     Assert.assertTrue(types[1].equals(
@Test [EOL] public void testNormalizeUpperBounds() throws SecurityException, NoSuchFieldException, NoSuchMethodException { [EOL]     final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable").getGenericType(); [EOL]     final Type[] iterableTypeVarAssigns = TypeUtils.normalizeUpperBounds(TreeSet.class.getField("iterable").getGenericType()); [EOL]     final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]     Assert.assertTrue(Arrays.equals(iterableTypeVarAssigns, iterableType)); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[0], iterableType.getActualTypeArguments()[0]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[1], iterableType.getActualTypeArguments()[1]); [EOL]     Assert.assertEquals(iterableType.getActualTypeArguments()[2], iterableType.getActualTypeArguments()[2]); [EOL] }
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testRemoveElementCharArray() { [EOL]     char[] array; [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); [EOL]     assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); [EOL]     assertEquals(Character.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new char[] { 'a', '
@Test [EOL] public void testToShortStringI() { [EOL]     assertTrue("toShort(String,short) 1 failed", NumberUtils.toShort("12345", (short) 5) == 12345); [EOL]     assertTrue("toShort(String,short) 2 failed", NumberUtils.toShort("1234.5", (short) 5) == 5); [EOL] }
@Test [EOL] public void testToShortStringI() { [EOL]     assertTrue("toShort(String,short) 1 failed", NumberUtils.toShort("12345", (short) 5) == 12345); [EOL]     assertTrue("toShort(String,short) 2 failed", NumberUtils.toShort("1234.5", (short) 5) == 5); [EOL] }
@Test [EOL] public void testToShortStringI() { [EOL]     assertTrue("toShort(String,short) 1 failed", NumberUtils.toShort("12345", (short) 5) == 12345); [EOL]     assertTrue("toShort(String,short) 2 failed", NumberUtils.toShort("1234.5", (short) 5) == 5); [EOL] }
@Test [EOL] public void testToShortStringI() { [EOL]     assertTrue("toShort(String,short) 1 failed", NumberUtils.toShort("12345", (short) 5) == 12345); [EOL]     assertTrue("toShort(String,short) 2 failed", NumberUtils.toShort("1234.5", (short) 5) == 5); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test(expected = NumberFormatException.class) [EOL] public void testCreateNumberFailure_4() { [EOL]     NumberUtils.createNumber("1eE+00001"); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test(expected = NumberFormatException.class) [EOL] public void testCreateNumberFailure_4() { [EOL]     NumberUtils.createNumber("1eE+00001"); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testCreateLong() { [EOL]     assertEquals("createLong(String) failed", Long.valueOf("12345"), NumberUtils.createLong("12345")); [EOL]     assertEquals("createLong(null) failed", null, NumberUtils.createLong(null)); [EOL]     this.testCreateLongFailure(""); [EOL]     this.testCreateLongFailure(" "); [EOL]     this.testCreateLongFailure("\b\t\n\f\r"); [EOL]     this.testCreateLongFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test(expected = NumberFormatException.class) [EOL] public void testCreateNumberFailure_4() { [EOL]     NumberUtils.createNumber("1eE+00001"); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testCreateLong() { [EOL]     assertEquals("createLong(String) failed", Long.valueOf("12345"), NumberUtils.createLong("12345")); [EOL]     assertEquals("createLong(null) failed", null, NumberUtils.createLong(null)); [EOL]     this.testCreateLongFailure(""); [EOL]     this.testCreateLongFailure(" "); [EOL]     this.testCreateLongFailure("\b\t\n\f\r"); [EOL]     this.testCreateLongFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test(expected = NumberFormatException.class) [EOL] public void testCreateNumberFailure_4() { [EOL]     NumberUtils.createNumber("1eE+00001"); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testFormatDurationWords() { [EOL]     String text = null; [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); [EOL]     assertEquals("2 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); [EOL]     assertEquals("1 hour 12 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); [EOL]     assertEquals("1 day 0 hours 0 minutes 0 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); [EOL]     assertEquals("50 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); [EOL]     assertEquals("1 minute 5 seconds", text); [EOL]     text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); [EOL]     assertEquals("2 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); [EOL]     assertEquals("2 minutes 1 second", text); [EOL]     text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); [EOL]     assertEquals("1 hour 12 minutes", text); [EOL]     text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); [EOL]     assertEquals("1 day", text); [EOL]     text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); [EOL]     assertEquals("0 days 0 hours 0
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testCreateInteger() { [EOL]     assertEquals("createInteger(String) failed", Integer.valueOf("12345"), NumberUtils.createInteger("12345")); [EOL]     assertEquals("createInteger(null) failed", null, NumberUtils.createInteger(null)); [EOL]     this.testCreateIntegerFailure(""); [EOL]     this.testCreateIntegerFailure(" "); [EOL]     this.testCreateIntegerFailure("\b\t\n\f\r"); [EOL]     this.testCreateIntegerFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testCreateInteger() { [EOL]     assertEquals("createInteger(String) failed", Integer.valueOf("12345"), NumberUtils.createInteger("12345")); [EOL]     assertEquals("createInteger(null) failed", null, NumberUtils.createInteger(null)); [EOL]     this.testCreateIntegerFailure(""); [EOL]     this.testCreateIntegerFailure(" "); [EOL]     this.testCreateIntegerFailure("\b\t\n\f\r"); [EOL]     this.testCreateIntegerFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testStringIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testCreateLong() { [EOL]     assertEquals("createLong(String) failed", Long.valueOf("12345"), NumberUtils.createLong("12345")); [EOL]     assertEquals("createLong(null) failed", null, NumberUtils.createLong(null)); [EOL]     this.testCreateLongFailure(""); [EOL]     this.testCreateLongFailure(" "); [EOL]     this.testCreateLongFailure("\b\t\n\f\r"); [EOL]     this.testCreateLongFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testCreateInteger() { [EOL]     assertEquals("createInteger(String) failed", Integer.valueOf("12345"), NumberUtils.createInteger("12345")); [EOL]     assertEquals("createInteger(null) failed", null, NumberUtils.createInteger(null)); [EOL]     this.testCreateIntegerFailure(""); [EOL]     this.testCreateIntegerFailure(" "); [EOL]     this.testCreateIntegerFailure("\b\t\n\f\r"); [EOL]     this.testCreateIntegerFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testCreateNumber() { [EOL]     assertTrue("createNumber(String) failed", NumberUtils.createNumber("12345")); [EOL]     assertTrue("createNumber(String) neg 1 failed", NumberUtils.createNumber("1234.5")); [EOL]     assertTrue("createNumber(String) neg 3 failed", NumberUtils.createNumber("1ab")); [EOL]     assertTrue("createNumber(String) neg 4 failed", NumberUtils.createNumber("abc")); [EOL]     assertFalse("createNumber(empty) failed", NumberUtils.createNumber("")); [EOL]     assertFalse("createNumber(null) failed", NumberUtils.createNumber(null)); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void TestLang747() { [EOL]     assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); [EOL]     assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); [EOL]     assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assertEquals(Integer.valueOf(8000000), NumberUtils.createNumber("8000000")); [EOL]     assert
@Test [EOL] public void testStringCreateNumberEnsureNoPrecisionLoss() { [EOL]     String shouldBeFloat = "1.23"; [EOL]     String shouldBeDouble = "3.40282354e+38"; [EOL]     String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]     assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]     assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void testIsNumber() { [EOL]     assertFalse(StringUtils.isNumber(null)); [EOL]     assertFalse(StringUtils.isNumber("")); [EOL]     assertFalse(StringUtils.isNumber(" ")); [EOL]     assertFalse(StringUtils.isNumber("a")); [EOL]     assertFalse(StringUtils.isNumber("A")); [EOL]     assertFalse(StringUtils.isNumber("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]     assertFalse(StringUtils.isNumber("ham kso")); [EOL]     assertTrue(StringUtils.isNumber("1")); [EOL]     assertTrue(StringUtils.isNumber("1000")); [EOL]     assertFalse(StringUtils.isNumber("2.3")); [EOL]     assertFalse(StringUtils.isNumber("10 00")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]     assertFalse(StringUtils.isNumber("_")); [EOL]     assertFalse(StringUtils.isNumber("hkHKHik*khbkuh")); [EOL] }
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("ClassUtils")); [EOL]     assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName(ClassUtils[].class)); [EOL]     assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName(ClassUtils[][].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortCanonicalName("boolean")); [EOL]     assertEquals("byte", ClassUtils.getShortCanonicalName("byte")); [EOL]     assertEquals("char", ClassUtils.getShortCanonicalName("char")); [EOL]     assertEquals("short", ClassUtils.getShortCanonicalName("short")); [EOL]     assertEquals("int", ClassUtils.getShortCanonicalName("int")); [EOL]     assertEquals("long", ClassUtils.getShortCanonicalName("long")); [EOL]     assertEquals("float", ClassUtils.getShortCanonicalName("float")); [EOL]     assertEquals("double", ClassUtils.getShortCanonicalName("double")); [EOL]     assertEquals("boolean[]", ClassUtils.getShortCanonicalName(new String[0])); [EOL]     assertEquals("<null>", ClassUtils.getShortCanonicalName("<null>")); [EOL] }
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("ClassUtils")); [EOL]     assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName(ClassUtils[].class)); [EOL]     assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName(ClassUtils[][].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortCanonicalName("boolean")); [EOL]     assertEquals("byte", ClassUtils.getShortCanonicalName("byte")); [EOL]     assertEquals("char", ClassUtils.getShortCanonicalName("char")); [EOL]     assertEquals("short", ClassUtils.getShortCanonicalName("short")); [EOL]     assertEquals("int", ClassUtils.getShortCanonicalName("int")); [EOL]     assertEquals("long", ClassUtils.getShortCanonicalName("long")); [EOL]     assertEquals("float", ClassUtils.getShortCanonicalName("float")); [EOL]     assertEquals("double", ClassUtils.getShortCanonicalName("double")); [EOL]     assertEquals("boolean[]", ClassUtils.getShortCanonicalName(new String[0])); [EOL]     assertEquals("<null>", ClassUtils.getShortCanonicalName("<null>")); [EOL] }
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getShortClassName_Class() { [EOL]     assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); [EOL]     assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); [EOL]     assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); [EOL]     assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getShortClassName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getShortClassName(char.class)); [EOL]     assertEquals("short", ClassUtils.getShortClassName(short.class)); [EOL]     assertEquals("int", ClassUtils.getShortClassName(int.class)); [EOL]     assertEquals("long", ClassUtils.getShortClassName(long.class)); [EOL]     assertEquals("float", ClassUtils.getShortClassName(float.class)); [EOL]     assertEquals("double", ClassUtils.getShortClassName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getShortClassName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void test_getCanonicalName_String() { [EOL]     assertEquals("ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class.getName())); [EOL]     assertEquals("Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class.getName())); [EOL]     assertEquals("", ClassUtils.getCanonicalName((String) null)); [EOL]     assertEquals("String[]", ClassUtils.getCanonicalName(String[].class)); [EOL]     assertEquals("Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class)); [EOL]     assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class)); [EOL]     assertEquals("byte", ClassUtils.getCanonicalName(byte.class)); [EOL]     assertEquals("char", ClassUtils.getCanonicalName(char.class)); [EOL]     assertEquals("short", ClassUtils.getCanonicalName(short.class)); [EOL]     assertEquals("int", ClassUtils.getCanonicalName(int.class)); [EOL]     assertEquals("long", ClassUtils.getCanonicalName(long.class)); [EOL]     assertEquals("float", ClassUtils.getCanonicalName(float.class)); [EOL]     assertEquals("double", ClassUtils.getCanonicalName(double.class)); [EOL]     assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class)); [EOL]     assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class)); [EOL]     assertEquals("char[]", ClassUtils.getCanonicalName(char[].class)); [EOL]     assertEquals("short[]", ClassUtils.getCanonicalName(short[].class)); [EOL]     assertEquals("int[]", ClassUtils.getCanonicalName(int[].class)); [EOL]     assertEquals("long[]", ClassUtils.getCanonicalName(long[].class)); [EOL]     assertEquals("float[]", ClassUtils.getCanonicalName(float[].class)); [EOL]     assertEquals("double[]", ClassUtils.getCanonicalName(double[].class)); [EOL]     assertEquals("String[][]", ClassUtils.getCanonicalName(String[][][].class)); [EOL]
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testContainsAny_StringWithSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000)); [EOL]     assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001)); [EOL]     assertFalse(StringUtils.containsAny(CharU20000, CharU20000)); [EOL]     assertFalse(StringUtils.containsAny(CharU20000, CharU20001)); [EOL] }
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testToCharArray() { [EOL]     assertArrayEquals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc")); [EOL]     assertArrayEquals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc")); [EOL]     assertTrue(Arrays.equals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc"))); [EOL]     assertFalse(Arrays.equals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abcd"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'c', 'd', 'e', 'f' }, StringUtils.toCharArray("abcd"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'd', 'e', 'r' }, StringUtils.toCharArray("abcd"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'a', 'b', 'c', 'd' }, StringUtils.toCharArray("abcd"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'd', 'e', 'f' }, StringUtils.toCharArray("abcd"))); [EOL] }
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testEscapeSurrogatePairs() throws Exception { [EOL]     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]     assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]     assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL] }
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testToCharArray() { [EOL]     assertArrayEquals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc")); [EOL]     assertArrayEquals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc")); [EOL]     assertTrue(Arrays.equals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc"))); [EOL]     assertFalse(Arrays.equals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abcd"))); [EOL]     assertFalse(Arrays.equals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abcde"))); [EOL] }
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testEscapeSurrogatePairs() throws Exception { [EOL]     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]     assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]     assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL] }
@Test [EOL] public void testEscapeSurrogatePairs() throws Exception { [EOL]     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]     assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]     assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL] }
@Test [EOL] public void testEscapeSurrogatePairs() throws Exception { [EOL]     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]     assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]     assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL] }
@Test [EOL] public void testContainsAny_StringWithSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000)); [EOL]     assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001)); [EOL]     assertFalse(StringUtils.containsAny(CharU20000, CharU20000)); [EOL]     assertFalse(StringUtils.containsAny(CharU20000, CharU20001)); [EOL] }
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testContainsAny_StringWithSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000)); [EOL]     assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001)); [EOL]     assertFalse(StringUtils.containsAny(CharU20000, CharU20000)); [EOL]     assertFalse(StringUtils.containsAny(CharU20000, CharU20001)); [EOL] }
@Test [EOL] public void testToCharArray() { [EOL]     assertArrayEquals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc")); [EOL]     assertArrayEquals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc")); [EOL]     final char[] a = StringUtils.toCharArray("abc"); [EOL]     assertNotNull(a); [EOL]     assertEquals(3, a.length); [EOL]     assertTrue(Arrays.equals(new char[] { 'a', 'b' }, a)); [EOL]     assertTrue(Arrays.equals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abc"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'a', 'b' }, StringUtils.toCharArray("abcd"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'c', 'd', 'e', 'f' }, StringUtils.toCharArray("abcde"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'a', 'b', 'c', 'd' }, StringUtils.toCharArray("abcd"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'd', 'e', 'f' }, StringUtils.toCharArray("abcd"))); [EOL]     assertTrue(Arrays.equals(new char[] { 'c', 'd', 'e', 'f' }, StringUtils.toCharArray("abcde"))); [EOL] }
@Test [EOL] public void testEscapeSurrogatePairs() throws Exception { [EOL]     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); [EOL]     assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); [EOL]     assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); [EOL]     assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); [EOL] }
@Test [EOL] public void testContainsAny_StringWithBadSupplementaryChars() { [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); [EOL]     assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); [EOL]     assertTrue(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); [EOL]     assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); [EOL]     assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL]     assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); [EOL]     assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testJoin_ArrayOfDoubles() { [EOL]     assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]     assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]     assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testRandomStringUtils() { [EOL]     String r1 = RandomStringUtils.random(50); [EOL]     assertEquals("random(50) length", 50, r1.length()); [EOL]     String r2 = RandomStringUtils.random(50); [EOL]     assertEquals("random(50) length", 50, r2.length()); [EOL]     assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]     r1 = RandomStringUtils.randomAscii(50); [EOL]     assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]     for (int i = 0; i < r1.length(); i++) { [EOL]         assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]     } [EOL]     r2 = RandomStringUtils.randomAscii(50); [EOL]     assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]     r1 = RandomStringUtils.randomAlphabetic(50); [EOL]     assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]     for (int i = 0; i < r1.length(); i++) { [EOL]         assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]     } [EOL]     r2 = RandomStringUtils.randomAlphabetic(50); [EOL]     assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]     r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]     assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]     for (int i = 0; i < r1.length(); i++) { [EOL]         assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]     } [EOL
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testExceptions() { [EOL]     final char[] DUMMY = new char[] { 'a' }; [EOL]     try { [EOL]         RandomStringUtils.random(-1); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, true, true); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, DUMMY); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, new char[0]); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, (String) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', '
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testExceptions() { [EOL]     final char[] DUMMY = new char[] { 'a' }; [EOL]     try { [EOL]         RandomStringUtils.random(-1); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, true, true); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, DUMMY); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, new char[0]); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, (String) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', '
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testExceptions() { [EOL]     final char[] DUMMY = new char[] { 'a' }; [EOL]     try { [EOL]         RandomStringUtils.random(-1); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, true, true); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, DUMMY); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, new char[0]); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, (String) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', '
@Test [EOL] public void testRandomStringUtils() { [EOL]     String r1 = RandomStringUtils.random(50); [EOL]     assertEquals("random(50) length", 50, r1.length()); [EOL]     String r2 = RandomStringUtils.random(50); [EOL]     assertEquals("random(50) length", 50, r2.length()); [EOL]     assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]     r1 = RandomStringUtils.randomAscii(50); [EOL]     assertEquals("randomAscii(50) length", 50, r1.length()); [EOL]     for (int i = 0; i < r1.length(); i++) { [EOL]         assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); [EOL]     } [EOL]     r2 = RandomStringUtils.randomAscii(50); [EOL]     assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]     r1 = RandomStringUtils.randomAlphabetic(50); [EOL]     assertEquals("randomAlphabetic(50)", 50, r1.length()); [EOL]     for (int i = 0; i < r1.length(); i++) { [EOL]         assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); [EOL]     } [EOL]     r2 = RandomStringUtils.randomAlphabetic(50); [EOL]     assertTrue("!r1.equals(r2)", !r1.equals(r2)); [EOL]     r1 = RandomStringUtils.randomAlphanumeric(50); [EOL]     assertEquals("randomAlphanumeric(50)", 50, r1.length()); [EOL]     for (int i = 0; i < r1.length(); i++) { [EOL]         assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); [EOL]     } [EOL
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testExceptions() { [EOL]     final char[] DUMMY = new char[] { 'a' }; [EOL]     try { [EOL]         RandomStringUtils.random(-1); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, true, true); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, DUMMY); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, new char[0]); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, (String) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         RandomStringUtils.random(-1, 'a', '
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testLANG805() { [EOL]     final long seed = System.currentTimeMillis(); [EOL]     assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[] { 'a' }, new Random(seed))); [EOL] }
@Test [EOL] public void testInitializerNames() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     final Set<String> initializerNames = initializer.initializerNames(); [EOL]     assertEquals(2, initializerNames.size()); [EOL]     assertTrue(initializerNames.contains(CHILD_INIT)); [EOL]     assertTrue(initializerNames.contains(CH_INIT_1)); [EOL]     assertTrue(initializerNames.contains(CH_INIT_2)); [EOL]     assertTrue(initializerNames.contains(CH_INIT_3)); [EOL]     initializerNames = initializer.initializerNames(); [EOL]     assertEquals(3, initializerNames.size()); [EOL]     assertTrue(initializerNames.contains(CH_INIT_1)); [EOL]     assertTrue(initializerNames.contains(CH_INIT_2)); [EOL]     assertTrue(initializerNames.contains(CH_INIT_3)); [EOL]     initializerNames = initializer.initializerNames(); [EOL]     assertEquals(2, initializerNames.size()); [EOL]     assertTrue(initializerNames.contains(CH_INIT_1)); [EOL]     assertTrue(initializerNames.contains(CH_INIT_2)); [EOL]     assertTrue(initializerNames.contains(CH_INIT_3)); [EOL] }
@Test [EOL] public void testIsException() { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi2.addInitializer(CHILD_INIT, mi2); [EOL]     initializer.addInitializer(CH_INIT, mi2); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi3.addInitializer(CH_INIT, mi3); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     assertFalse("Wrong success flag", mi5.isException(CHILD_INIT)); [EOL]     assertTrue("Wrong success flag", mi6.isException(CH_INIT)); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong success flag", mi2.getInitializer(CH_INIT).booleanValue()); [EOL]     assertTrue("Wrong success flag", mi2.getInitializer(CH_INIT).booleanValue()); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final List<MultiBackgroundInitializer> list = new ArrayList<MultiBackgroundInitializer>(); [EOL]     list.addAll(Arrays.asList(mi1, mi2, mi3, mi4, mi5)); [EOL]     assertFalse("Wrong number of initializers", list.contains(mi1)); [EOL]     assertTrue("Wrong number of initializers", list.contains(mi2)); [EOL]     assertTrue("Wrong number of initializers", list.contains(mi3)); [EOL]     assertTrue("Wrong number of results", list.contains(mi
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi2.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi3.addInitializer(CHILD_INIT, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final Map<String, MultiBackgroundInitializer> inits = new HashMap<String, MultiBackgroundInitializer>(); [EOL]     inits.put(CHILD_INIT, mi4); [EOL]     inits.put(MIXED_INIT, mi5); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     inits.put(MIXED_INIT, mi7); [EOL]     final MultiBackgroundInitializerResults res = initializer.get(); [EOL]     final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res.getInitializer(MIXED_INIT); [EOL]     assertEquals("Wrong number of initializers", 2, res.initializerNames().size()); [EOL]     assertEquals("Wrong number of initializers", 1, res2.initializerNames().size()); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         checkInitialize(res.getInitializer(MIXED_INIT), res2.getInitializer(MIXED_INIT)); [EOL]     }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     try { [EOL]         mi1.addInitializer(CHILD_INIT, mi2); [EOL]
@Test [EOL] public void testInitializeExternalExec() throws ConcurrentException { [EOL]     final String nameMulti = "multiChildInitializer"; [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(nameMulti, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(exec); [EOL]     mi2.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(nameMulti, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(exec); [EOL]     mi3.addInitializer(nameMulti, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.getInitializer(nameMulti); [EOL]     final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res.getResultObject(nameMulti); [EOL]     assertEquals("Wrong number of initializers", 2, res.initializerNames().size()); [EOL]     assertTrue("Wrong number of initializers", res.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", res2.initializerNames().contains(nameMulti)); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi6.addInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]
@Test [EOL] public void testGetNullInitializer() throws ConcurrentException { [EOL]     initializer = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi2.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi3.addInitializer(null, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi3, mi5); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     assertFalse("Wrong initializer", initializer.getInitializer(null).equals(initializer.getInitializer(mi5))); [EOL]     assertFalse("Wrong initializer", initializer.getInitializer(mi6).equals(initializer.getInitializer(mi7))); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi2.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi3.addInitializer(CHILD_INIT, mi3); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7.addInitializer(mi8, mi7); [EOL]     final MultiBackgroundInitializer mi8.addInitializer(mi7, mi8); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi.initializerNames().size() == 3); [EOL]     assertTrue("Wrong number of initializers", mi.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of results", mi.results.size() == 1);
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(); [EOL]     mi2.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(); [EOL]     mi3.addInitializer(MIXED_INIT, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(); [EOL]     mi4.addInitializer(MIXED_INIT, mi4); [EOL]     initializer.addInitializer(MIXED_INIT, mi3); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(); [EOL]     mi6.addInitializer(MIXED_INIT, mi5); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miA = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miB = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miC = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miC.addInitializer(MIXED_INIT, miA); [EOL]     final MultiBackgroundInitializer miB = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miC.addInitializer(MIXED_INIT, miB); [EOL]     final MultiBackgroundInitializer miC.addInitializer(MIXED_INIT, miC); [EOL]     final MultiBackgroundInitializer miA = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miB = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miC.addInitializer(MIXED_INIT, miB); [EOL]     final MultiBackgroundInitializer miC.addInitializer(
@Test [EOL] public void testAddInitializerAfterStart() throws ConcurrentException { [EOL]     initializer.start(); [EOL]     try { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         fail("Could add initializer after start()!"); [EOL]     } catch (final IllegalStateException istex) { [EOL]         initializer.get(); [EOL]     } [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi1.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi3.initializerNames().contains(CHILD_INIT)); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     try { [EOL]         initializer.add
@Test [EOL] public void testIsException() { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi2.addInitializer(CHILD_INIT, mi2); [EOL]     initializer.addInitializer(CH_INIT, mi2); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi3.addInitializer(CH_INIT, mi3); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     assertFalse("Wrong success flag", mi5.isException(CHILD_INIT)); [EOL]     assertTrue("Wrong success flag", mi6.isException(CH_INIT)); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     try { [EOL]         mi1.addInitializer(CHILD_INIT, mi2); [EOL]
@Test [EOL] public void testAddInitializerAfterStart() throws ConcurrentException { [EOL]     initializer.start(); [EOL]     try { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         fail("Could add initializer after start()!"); [EOL]     } catch (final IllegalStateException istex) { [EOL]         initializer.get(); [EOL]     } [EOL] }
@Test [EOL] public void testIsStartedAfterGet() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     init.start(); [EOL]     checkInitialize(init); [EOL]     assertTrue("Not started", init.isStarted()); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi6.addInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.addInitializer(mi3, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7.addInitializer(mi1, mi1); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     assertTrue("Wrong success flag", mi5.isSuccessful()); [EOL]     assertFalse("Wrong success flag", mi6.isSuccessful()); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     try { [EOL]         mi1.addInitializer(CHILD_INIT, mi2); [EOL]
@Test [EOL] public void testAddInitializerAfterStart() throws ConcurrentException { [EOL]     initializer.start(); [EOL]     try { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         fail("Could add initializer after start()!"); [EOL]     } catch (final IllegalStateException istex) { [EOL]         initializer.get(); [EOL]     } [EOL] }
@Test [EOL] public void testInitializerNames() throws ConcurrentException { [EOL]     initializer.addInitializer(INIT_1, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(INIT_2, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(INIT_3, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(INIT_4, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(INIT_5, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(INIT_6, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(INIT_7, new ChildBackgroundInitializer()); [EOL]     final Set<String> initializerNames = initializer.initializerNames(); [EOL]     assertEquals(3, initializerNames.size()); [EOL]     assertTrue(initializerNames.contains(INIT_1)); [EOL]     assertTrue(initializerNames.contains(INIT_2)); [EOL]     assertTrue(initializerNames.contains(INIT_3)); [EOL]     assertTrue(initializerNames.contains(INIT_4)); [EOL]     assertTrue(initializerNames.contains(INIT_5)); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(SECOND_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong success flag", mi2.getInitializer(CHILD_INIT).booleanValue()); [EOL]     assertTrue("Wrong success flag", mi2.getInitializer(SECOND_INIT).booleanValue()); [EOL]     assertTrue("Wrong success flag", mi3.booleanValue()); [EOL] }
@Test [EOL] public void testIsException() { [EOL]     initializer.addInitializer("test", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("test2", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("test3", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("test4", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("test5", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("test6", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("test7", new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     assertFalse(mi2.isException("test")); [EOL]     assertTrue(mi2.isException("test")); [EOL]     assertTrue(mi3.isException("test2")); [EOL]     assertTrue(mi4.isException("test")); [EOL]     assertFalse(mi5.isException("test")); [EOL]     assertFalse(mi6.isException("test")); [EOL] }
@Test [EOL] public void testInitializeExternalExec() throws ConcurrentException { [EOL]     final String nameMulti = "multiChildInitializer"; [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(nameMulti, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(exec); [EOL]     mi2.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(nameMulti, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(exec); [EOL]     mi3.addInitializer(nameMulti, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.getInitializer(nameMulti); [EOL]     final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res.getResultObject(nameMulti); [EOL]     assertEquals("Wrong number of initializers", 2, res.initializerNames().size()); [EOL]     assertTrue("Wrong number of initializers", res.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", res2.initializerNames().contains(nameMulti)); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi2.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi3.addInitializer(CHILD_INIT, mi3); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7.addInitializer(mi8, mi7); [EOL]     final MultiBackgroundInitializer mi8.addInitializer(mi7, mi8); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi.initializerNames().size() == 3); [EOL]     assertTrue("Wrong number of initializers", mi.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of results", mi.results.size() == 1);
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(SECOND_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().size() == 3); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi3.initializerNames().contains(SECOND_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi7.initializerNames().contains(FOUR_INIT)); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi6.addInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("", new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer("", new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     initializer.addInitializer(mi1, mi2); [EOL]     initializer.addInitializer(mi3, mi4); [EOL]     initializer.addInitializer(mi5, mi6); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(),
@Test [EOL] public void testGetNullInitializer() throws ConcurrentException { [EOL]     initializer = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi3, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi5, mi5); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi7, mi6); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi8, mi9); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), mi1, mi2, mi3, mi4); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), mi2, mi3, mi4); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), mi1, mi2, mi3, mi4); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.
@Test [EOL] public void testAddInitializerAfterStart() throws ConcurrentException { [EOL]     initializer.start(); [EOL]     try { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         fail("Could add initializer after start()!"); [EOL]     } catch (final IllegalStateException istex) { [EOL]         initializer.get(); [EOL]     } [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.addInitializer(mi3, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7.addInitializer(mi1, mi1); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     assertTrue("Wrong success flag", mi5.isSuccessful()); [EOL]     assertFalse("Wrong success flag", mi6.isSuccessful()); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi16 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer(Executors.newSingleThreadInitializer(Executors.newSingleThreadInitializer()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadInitializer(Executors.newThreadInitializer(Executors.newThreadInitializer(Executors.newThreadInitializer(Executors
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(SECOND_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final Map<String, MultiBackgroundInitializer> initializers = initializer.getInitializer(); [EOL]     assertEquals(2, initializers.size()); [EOL]     assertTrue(initializers.containsKey(CHILD_INIT)); [EOL]     assertEquals(1, initializers.get(SECOND_INIT).getTaskCount()); [EOL]     assertTrue(initializers.containsKey(FOUR_INIT).getTaskCount()); [EOL]     assertTrue(initializers.containsKey(FOUR_INIT).getTaskCount()); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(SECOND_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().size() == 3); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi3.initializerNames().contains(SECOND_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi7.initializerNames().contains(FOUR_INIT)); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CH_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     try { [EOL]         mi1.addInitializer(CHILD_INIT, mi
@Test [EOL] public void testInitializeExternalExec() throws ConcurrentException { [EOL]     final String nameMulti = "multiChildInitializer"; [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(nameMulti, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(exec); [EOL]     mi2.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(nameMulti, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(exec); [EOL]     mi3.addInitializer(nameMulti, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.getInitializer(nameMulti); [EOL]     final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res.getResultObject(nameMulti); [EOL]     assertEquals("Wrong number of initializers", 2, res.initializerNames().size()); [EOL]     assertTrue("Wrong number of initializers", res.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", res2.initializerNames().contains(nameMulti)); [EOL] }
@Test [EOL] public void testIsStartedAfterGet() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     init.start(); [EOL]     checkInitialize(init); [EOL]     assertTrue("Not started", init.isStarted()); [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(SECOND_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi1.initializerNames().contains(SECOND_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().contains(FOUR_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi3.initializerNames().contains(FOUR_INIT)); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi7.initializerNames
@Test [EOL] public void testInitializeExternalExec() throws ConcurrentException { [EOL]     initializer.setExternalExecutor(Executors.newSingleThreadExecutor()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi2.addInitializer(CHILD_INIT, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi3.addInitializer(CHILD_INIT, mi3); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     mi4.addInitializer(CHILD_INIT, mi4); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer miA = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miB = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miC = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miC.addInitializer(AAA, miB); [EOL]     final MultiBackgroundInitializer miA = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miB = new MultiBackgroundInitializer(); [EOL]     final MultiBackgroundInitializer miC.addInitializer(AAA, miC); [EOL]     final MultiBackgroundInitializer miC.setActiveExecutor(Executors.newSingleThreadExecutor()); [EOL]     try { [EOL]         initializer.addInitializer(null, miA); [EOL]         fail("Exception not thrown!"); [EOL]     } catch (final ConcurrentException cex) { [EOL]
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi3, mi6); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     initializer.addInitializer(mi4, mi5); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     assertTrue("Wrong success flag", mi5.isSuccessful()); [EOL]     assertTrue("Wrong success flag", mi6.isSuccessful()); [EOL] }
@Test [EOL] public void testAddInitializerAfterStart() throws ConcurrentException { [EOL]     initializer.start(); [EOL]     try { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         fail("Could add initializer after start()!"); [EOL]     } catch (final IllegalStateException istex) { [EOL]         initializer.get(); [EOL]     } [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(initializer.getActiveExecutor()); [EOL]     final List<MultiBackgroundInitializer> list = new ArrayList<MultiBackgroundInitializer>(); [EOL]     list.addAll(list); [EOL]     assertEquals(2, list.size()); [EOL]     assertTrue(list.contains(mi1)); [EOL]     assertTrue(list.contains(mi2)); [EOL]     assertTrue(list.contains(mi3)); [EOL]     assertTrue(list.contains(mi4)); [EOL]     assertFalse(list
@Test [EOL] public void testAddInitializerAfterStart() throws ConcurrentException { [EOL]     initializer.start(); [EOL]     try { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         fail("Could add initializer after start()!"); [EOL]     } catch (final IllegalStateException istex) { [EOL]         initializer.get(); [EOL]     } [EOL] }
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi6.addInitializer(Executors.newHashMap<String, Object>(), new HashMap<String, Object>()); [EOL]
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi2.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(mi2, mi2); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     mi3.addInitializer(CHILD_INIT, mi3); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7.addInitializer(mi8, mi7); [EOL]     final MultiBackgroundInitializer mi8.addInitializer(mi7, mi8); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(exec, new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi.initializerNames().size() == 3); [EOL]     assertTrue("Wrong number of initializers", mi.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of results", mi.results.size() == 1);
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi15 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     assertTrue("Wrong success flag", mi1.getInitializer(CHILD_INIT).isSuccessful()); [EOL]     assertTrue("Wrong success flag", mi2.isSuccessful()); [EOL]     assertFalse("Wrong success flag", mi3.isSuccessful()); [EOL]     assertFalse("Wrong success flag", mi4.isSuccessful()); [EOL]
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.start(); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi8 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi9 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi10 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi11 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi12 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi13 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi14 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final List<MultiBackgroundInitializer> list = new ArrayList<MultiBackgroundInitializer>(); [EOL]     list.addAll(Arrays.asList(mi1, mi2, mi3, mi4, mi5)); [EOL]     assertFalse("Wrong number of initializers", list.contains(mi1)); [EOL]     assertTrue("Wrong number of initializers", list.contains(mi2)); [EOL]     assertTrue("Wrong number of initializers", list.contains(mi3)); [EOL]     assertTrue("Wrong number of results", list.contains(mi
@Test [EOL] public void testInitializeNested() throws ConcurrentException { [EOL]     initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(SECOND_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     initializer.addInitializer(FOUR_INIT, new ChildBackgroundInitializer()); [EOL]     final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi3 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor()); [EOL]     final MultiBackgroundInitializer mi4 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi5 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi6 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     final MultiBackgroundInitializer mi7 = new MultiBackgroundInitializer(Executors.newSingleThreadExecutor(), new HashMap<String, Object>(), new HashMap<String, Object>()); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().size() == 3); [EOL]     assertTrue("Wrong number of initializers", mi2.initializerNames().contains(CHILD_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi3.initializerNames().contains(SECOND_INIT)); [EOL]     assertTrue("Wrong number of initializers", mi7.initializerNames().contains(FOUR_INIT)); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testPerson() { [EOL]     final Person p = new Person(); [EOL]     p.name = "John Q. Public"; [EOL]     p.age = 45; [EOL]     p.smoker = true; [EOL]     final String pBaseStr = "ToStringStyleTest.Person"; [EOL]     assertEquals(pBaseStr + "[name=John Q. Public,age=45,smoker=true]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testPerson() { [EOL]     final Person p = new Person(); [EOL]     p.name = "John Q. Public"; [EOL]     p.age = 45; [EOL]     p.smoker = true; [EOL]     final String pBaseStr = "ToStringStyleTest.Person"; [EOL]     assertEquals(pBaseStr + "[name=John Q. Public,age=45,smoker=true]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testPerson() { [EOL]     final Person p = new Person(); [EOL]     p.name = "John Q. Public"; [EOL]     p.age = 45; [EOL]     p.smoker = true; [EOL]     final String pBaseStr = "ToStringStyleTest.Person"; [EOL]     assertEquals(pBaseStr + "[name=John Q. Public,age=45,smoker=true]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArrayArray() { [EOL]     long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testPerson() { [EOL]     final Person p = new Person(); [EOL]     p.name = "John Q. Public"; [EOL]     p.age = 45; [EOL]     p.smoker = true; [EOL]     final String pBaseStr = "ToStringStyleTest.Person"; [EOL]     assertEquals(pBaseStr + "[name=John Q. Public,age=45,smoker=true]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); [EOL] }
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testContainsLong() { [EOL]     long[] array = null; [EOL]     assertFalse(ArrayUtils.contains(array, 1L)); [EOL]     array = new long[] { 0, 1, 2, 3, 0 }; [EOL]     assertTrue(ArrayUtils.contains(array, 0L)); [EOL]     assertTrue(ArrayUtils.contains(array, 1L)); [EOL]     assertTrue(ArrayUtils.contains(array, 2L)); [EOL]     assertTrue(ArrayUtils.contains(array, 3L)); [EOL]     assertFalse(ArrayUtils.contains(array, 99L)); [EOL] }
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NaN); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.0d); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-7.d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = F
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NaN); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.0d); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-7.d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0.5); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(-0.5); [EOL]     assertEquals(-1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NaN); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.0d); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-7.d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0.5); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(-0.5); [EOL]     assertEquals(-1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = F
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction("1e+00001"); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("1e+00001"); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("1e+00001"); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("1e+00001"); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction("1e+00001"); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1"); [EOL]     assertEquals(-1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction("-1"); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("1"); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("1"); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = F
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1,
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = F
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NaN); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.0d); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-7.d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NaN); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.0d); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-7.d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NaN); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.0d); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-7.d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0.5); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(-0.5); [EOL]     assertEquals(-1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(-0.5d); [EOL]     assertEquals(-1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = F
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex)
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(Double.POSITIVE_INFINITY, f.getNumerator()); [EOL]     assertEquals(Double.NEGATIVE_INFINITY, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0.5); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(-0.5); [EOL]     assertEquals(-1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testReducedFactory_int_int() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getReducedFraction(0, 1); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(1, 1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(2, 1); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(22, 7); [EOL]     assertEquals(22, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, 10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(6, -10); [EOL]     assertEquals(-3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getReducedFraction(-6, -10); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getReducedFraction(1, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(2, 0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getReducedFraction(-3, 0); [EOL]
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(-1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NaN); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.0d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.0d); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-7.d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(1.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction(-0.5d); [EOL]     assertEquals(-1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(2.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(0.5d); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(-0.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.5d); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final
@Test [EOL] public void testFactory_String_proper() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction("0 0/1"); [EOL]     assertEquals(0, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 1/5"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(5, f.getDenominator()); [EOL]     f = Fraction.getFraction("7 1/2"); [EOL]     assertEquals(15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("1 2/4"); [EOL]     assertEquals(6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     f = Fraction.getFraction("-7 1/2"); [EOL]     assertEquals(-15, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f = Fraction.getFraction("-1 2/4"); [EOL]     assertEquals(-6, f.getNumerator()); [EOL]     assertEquals(4, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction("2 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("a 3"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction("2 b/4"); [EOL]         fail("expecting NumberFormatException"); [EOL]     } catch (final NumberFormatException ex
@Test [EOL] public void testFactory_double() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(Double.NaN); [EOL]     assertEquals(Double.NaN, f.getNumerator()); [EOL]     assertEquals(Double.NaN, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     try { [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(0.5); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f = Fraction.getFraction(-0.5); [EOL]     assertEquals(-1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     try { [EOL]         f = Fraction.getFraction(1.0); [EOL]         fail("expecting ArithmeticException"); [EOL]
@Test [EOL] public void testReduce() { [EOL]     Fraction f = null; [EOL]     f = Fraction.getFraction(50, 75); [EOL]     Fraction result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, -3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(-2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(-2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(2, 3); [EOL]     result = f.reduce(); [EOL]     assertEquals(2, result.getNumerator()); [EOL]     assertEquals(3, result.getDenominator()); [EOL]     f = Fraction.getFraction(0, 1); [EOL]     result = f.reduce(); [EOL]     assertEquals(0, result.getNumerator()); [EOL]     assertEquals(1, result.getDenominator()); [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         result = f.reduce(); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(3, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f2.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(2, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(1, f1.compareTo(f1)); [EOL]     assertEquals(0, f2.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(6, 10); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     f1 = Fraction.getFraction(6, 10); [EOL]     f2 = Fraction.getFraction(-4, -5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(6, -10); [EOL]     f2 = Fraction.getFraction(-4, -5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(+1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(-4, 5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(+1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(-4, 5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(+1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(-4, 5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(+1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(-4, 5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(+1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(-4, 5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testDivide() { [EOL]     Fraction f = null; [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(1, 5); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(3, f.getNumerator()); [EOL]     assertEquals(2, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.ZERO; [EOL]     try { [EOL]         f = f1.divideBy(f2); [EOL]         fail("expecting ArithmeticException"); [EOL]     } catch (final ArithmeticException ex) { [EOL]     } [EOL]     f1 = Fraction.getFraction(0, 5); [EOL]     f2 = Fraction.getFraction(2, 7); [EOL]     f = f1.divideBy(f2); [EOL]     assertSame(Fraction.ZERO, f); [EOL]     f1 = Fraction.getFraction(2, 7); [EOL]     f2 = Fraction.ONE; [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(2, f.getNumerator()); [EOL]     assertEquals(7, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f1); [EOL]     assertEquals(1, f.getNumerator()); [EOL]     assertEquals(1, f.getDenominator()); [EOL]     f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     f2 = Fraction.getFraction(1, Integer.MAX_VALUE); [EOL]     f = f1.divideBy(f2); [EOL]     assertEquals(Integer.MIN_VALUE, f.getNumerator()); [EOL]     assertEquals(1
@Test [EOL] public void testCompareTo() { [EOL]     Fraction f1 = null; [EOL]     Fraction f2 = null; [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f1)); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(3, 5); [EOL]     f2 = Fraction.getFraction(2, 5); [EOL]     assertEquals(1, f1.compareTo(f1)); [EOL]     f2 = Fraction.getFraction(6, 10); [EOL]     assertEquals(0, f1.compareTo(f2)); [EOL]     f1 = Fraction.getFraction(6, -10); [EOL]     f2 = Fraction.getFraction(-4, -5); [EOL]     assertEquals(-1, f1.compareTo(f2)); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testOSMatchesName() { [EOL]     String osName = null; [EOL]     assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL]     osName = ""; [EOL]     assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL]     osName = "Windows 95"; [EOL]     assertTrue(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL]     osName = "Windows NT"; [EOL]     assertTrue(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL]     osName = "OS/2"; [EOL]     assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL] }
@Test [EOL] public void testSetContentStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setContentStart(null); [EOL]     assertEquals("", style.getContentStart()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testSetContentStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setContentStart(null); [EOL]     assertEquals("", style.getContentStart()); [EOL] }
@Test [EOL] public void testSetContentStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setContentStart(null); [EOL]     assertEquals("", style.getContentStart()); [EOL] }
@Test [EOL] public void testJavaVersionMatches() { [EOL]     String javaVersion = null; [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); [EOL]     javaVersion = ""; [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); [EOL]     javaVersion = "1.0"; [EOL]     assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); [EOL]     assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.2", JAVA_1_2, JAVA_1_2); [EOL]     assertEquals("1.5", JAVA_1_6, JAVA_1_5); [EOL]     assertEquals("1.6", JAVA_1_7, JAVA_1_6); [EOL]     assertEquals("1.7", JAVA_1_8, JAVA_1_9); [EOL]     assertEquals("1.0", JAVA_1_9, JAVA_1_0); [EOL]     assertEquals("1.1", JAVA_1_9, JAVA_1_1); [EOL]     assertEquals("1.2", JAVA_1_2, JAVA_1_2); [EOL]     assertEquals("1.3", JAVA_1_3, JAVA_1_3); [EOL]     assertEquals("1.4", JAVA_1_4, JAVA_1_5); [EOL]     assertEquals("1.6", JAVA_1_7, JAVA_1_6); [EOL] }
@Test [EOL] public void testSetSummaryObjectEndText() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setSummaryObjectEndText(null); [EOL]     assertEquals("", style.getSummaryObjectEndText()); [EOL] }
@Test [EOL] public void testToStringObject() { [EOL]     final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]     assertEquals(null, ArrayUtils.toString(null)); [EOL]     assertEquals("<null>", ArrayUtils.toString(null, "<null>")); [EOL]     assertEquals("<null>", ArrayUtils.toString(array, "<null>")); [EOL]     array = null; [EOL]     assertEquals("<null>", ArrayUtils.toString(array, "<null>")); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testGetUserHome() { [EOL]     final File dir = SystemUtils.getUserHome(); [EOL]     Assert.assertNotNull(dir); [EOL]     Assert.assertTrue(dir.exists()); [EOL] }
@Test [EOL] public void testSetContentStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setContentStart(null); [EOL]     assertEquals("", style.getContentStart()); [EOL] }
@Test [EOL] public void testGetUserHome() { [EOL]     final File dir = SystemUtils.getUserHome(); [EOL]     Assert.assertNotNull(dir); [EOL]     Assert.assertTrue(dir.exists()); [EOL] }
@Test [EOL] public void testSetContentStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setContentStart(null); [EOL]     assertEquals("", style.getContentStart()); [EOL] }
@Test [EOL] public void testGetUserHome() { [EOL]     final File dir = SystemUtils.getUserHome(); [EOL]     Assert.assertNotNull(dir); [EOL]     Assert.assertTrue(dir.exists()); [EOL] }
@Test [EOL] public void testOSMatchesName() { [EOL]     String osName = null; [EOL]     assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL]     osName = ""; [EOL]     assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL]     osName = "Windows 95"; [EOL]     assertTrue(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL]     osName = "Windows NT"; [EOL]     assertTrue(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL]     osName = "OS/2"; [EOL]     assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); [EOL] }
@Test [EOL] public void testToStringObject() { [EOL]     final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]     assertEquals(null, ArrayUtils.toString(null)); [EOL]     assertEquals("<null>", ArrayUtils.toString(null, "<null>")); [EOL]     assertEquals("<null>", ArrayUtils.toString(array, "<null>")); [EOL]     array = null; [EOL]     assertEquals("<null>", ArrayUtils.toString(array, "<null>")); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testToString() { [EOL]     final String[] stringArray = null; [EOL]     assertEquals("", ArrayUtils.toString(stringArray)); [EOL]     stringArray = new String[] { "pick" }; [EOL]     assertEquals("pick", ArrayUtils.toString(stringArray)); [EOL]     stringArray = new String[] { "pick", "stick" }; [EOL]     assertEquals("pick", ArrayUtils.toString(stringArray)); [EOL]     stringArray = new String[] { "pick", "stick" }; [EOL]     assertEquals("pick", ArrayUtils.toString(stringArray)); [EOL]     stringArray = new String[] { "pick", "stick" }; [EOL]     assertEquals("pick", ArrayUtils.toString(stringArray)); [EOL]     try { [EOL]         ArrayUtils.toString(new Object[] { "pick", "stick" }); [EOL]         fail("IndexOutOfBoundsException expected"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         ArrayUtils.toString(new Object[] { "pick", "stick" }, null); [EOL]         fail("IndexOutOfBoundsException expected"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         ArrayUtils.toString(new Object[] { "pick", "stick" }, "illegal type"); [EOL]         fail("IndexOutOfBoundsException expected"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL]     try { [EOL]         ArrayUtils.toString(new Object[] { "pick", "stick" }, "illegal type"); [EOL]         fail("IndexOutOfBoundsException expected"); [EOL]     } catch (final IndexOutOfBoundsException e) { [EOL]     } [EOL] }
@Test [EOL] public void testSetFieldSeparatorAtStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setFieldSeparatorAtStart(false); [EOL]     assertFalse(style.isFieldSeparatorAtStart()); [EOL] }
@Test [EOL] public void testToStringObject() { [EOL]     final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]     assertEquals(String.format("{0,1,2,3,0}", ArrayUtils.toString(array)), ArrayUtils.toString(array)); [EOL]     assertEquals(String.format("{0,1,2,3,0}", ArrayUtils.toString(array, "0")); [EOL]     assertEquals(String.format("{0,1,2,3,0}", ArrayUtils.toString(array, "1")); [EOL]     assertEquals(String.format("{1,2,3,0}", ArrayUtils.toString(array, "2")); [EOL]     assertEquals(String.format("{2,3,0,1}", ArrayUtils.toString(array, "3")); [EOL] }
@Test [EOL] public void testSetContentStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setContentStart(null); [EOL]     assertEquals("", style.getContentStart()); [EOL]     style.setContentEnd(null); [EOL]     assertEquals("", style.getContentStart()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testOneArgNull() { [EOL]     assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null)); [EOL]     assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testOneArgNull() { [EOL]     assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null)); [EOL]     assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.2", JAVA_1_2, JAVA_1_2); [EOL]     assertEquals("1.5", JAVA_1_6, JAVA_1_5); [EOL]     assertEquals("1.6", JAVA_1_7, JAVA_1_6); [EOL]     assertEquals("1.7", JAVA_1_8, JAVA_1_9); [EOL]     assertEquals("1.0", JAVA_1_9, JAVA_1_0); [EOL]     assertEquals("1.1", JAVA_1_9, JAVA_1_1); [EOL]     assertEquals("1.2", JAVA_1_2, JAVA_1_2); [EOL]     assertEquals("1.3", JAVA_1_3, JAVA_1_3); [EOL]     assertEquals("1.4", JAVA_1_4, JAVA_1_5); [EOL]     assertEquals("1.6", JAVA_1_7, JAVA_1_6); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testSetContentStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setContentStart(null); [EOL]     assertEquals("", style.getContentStart()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testLongArray() { [EOL]     long[] array = new long[] { 1, 2, -3, 4 }; [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testJavaAwtHeadless() { [EOL]     final boolean atLeastJava14 = SystemUtils.isJavaVersionAtLeast(JAVA_1_4); [EOL]     final String expectedStringValue = System.getProperty("java.awt.headless"); [EOL]     final String expectedStringValueWithDefault = System.getProperty("java.awt.headless", "false"); [EOL]     final String expectedStringValueWithDefault = SystemUtils.getProperty("java.awt.headless", "true"); [EOL]     assertNotNull(expectedStringValueWithDefault); [EOL]     if (atLeastJava14) { [EOL]         final boolean expectedValue = Boolean.valueOf(expectedStringValue).booleanValue(); [EOL]         if (expectedStringValue != null) { [EOL]             assertEquals(expectedStringValueWithDefault, SystemUtils.JAVA_AWT_HEADLESS); [EOL]             } [EOL]         assertEquals(expectedStringValueWithDefault, SystemUtils.isJavaAwtHeadless()); [EOL]     } else { [EOL]         assertNull(expectedStringValueWithDefault); [EOL]         assertNull(SystemUtils.JAVA_AWT_HEADLESS); [EOL]         assertEquals(expectedStringValueWithDefault, SystemUtils.isJavaAwtHeadless()); [EOL]     } [EOL] }
@Test [EOL] public void testToStringObject() { [EOL]     final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]     assertEquals(null, ArrayUtils.toString(null)); [EOL]     assertEquals("<null>", ArrayUtils.toString(null, "<null>")); [EOL]     assertEquals("<null>", ArrayUtils.toString(array, "<null>")); [EOL]     array = null; [EOL]     assertEquals("<null>", ArrayUtils.toString(array, "<null>")); [EOL] }
@Test [EOL] public void testGet() { [EOL]     assertEquals("1.2", JAVA_1_2, JAVA_1_2); [EOL]     assertEquals("1.5", JAVA_1_6, JAVA_1_5); [EOL]     assertEquals("1.6", JAVA_1_7, JAVA_1_6); [EOL]     assertEquals("1.7", JAVA_1_8, JAVA_1_9); [EOL]     assertEquals("1.0", JAVA_1_9, JAVA_1_0); [EOL]     assertEquals("1.1", JAVA_1_9, JAVA_1_1); [EOL]     assertEquals("1.2", JAVA_1_2, JAVA_1_2); [EOL]     assertEquals("1.3", JAVA_1_3, JAVA_1_3); [EOL]     assertEquals("1.4", JAVA_1_4, JAVA_1_5); [EOL]     assertEquals("1.6", JAVA_1_7, JAVA_1_6); [EOL] }
@Test [EOL] public void testSetContentStart() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setContentStart(null); [EOL]     assertEquals("", style.getContentStart()); [EOL]     style.setContentEnd(null); [EOL]     assertEquals("", style.getContentStart()); [EOL] }
@Test [EOL] public void testToStringObjectString() { [EOL]     final String[] stringArray = null; [EOL]     assertEquals("<null>", ArrayUtils.toString(stringArray)); [EOL]     stringArray = new String[] { "pick" }; [EOL]     assertEquals("<null>", ArrayUtils.toString(stringArray)); [EOL]     stringArray = new String[] { "pick", "stick" }; [EOL]     assertEquals("<null>", ArrayUtils.toString(stringArray)); [EOL]     stringArray = new String[] { "pick", "stick" }; [EOL]     assertEquals("<null>", ArrayUtils.toString(stringArray)); [EOL] }
@Test [EOL] public void testOSMatchesName() { [EOL]     String osName = null; [EOL]     String osVersion = null; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     osName = ""; [EOL]     osVersion = ""; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     osName = "Windows 95"; [EOL]     osVersion = "4.1"; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     osName = "Windows 98"; [EOL]     osVersion = "4.1"; [EOL]     try { [EOL]         SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"); [EOL]         fail("Expected IllegalArgumentException"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testSetSummaryObjectEndText() { [EOL]     final ToStringStyle style = new ToStringStyleImpl(); [EOL]     style.setSummaryObjectEndText(null); [EOL]     assertEquals("", style.getSummaryObjectEndText()); [EOL] }
@Test [EOL] public void testOneArgNull() { [EOL]     assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null)); [EOL]     assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArrayHiddenByObject() { [EOL]     final char[] array1 = new char[2]; [EOL]     array1[0] = 5; [EOL]     array1[1] = 6; [EOL]     final char[] array2 = new char[2]; [EOL]     array2[0] = 5; [EOL]     array2[1] = 6; [EOL]     final char[] array3 = new char[3]; [EOL]     array3[0] = 5; [EOL]     array3[1] = 6; [EOL]     array3[2] = 7; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArrayHiddenByObject() { [EOL]     final char[] array1 = new char[2]; [EOL]     array1[0] = 5; [EOL]     array1[1] = 6; [EOL]     final char[] array2 = new char[2]; [EOL]     array2[0] = 5; [EOL]     array2[1] = 6; [EOL]     final char[] array3 = new char[3]; [EOL]     array3[0] = 5; [EOL]     array3[1] = 6; [EOL]     array3[2] = 7; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArrayHiddenByObject() { [EOL]     final char[] array1 = new char[2]; [EOL]     array1[0] = 5; [EOL]     array1[1] = 6; [EOL]     final char[] array2 = new char[2]; [EOL]     array2[0] = 5; [EOL]     array2[1] = 6; [EOL]     final char[] array3 = new char[3]; [EOL]     array3[0] = 5; [EOL]     array3[1] = 6; [EOL]     array3[2] = 7; [EOL]     final Object obj1 = array1; [EOL]     final Object obj2 = array2; [EOL]     final Object obj3 = array3; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     array1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testCharArray() { [EOL]     final char[] obj1 = new char[2]; [EOL]     obj1[0] = 5; [EOL]     obj1[1] = 6; [EOL]     final char[] obj2 = new char[2]; [EOL]     obj2[0] = 5; [EOL]     obj2[1] = 6; [EOL]     final char[] obj3 = new char[3]; [EOL]     obj3[0] = 5; [EOL]     obj3[1] = 6; [EOL]     obj3[2] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]     obj1[1] = 7; [EOL]     assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]     assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]     assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); [EOL]     assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testLastIndexOfShortWithStartIndex() { [EOL]     short[] array = null; [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     array = new short[] { 0, 1, 2, 3, 0 }; [EOL]     assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); [EOL]     assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); [EOL]     assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); [EOL]     assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); [EOL]     assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testRemoveListenerDuringEvent() throws PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         addDeregisterListener(listenerSupport); [EOL]     } [EOL]     assertEquals(listenerSupport.getListenerCount(), 10); [EOL]     listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); [EOL]     assertEquals(listenerSupport.getListenerCount(), 0); [EOL] }
@Test [EOL] public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { [EOL]     final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); [EOL]     listenerSupport.addListener(new VetoableChangeListener() { [EOL]  [EOL]         @Override [EOL]         public void vetoableChange(final PropertyChangeEvent e) { [EOL]         } [EOL]     }); [EOL]     listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); [EOL]     final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL]     final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); [EOL]     objectOutputStream.writeObject(listenerSupport); [EOL]     objectOutputStream.close(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())).readObject(); [EOL]     final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); [EOL]     assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); [EOL]     assertEquals(1, listeners.length); [EOL]     final VetoableChangeListener listener = listeners[0]; [EOL]     final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); [EOL]     listener.vetoableChange(evt); [EOL]     EasyMock.replay(listener); [EOL]     deserializedListenerSupport.fire().vetoableChange(evt); [EOL]     EasyMock.verify(listener); [EOL]     deserializedListenerSupport.removeListener(listener); [EOL]     assertEquals(0, deserializedListenerSupport.getListeners().length); [EOL] }
@Test [EOL] public void testFloatArrayArray() { [EOL]     float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } }; [EOL]     assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testFloatArrayArray() { [EOL]     float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } }; [EOL]     assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testFloatArrayArray() { [EOL]     float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } }; [EOL]     assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     array = null; [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]     assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL] }
@Test [EOL] public void testToFloat() { [EOL]     assertEquals(Float.valueOf(0f), new MutableFloat(0f).toFloat()); [EOL]     assertEquals(Float.valueOf(123f), new MutableFloat(123f).toFloat()); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementDoubleArray() { [EOL]     double[] array; [EOL]     array = ArrayUtils.removeElements((double[]) null, (double) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1); [EOL]     assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1); [EOL]     assertTrue(Arrays.equals(new double[] { 2, 1 }, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((double[]) null, (double) 1, (double) 2); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1, (double) 2); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1, (double) 2); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test [EOL] @SuppressWarnings("cast") [EOL] public void testRemoveElementDoubleArray() { [EOL]     double[] array; [EOL]     array = ArrayUtils.removeElements((double[]) null, (double) 1); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1); [EOL]     assertTrue(Arrays.equals(new double[] { 2 }, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1); [EOL]     assertTrue(Arrays.equals(new double[] { 2, 1 }, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements((double[]) null, (double) 1, (double) 2); [EOL]     assertNull(array); [EOL]     array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1, (double) 2); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1, (double) 2); [EOL]     assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); [EOL]     assertEquals(Double.TYPE, array.getClass().getComponentType()); [EOL]     array =
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void testRemoveAllFloatArrayNegativeIndex() { [EOL]     ArrayUtils.removeAll(new float[] { 1, 2 }, -1); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0f, new MutableFloat().floatValue(), 0.0001f); [EOL]     assertEquals(1f, new MutableFloat(1f).floatValue(), 0.0001f); [EOL]     assertEquals(2f, new MutableFloat(Float.valueOf(2f)).floatValue(), 0.0001f); [EOL]     assertEquals(3f, new MutableFloat(new MutableFloat(3f)).floatValue(), 0.0001f); [EOL]     assertEquals(2f, new MutableFloat("2.0").floatValue(), 0.0001f); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(0f, new MutableFloat().floatValue(), 0.0001f); [EOL]     assertEquals(1f, new MutableFloat(1f).floatValue(), 0.0001f); [EOL]     assertEquals(2f, new MutableFloat(Float.valueOf(2f)).floatValue(), 0.0001f); [EOL]     assertEquals(3f, new MutableFloat(new MutableFloat(3f)).floatValue(), 0.0001f); [EOL]     assertEquals(2f, new MutableFloat("2.0").floatValue(), 0.0001f); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(null, new MutableObject<String>().getValue()); [EOL]     final Integer i = Integer.valueOf(6); [EOL]     assertSame(i, new MutableObject<Integer>(i).getValue()); [EOL]     assertSame("HI", new MutableObject<String>("HI").getValue()); [EOL]     assertSame(null, new MutableObject<Object>(null).getValue()); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testConstructors() { [EOL]     assertEquals(null, new MutableObject<String>().getValue()); [EOL]     final Integer i = Integer.valueOf(6); [EOL]     assertSame(i, new MutableObject<Integer>(i).getValue()); [EOL]     assertSame("HI", new MutableObject<String>("HI").getValue()); [EOL]     assertSame(null, new MutableObject<Object>(null).getValue()); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); [EOL]     final MutableObject<String> mutNumC = new MutableObject<String>("ALPHA"); [EOL]     assertTrue(mutNumA.equals(mutNumA)); [EOL]     assertTrue(mutNumA.equals(mutNumB)); [EOL]     assertTrue(mutNumB.equals(mutNumA)); [EOL]     assertTrue(mutNumB.equals(mutNumB)); [EOL]     assertFalse(mutNumA.equals(mutNumC)); [EOL]     assertFalse(mutNumB.equals(mutNumC)); [EOL]     assertTrue(mutNumC.equals(mutNumC)); [EOL]     assertFalse(mutNumA.equals(null)); [EOL]     assertFalse(mutNumA.equals("ALPHA")); [EOL] }
@Test [EOL] public void testMin() { [EOL]     final Calendar calendar = Calendar.getInstance(); [EOL]     final Date nonNullComparable1 = calendar.getTime(); [EOL]     final Date nonNullComparable2 = calendar.getTime(); [EOL]     final String[] nullAray = null; [EOL]     calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1); [EOL]     final Date minComparable = calendar.getTime(); [EOL]     assertNotSame(nonNullComparable1, nonNullComparable2); [EOL]     assertNull(ObjectUtils.min((String) null)); [EOL]     assertNull(ObjectUtils.min(nullAray)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(null, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(nonNullComparable1, null)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(nonNullComparable1, nonNullComparable2)); [EOL]     assertSame(nonNullComparable2, ObjectUtils.min(nonNullComparable2, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(nonNullComparable1, minComparable)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(minComparable, nonNullComparable1)); [EOL]     assertSame(nonNullComparable1, ObjectUtils.min(null, nonNullComparable1, null, nonNullComparable1)); [EOL]     assertNull(ObjectUtils.min((String) null, (String) null)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 1, 0, 0, 0)); [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x7800, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x12345678, Conversion.shortArrayToInt(src, 1, 0x12345678, 0, 0)); [EOL]     assertEquals(0xCD345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 24, 1)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123478003456DEF0, 16, 2)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 1, 0, 0, 0)); [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x7800, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x12345678, Conversion.shortArrayToInt(src, 1, 0x12345678, 0, 0)); [EOL]     assertEquals(0xCD345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 24, 1)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testShortArrayToInt() { [EOL]     final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 }; [EOL]     assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); [EOL]     assertEquals(0x000000000000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); [EOL]     assertEquals(0x00000000F0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); [EOL]     assertEquals(0x780034560F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 4)); [EOL]     assertEquals(0x123456789ABCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 0, 0)); [EOL]     assertEquals(0x123456CDF1BCDEF0, Conversion.shortArrayToInt(src, 0, 0x123456789ABCDEF0, 24, 1)); [EOL]     assertEquals(0x123478003456DEF0, Conversion.shortArrayToInt(src, 3, 0x123456789ABCDEF0, 16, 2)); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testContextedExceptionStringThrowableContext() { [EOL]     exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); [EOL]     final String message = exceptionContext.getMessage(); [EOL]     final String trace = ExceptionUtils.getStackTrace(exceptionContext); [EOL]     assertTrue(trace.indexOf("ContextedException") >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE) >= 0); [EOL]     assertTrue(trace.indexOf(TEST_MESSAGE_2) >= 0); [EOL]     assertTrue(message.indexOf(TEST_MESSAGE_2) >= 0); [EOL] }
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, true })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, true, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, true, false })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, true, true })); [EOL]     assertEquals('f', Conversion.binaryBeMsb
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testBinaryBeMsb0ToHexDigit() { [EOL]     assertEquals('0', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, false })); [EOL]     assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, false, true })); [EOL]     assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, false, true, false })); [EOL]     assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('4', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, true })); [EOL]     assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, false })); [EOL]     assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, true, true })); [EOL]     assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { false, true, false, false })); [EOL]     assertEquals('8', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, true })); [EOL]     assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, false })); [EOL]     assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, false, false })); [EOL]     assertEquals('d', Conversion.binaryBeMsb0ToHexDigit(new boolean[] { true, false, true, true })); [EOL]     assertEquals('e', Conversion.binaryBeMsb0ToHex
@Test [EOL] public void testCharSetMatcher_charArray() { [EOL]     final StrMatcher matcher = StrMatcher.charSetMatcher("ace".toCharArray()); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 4)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(new char[0])); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((char[]) null)); [EOL] }
@Test [EOL] public void testCharSetMatcher_String() { [EOL]     final StrMatcher matcher = StrMatcher.charSetMatcher("ace".toCharArray()); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 4)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(new char[0])); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL] }
@Test [EOL] public void testCharSetMatcher_String() { [EOL]     final StrMatcher matcher = StrMatcher.charSetMatcher("ace".toCharArray()); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 4)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(new char[0])); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL] }
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testCharSetMatcher_String() { [EOL]     final StrMatcher matcher = StrMatcher.charSetMatcher("bc"); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 4)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher("")); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL] }
@Test [EOL] public void testCharSetMatcher_charArray() { [EOL]     final StrMatcher matcher = StrMatcher.charSetMatcher("ace".toCharArray()); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]     assertEquals(1, matcher.isMatch(BUFFER2, 4)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(new char[0])); [EOL]     assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((char[]) null)); [EOL] }
@Test [EOL] public void testMatcherIndices() { [EOL]     final StrMatcher matcher = StrMatcher.stringMatcher("bc"); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); [EOL]     assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); [EOL]     assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnfinishedEntity() { [EOL]     NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]     String input = "Test &#x30 not test"; [EOL]     String expected = "Test \u0030 not test"; [EOL]     String result = neu.translate(input); [EOL]     assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     expected = input; [EOL]     result = neu.translate(input); [EOL]     assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     try { [EOL]         result = neu.translate(input); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testUnfinishedEntity() { [EOL]     NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]     String input = "Test &#x30 not test"; [EOL]     String expected = "Test \u0030 not test"; [EOL]     String result = neu.translate(input); [EOL]     assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     expected = input; [EOL]     result = neu.translate(input); [EOL]     assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     try { [EOL]         result = neu.translate(input); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnfinishedEntity() { [EOL]     NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]     String input = "Test &#x30 not test"; [EOL]     String expected = "Test \u0030 not test"; [EOL]     String result = neu.translate(input); [EOL]     assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     expected = input; [EOL]     result = neu.translate(input); [EOL]     assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     try { [EOL]         result = neu.translate(input); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testUnfinishedEntity() { [EOL]     NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]     String input = "Test &#x30 not test"; [EOL]     String expected = "Test \u0030 not test"; [EOL]     String result = neu.translate(input); [EOL]     assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     expected = input; [EOL]     result = neu.translate(input); [EOL]     assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]     input = "Test &#x30 not test"; [EOL]     try { [EOL]         result = neu.translate(input); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnfinishedEntity() { [EOL]     NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]     String input = "Test &#x30 not test"; [EOL]     String expected = "Test \u0030 not test"; [EOL]     String result = neu.translate(input); [EOL]     assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     expected = input; [EOL]     result = neu.translate(input); [EOL]     assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]     input = "Test &#x30 not test"; [EOL]     try { [EOL]         result = neu.translate(input); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testUnfinishedEntity() { [EOL]     NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]     String input = "Test &#x30 not test"; [EOL]     String expected = "Test \u0030 not test"; [EOL]     String result = neu.translate(input); [EOL]     assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     expected = input; [EOL]     result = neu.translate(input); [EOL]     assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL]     input = "Test &#x30 not test"; [EOL]     try { [EOL]         result = neu.translate(input); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnfinishedEntity() { [EOL]     NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); [EOL]     String input = "Test &#x30 not test"; [EOL]     String expected = "Test \u0030 not test"; [EOL]     String result = neu.translate(input); [EOL]     assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     expected = input; [EOL]     result = neu.translate(input); [EOL]     assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); [EOL]     neu = new NumericEntityUnescaper(); [EOL]     input = "Test &#x30 not test"; [EOL]     try { [EOL]         result = neu.translate(input); [EOL]         fail("IllegalArgumentException expected"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testUnescapeHtml4() { [EOL]     for (int i = 0; i < HTML_ESCAPES.length; ++i) { [EOL]         final String message = HTML_ESCAPES[i][0]; [EOL]         final String expected = HTML_ESCAPES[i][2]; [EOL]         final String original = HTML_ESCAPES[i][1]; [EOL]         assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); [EOL]         final StringWriter sw = new StringWriter(); [EOL]         try { [EOL]             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); [EOL]         } catch (final IOException e) { [EOL]         } [EOL]         final String actual = original == null ? null : sw.toString(); [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL]     assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); [EOL]     assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); [EOL]     assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); [EOL]     assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); [EOL]     assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); [EOL] }
@Test [EOL] public void testIsSameDay_Cal() { [EOL]     final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); [EOL]     final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); [EOL]     cal1.set(2004, 6, 9, 13, 45, 0); [EOL]     cal1.set(Calendar.MILLISECOND, 0); [EOL]     cal2.set(2004, 6, 9, 13, 45, 0); [EOL]     cal2.set(Calendar.MILLISECOND, 0); [EOL]     assertTrue(DateUtils.isSameDay(cal1, cal2)); [EOL]     cal2.set(2004, 6, 9, 11, 45, 0); [EOL]     assertFalse(DateUtils.isSameDay(cal1, cal2)); [EOL]     try { [EOL]         DateUtils.isSameDay((Calendar) null, (Calendar) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIsSameDay_Cal() { [EOL]     final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); [EOL]     final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); [EOL]     cal1.set(2004, 6, 9, 13, 45, 0); [EOL]     cal1.set(Calendar.MILLISECOND, 0); [EOL]     cal2.set(2004, 6, 9, 13, 45, 0); [EOL]     cal2.set(Calendar.MILLISECOND, 0); [EOL]     assertTrue(DateUtils.isSameDay(cal1, cal2)); [EOL]     cal2.set(2004, 6, 9, 11, 45, 0); [EOL]     assertFalse(DateUtils.isSameDay(cal1, cal2)); [EOL]     try { [EOL]         DateUtils.isSameDay((Calendar) null, (Calendar) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIsSameDay_Date() { [EOL]     Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); [EOL]     Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); [EOL]     assertTrue(DateUtils.isSameDay(date1, date2)); [EOL]     date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime(); [EOL]     assertFalse(DateUtils.isSameDay(date1, date2)); [EOL]     date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime(); [EOL]     assertTrue(DateUtils.isSameDay(date1, date2)); [EOL]     date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime(); [EOL]     assertFalse(DateUtils.isSameDay(date1, date2)); [EOL]     try { [EOL]         DateUtils.isSameDay((Date) null, (Date) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIsSameDay_Cal() { [EOL]     final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); [EOL]     final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); [EOL]     cal1.set(2004, 6, 9, 13, 45, 0); [EOL]     cal1.set(Calendar.MILLISECOND, 0); [EOL]     cal2.set(2004, 6, 9, 13, 45, 0); [EOL]     cal2.set(Calendar.MILLISECOND, 0); [EOL]     assertTrue(DateUtils.isSameDay(cal1, cal2)); [EOL]     cal2.set(2004, 6, 9, 11, 45, 0); [EOL]     assertFalse(DateUtils.isSameDay(cal1, cal2)); [EOL]     try { [EOL]         DateUtils.isSameDay((Calendar) null, (Calendar) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIsSameDay_Cal() { [EOL]     final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); [EOL]     final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); [EOL]     cal1.set(2004, 6, 9, 13, 45, 0); [EOL]     cal1.set(Calendar.MILLISECOND, 0); [EOL]     cal2.set(2004, 6, 9, 13, 45, 0); [EOL]     cal2.set(Calendar.MILLISECOND, 0); [EOL]     assertTrue(DateUtils.isSameDay(cal1, cal2)); [EOL]     cal2.set(2004, 6, 9, 11, 45, 0); [EOL]     assertFalse(DateUtils.isSameDay(cal1, cal2)); [EOL]     try { [EOL]         DateUtils.isSameDay((Calendar) null, (Calendar) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIsSameDay_Date() { [EOL]     Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); [EOL]     Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); [EOL]     assertTrue(DateUtils.isSameDay(date1, date2)); [EOL]     date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime(); [EOL]     assertFalse(DateUtils.isSameDay(date1, date2)); [EOL]     date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime(); [EOL]     assertTrue(DateUtils.isSameDay(date1, date2)); [EOL]     date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime(); [EOL]     assertFalse(DateUtils.isSameDay(date1, date2)); [EOL]     try { [EOL]         DateUtils.isSameDay((Date) null, (Date) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testIsSameDay_Cal() { [EOL]     final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); [EOL]     final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); [EOL]     cal1.set(2004, 6, 9, 13, 45, 0); [EOL]     cal1.set(Calendar.MILLISECOND, 0); [EOL]     cal2.set(2004, 6, 9, 13, 45, 0); [EOL]     cal2.set(Calendar.MILLISECOND, 0); [EOL]     assertTrue(DateUtils.isSameDay(cal1, cal2)); [EOL]     cal2.set(2004, 6, 9, 11, 45, 0); [EOL]     assertFalse(DateUtils.isSameDay(cal1, cal2)); [EOL]     try { [EOL]         DateUtils.isSameDay((Calendar) null, (Calendar) null); [EOL]         fail(); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]     } [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test(timeout = 666000) [EOL] public void testIsAnnotation() throws Exception { [EOL]     final Test test = getClass().getDeclaredMethod("testIsAnnotation").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(test.getDeclaringClass())); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnnotation1.getDeclaringClass())); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnnotation3.getDeclaringClass())); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnnotation4.getDeclaringClass())); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquivalence() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testValidAnnotationMemberType() { [EOL]     final Test test = getClass().getDeclaredMethod("testValidAnnotationMemberType").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(test.getDeclaringClass())); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation.class)); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation3.class)); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation4.class)); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation5.class)); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation6.class)); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation7.class)); [EOL]     assertFalse(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation8.class)); [EOL]     assertFalse(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation9.class)); [EOL]     assertFalse(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation10.class)); [EOL]     assertFalse(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation11.class)); [EOL]     assertFalse(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation12.class)); [EOL]     assertFalse(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation13.class)); [EOL]     assertFalse(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation14.class)); [EOL]     assertFalse(AnnotationUtils.isValidAnnotationMemberType(TestAnnotation15.class)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquivalence() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testMemberEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testMemberEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testMemberEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testMemberEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquivalence() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testMemberEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testMemberEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(test.isAnnotation(test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(testAnnotation1 != testAnnotation1); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(testAnnotation3 != testAnnotation3); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(testAnnotation4 != testAnnotation4); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testMemberEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testMemberEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testMemberEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testMemberEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test(timeout = 666000) [EOL] public void testValidAnnotationMemberType() throws Exception { [EOL]     final Test testAnno = getClass().getDeclaredMethod("testValidAnnotationMemberType").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, "testString"))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, ""))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, new String("Test"))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, Integer.valueOf(1))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, Long.valueOf(1L))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, Float.valueOf(1.0f))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, Object.class))); [EOL] }
@Test [EOL] public void testBooleanArray() { [EOL]     final boolean[] array1 = new boolean[] { true, false, true }; [EOL]     final boolean[] array2 = new boolean[] { true, false, true }; [EOL]     assertTrue(AnnotationUtils.equals(array1, array1)); [EOL]     assertTrue(AnnotationUtils.equals(array1, array2)); [EOL]     assertFalse(AnnotationUtils.equals(array1, array2)); [EOL]     array1[0] = true; [EOL]     assertTrue(AnnotationUtils.equals(array1, array2)); [EOL]     assertFalse(AnnotationUtils.equals(array1, array2)); [EOL]     array2 = null; [EOL]     assertTrue(AnnotationUtils.equals(array1, array2)); [EOL] }
@Test [EOL] public void testEquivalence() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquivalence() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test [EOL] public void testSameInstance() { [EOL]     assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); [EOL] }
@Test [EOL] public void testMemberEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testMemberEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test(timeout = 666000) [EOL] public void testValidAnnotationMemberType() throws Exception { [EOL]     final Test testAnno = getClass().getDeclaredMethod("testValidAnnotationMemberType").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, "testString"))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, "testInt"))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, "testLong"))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, "testDouble"))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, NumberUtils.INTEGER_ONE))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, NumberUtils.BYTE_ONE))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, NumberUtils.LONG_ONE))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, NumberUtils.DOUBLE_ONE))); [EOL] }
@Test [EOL] public void testEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testEquals").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.equals(test, test)); [EOL]     final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation1, testAnnotation1)); [EOL]     final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation3, testAnnotation3)); [EOL]     final TestAnnotation testAnnotation4 = field4.getAnnotation(TestAnnotation.class); [EOL]     assertTrue(AnnotationUtils.equals(testAnnotation4, testAnnotation4)); [EOL] }
@Test(timeout = 666000) [EOL] public void testValidAnnotationMemberType() throws Exception { [EOL]     final Test testAnno = getClass().getDeclaredMethod("testValidAnnotationMemberType").getAnnotation(Test.class); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, "testString"))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, ""))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, new String("Test"))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, Integer.valueOf(1))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, Long.valueOf(1L))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, Float.valueOf(1.0f))); [EOL]     assertTrue(AnnotationUtils.isValidAnnotationMemberType(testAnno.getAnnotation(TestAnnotation.class, Object.class))); [EOL] }
@Test [EOL] public void testArrayMemberEquals() { [EOL]     final Test test = getClass().getDeclaredMethod("testArrayMemberEquals").getAnnotation(Test.class); [EOL]     assertTrue(test.isAccessible()); [EOL]     final TestAnnotation[] array1 = new TestAnnotation[3]; [EOL]     final TestAnnotation[] array2 = new TestAnnotation[3]; [EOL]     for (int i = 0; i < array1.length; ++i) { [EOL]         for (int j = 0; j < array1[0].length; j++) { [EOL]             array1[i][j] = (i + 1) * (j + 1); [EOL]             array2[i][j] = (i + 1) * (j + 1); [EOL]         } [EOL]     } [EOL]     assertFalse(test.isPresent()); [EOL]     array1[1][1] = (i + 1) * (j + 1); [EOL]     assertTrue(test.isPresent()); [EOL]     array2[1][1] = (i + 1) * (j + 1); [EOL]     assertFalse(test.isPresent()); [EOL]     array1[2][1] = (i + 1) * (j + 1); [EOL]     assertTrue(test.isPresent()); [EOL]     array2[2][1] = (i + 1) * (j + 1); [EOL]     assertFalse(test.isPresent()); [EOL] }
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
@Test [EOL] public void testToLocale_1Part() { [EOL]     assertEquals(null, LocaleUtils.toLocale((String) null)); [EOL]     assertValidToLocale("us"); [EOL]     assertValidToLocale("fr"); [EOL]     assertValidToLocale("de"); [EOL]     assertValidToLocale("zh"); [EOL]     assertValidToLocale("qq"); [EOL]     try { [EOL]         LocaleUtils.toLocale("Us"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("uS"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u#"); [EOL]         fail("Should fail if not lowercase"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("u"); [EOL]         fail("Must be 2 chars if less than 5"); [EOL]     } catch (final IllegalArgumentException iae) { [EOL]     } [EOL]     try { [EOL]         LocaleUtils.toLocale("
