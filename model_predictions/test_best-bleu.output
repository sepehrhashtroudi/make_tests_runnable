@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testToString() { [EOL]         assertEquals("{}", StrLookup.toString(null)); [EOL]         assertEquals("{}", StrLookup.toString(new Object[0])); [EOL]         assertEquals("{}", StrLookup.toString(new String[0])); [EOL]         assertEquals("{<null>}", StrLookup.toString(new String[] {null})); [EOL]         assertEquals("{pink,blue}", StrLookup.toString(new String[] {"pink","blue"})); [EOL]          [EOL]         assertEquals("<empty>", StrLookup.toString(null, "<empty>")); [EOL]         assertEquals("{}", StrLookup.toString(new Object[0], "<empty>")); [EOL]         assertEquals("{<null>}", StrLookup.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", StrLookup.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]          [EOL]         assertEquals("{<null>}", StrLookup.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", StrLookup.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals(" c", tok.next()); [EOL]          [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertEquals("d e", tok.next()); [EOL]          [EOL]         tok.reset("e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]          [EOL]         tok.reset("f"); [EOL]         assertEquals("f", tok.next()); [EOL]         assertEquals("g", tok.next()); [EOL]         assertEquals("h", tok.next()); [EOL]          [EOL]         tok.reset("i"); [EOL]         assertEquals("h", tok.next()); [EOL]         assertEquals("i", tok.next()); [EOL]          [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Range<Integer> ri1 = Range.is(10); [EOL]         final Range<Integer> ri2 = Range.is(10); [EOL]         assertEquals(ri1, ri2); [EOL]         assertEquals(ri1.hashCode(), ri2.hashCode()); [EOL]         ri1.hashCode(); [EOL]         ri2.hashCode(); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementBooleanArray() { [EOL]         boolean[] array; [EOL]         array = ArrayUtils.removeElement((boolean[]) null, true); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true}, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false, true}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] array = new int[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToInt() { [EOL]         assertEquals(0, Conversion.hexDigitToInt('0')); [EOL]         assertEquals(1, Conversion.hexDigitToInt('1')); [EOL]         assertEquals(2, Conversion.hexDigitToInt('2')); [EOL]         assertEquals(3, Conversion.hexDigitToInt('3')); [EOL]         assertEquals(4, Conversion.hexDigitToInt('4')); [EOL]         assertEquals(5, Conversion.hexDigitToInt('5')); [EOL]         assertEquals(6, Conversion.hexDigitToInt('6')); [EOL]         assertEquals(7, Conversion.hexDigitToInt('7')); [EOL]         assertEquals(8, Conversion.hexDigitToInt('8')); [EOL]         assertEquals(9, Conversion.hexDigitToInt('9')); [EOL]         assertEquals(10, Conversion.hexDigitToInt('A')); [EOL]         assertEquals(11, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(12, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(13, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(14, Conversion.hexDigitToInt('E')); [EOL]         assertEquals(15, Conversion.hexDigitToInt('F')); [EOL]         assertEquals(16, Conversion.hexDigitToInt('a')); [EOL]         assertEquals(32, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(6, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(7, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(8, Conversion.hexDigitToInt('E')); [EOL]         assertEquals(9, Conversion.hexDigitToInt('F')); [EOL]         assertEquals(10, Conversion.hexDigitToInt('a')); [EOL]         assertEquals(11, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(12, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(13, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(14, Conversion.hexDigitToInt('E
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x10, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x11, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0x12, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0x13, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals('c')); [EOL]         assertEquals(0x14, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0x15,
@Test [EOL]     public void testGetCharsInt_charArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         char[] a = new char[10]; [EOL]         sb.getChars(0, 0, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, 1, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, -1, a, 0); [EOL]         try { [EOL]             sb.getChars(0, -1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(0, 1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, 1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(-1, 1, a, 0); [EOL]             fail("getChars(int, int, char[], 0) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars
@Test [EOL]     public void testNullToEmptyFloatObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Float[]) null)); [EOL]         // Test valid array handling [EOL]         final Float[] original = new Float[] {0f, 0f}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Float[] empty = new Float[]{}; [EOL]         final Float[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0],
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(4d)); [EOL]         assertEquals(4d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(5d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCapitalize_String() { [EOL]         assertEquals(null, StringUtils.capitalize(null)); [EOL]         assertEquals("", StringUtils.capitalize("")); [EOL]         assertEquals("  ", StringUtils.capitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.capitalize("I") ); [EOL]         assertEquals("I", WordUtils.capitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.capitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.capitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.capitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.capitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.capitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getReducedFraction(-6, 10); [EOL]         assertEquals(-3, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getReducedFraction(1, -6); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         final short[][] array3 = new short[2][3]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array2[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array3[i][j] = (short)((i + 1) * (j + 1)); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWrapperToPrimitive() { [EOL] //        assertEquals(boolean.class, ClassUtils.wrapperToPrimitive(boolean.class)); [EOL]         assertEquals(byte.class, ClassUtils.wrapperToPrimitive(byte.class)); [EOL]         assertEquals(char.class, ClassUtils.wrapperToPrimitive(char.class)); [EOL]         assertEquals(short.class, ClassUtils.wrapperToPrimitive(short.class)); [EOL]         assertEquals(int.class, ClassUtils.wrapperToPrimitive(int.class)); [EOL]         assertEquals(long.class, ClassUtils.wrapperToPrimitive(long.class)); [EOL]         assertEquals(float.class, ClassUtils.wrapperToPrimitive(float.class)); [EOL]         assertEquals(double.class, ClassUtils.wrapperToPrimitive(double.class)); [EOL]  [EOL]         // Inner types [EOL]         class Named extends Object {} [EOL]         assertEquals(Object.class, ClassUtils.wrapperToPrimitive(new Object(){}.getClass())); [EOL]         assertEquals(Object.class, ClassUtils.wrapperToPrimitive(new Object(){}.getClass())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers,
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, -1, -2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]         assertEquals("",
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]         ExceptionUtils.removeCommonFrames(withoutCause, null); [EOL]         assertEquals(0, throwables.length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(4, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "1", "2", "3", "4" }); [EOL]         assertEquals(5, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assertEquals("4
@Test [EOL]     public void testLongArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode()); [EOL]         final long[] obj = new long[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5L; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6L; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6L, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testHandleCauseChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.handleCause(new ExecutionException(ex)); [EOL]             fail("ConcurrentException not thrown!"); [EOL]         } catch (final ConcurrentException cex) { [EOL]             assertEquals("Wrong cause", ex, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests handleCause() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_char_int() { [EOL]         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); [EOL]         assertEquals(2, sb.indexOf('a', -1)); [EOL]         assertEquals(2, sb.indexOf('z', 0)); [EOL]         assertEquals(-1, sb.indexOf('a', 1)); [EOL]         assertEquals(-1, sb.indexOf('z', 2)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(4, sb.indexOf('a', 3)); [EOL]         assertEquals(4, sb.indexOf('z', 2)); [EOL]         assertEquals(-1, sb.indexOf('z', -1)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(6, sb.indexOf('a', 5)); [EOL]         assertEquals(5, sb.indexOf('z', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testRightPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.rightPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, null)); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, "")); [EOL]          [EOL]         final String str = StringUtils.rightPad("aaa", 10000, "ab");  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); [EOL]         child.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue("Wrong success flag", res.isSuccessful()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAppendln_StringBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent explicit cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testCharSetMatcher_String() { [EOL]         final StrMatcher matcher = StrMatcher.charSetMatcher("ace"); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 4)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher("")); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testClone() { [EOL]         final CloneFailedException ex = new CloneFailedException("Test"); [EOL]         assertEquals("Test", ex.getMessage()); [EOL]         assertNull(ex.getCause()); [EOL]          [EOL]         final CloneFailedException ex2 = new CloneFailedException("Test"); [EOL]         assertEquals("Test", ex2.getMessage()); [EOL]         assertNull(ex2.getCause()); [EOL]          [EOL]         ex = new CloneFailedException(null); [EOL]         assertEquals("Test", ex.getMessage()); [EOL]         assertNull(ex.getCause()); [EOL]          [EOL]         ex = new CloneFailedException("Test", null); [EOL]         assertEquals("Test", ex.getMessage()); [EOL]          [EOL]         ex = new CloneFailedException("Test", ex); [EOL]         assertEquals("Test", ex.getMessage()); [EOL]          [EOL]         ex = new CloneFailedException("Test", ex2); [EOL]         assertEquals("Test", ex.getMessage()); [EOL]          [EOL]         ex = new CloneFailedException("Test", ex); [EOL]         assertEquals("Test", ex.getMessage()); [EOL]          [EOL]         ex = new CloneFailedException("Test", ex); [EOL]         assertEquals("Test", ex.getMessage()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testStripToNull() { [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals("", StringUtils.stripToNull("")); [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]          [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]         assertEquals("abc", StringUtils.stripToNull("  abc  ")); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAppendIfMissingIgnoreCase() { [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("xyzabc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.appendIfMissingIgnoreCase("XYZabc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (false, true)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.ex); [EOL]         assertTrue(res.isException(CHILD_INIT)); [EOL]         assertFalse(res.isException(null)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testStripStart_StringString() { [EOL]         // null stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, null)); [EOL]         assertEquals("", StringUtils.stripStart("", null)); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("  ", StringUtils.stripStart("  ", "")); [EOL]          [EOL]         // " " stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, " ")); [EOL]         assertEquals("", StringUtils.stripStart("", " ")); [EOL]         assertEquals("", StringUtils.stripStart("  ", " ")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " ")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("ab", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" strip
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 00:00:00.000"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13, 45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]                 dateParser.parse("November 13, 45:01.231"), [EOL]                 DateUtils.round(date3, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assert
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode()); [EOL]         final int[] obj = new int[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testToStringBuilder() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertEquals("", sb.toStringBuilder().toString()); [EOL]          [EOL]         sb.append("HelloWorld"); [EOL]         assertEquals("HelloWorld", sb.toStringBuilder().toString()); [EOL]          [EOL]         sb.append(""); [EOL]         assertEquals("HelloWorld", sb.toStringBuilder().toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void testGetAccessibleMethod() throws Exception { [EOL]         assertEquals("()", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]         assertEquals("()", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, (Object[]) null).toString()); [EOL]         assertEquals("(String)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, "").toString()); [EOL]         assertEquals("(Object)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, new Object()).toString()); [EOL]         assertEquals("(Integer)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]         assertEquals("(double)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, new Object[] { NumberUtils.DOUBLE_ONE }, [EOL]                 new Class[] { Double.TYPE }).toString()); [EOL]  [EOL]         try { [EOL]             ConstructorUtils.getAccessibleConstructor(TestBean.class, [EOL]                     NumberUtils.BYTE_ONE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]         try { [EOL]             ConstructorUtils.getAccessibleConstructor(TestBean.class, [EOL]                     NumberUtils.LONG_ONE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]         try { [EOL]             ConstructorUtils.getAccessibleConstructor(TestBean.class, [EOL]                     Boolean.TRUE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]         try { [EOL]             ConstructorUtils.getAccessibleConstructor(TestBean.class, [EOL]                     Boolean.FALSE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAddValuePrimitive() { [EOL]         final MutableFloat mutNum = new MutableFloat(1); [EOL]         mutNum.add(1); [EOL]          [EOL]         assertEquals(2.0f, mutNum.floatValue(), 0.01f); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvert() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction(50, 75); [EOL]         f = f.invert(); [EOL]         assertEquals(75, f.getNumerator()); [EOL]         assertEquals(50, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(4, 3); [EOL]         f = f.invert(); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(-15, 47); [EOL]         f = f.invert(); [EOL]         assertEquals(-47, f.getNumerator()); [EOL]         assertEquals(15, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(0, 3); [EOL]         try { [EOL]             f = f.invert(); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         // large values [EOL]         f = Fraction.getFraction(Integer.MIN_VALUE, 1); [EOL]         try { [EOL]             f = f.invert(); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         f = Fraction.getFraction(Integer.MAX_VALUE, 1); [EOL]         f = f.invert(); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(Integer.MAX_VALUE, f.getDenominator()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testGetContextValues() { [EOL]         exceptionContext.addContextValue("test2", "different value"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test1") == null); [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("some value")); [EOL]         assertTrue(exceptionContext.getFirstContextValue("crap") == null); [EOL]  [EOL]         exceptionContext.setContextValue("test2", "another"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("another")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testBooleanArrayAsObject() { [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTrimToEmpty() { [EOL]         assertEquals("", StringUtils.trimToEmpty(null)); [EOL]         assertEquals("", StringUtils.trimToEmpty("")); [EOL]         assertEquals("", StringUtils.trimToEmpty("  \u000C  \t\t\u001F\n\n \u000B  ")); [EOL]         assertEquals("", StringUtils.trimToEmpty("")); [EOL]         assertEquals("", StringUtils.trimToEmpty(StringUtilsTest.TRIMMABLE)); [EOL]         assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToEmpty(StringUtilsTest.NON_TRIMMABLE)); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.trimToEmpty(StringUtilsTest.WHITESPACE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testUpperCase() { [EOL]         assertEquals(null, StringUtils.upperCase(null)); [EOL]         assertEquals("", StringUtils.upperCase("")); [EOL]         assertEquals("  ", StringUtils.upperCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.upperCase("I") ); [EOL]         assertEquals("I", WordUtils.upperCase("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.upperCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.upperCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.upperCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.upperCase("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test(timeout = 666000) [EOL]     public void testGetShortClassName() throws Exception { [EOL]         assertEquals("Test", AnnotationUtils.getShortClassName(field1.getAnnotation(Test.class))); [EOL]         assertEquals("TestAnnotation1", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation1.class))); [EOL]         assertEquals("TestAnnotation2", AnnotationUtils.getShortClassName(field2.getAnnotation(TestAnnotation2.class))); [EOL]         assertEquals("TestAnnotation3", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation3.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMaxShort() { [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 1", [EOL]             5, [EOL]             NumberUtils.max(new short[] { 5 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 2", [EOL]             9, [EOL]             NumberUtils.max(new short[] { 6, 9 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 5", [EOL]             10, [EOL]             NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testRemoveElementByte() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElement((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2, 1}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testAddMilliseconds() throws Exception { [EOL]         final Date base = new Date(MILLIS_TEST); [EOL]         Date result = DateUtils.addMilliseconds(base, 0); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addMilliseconds(base, 1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addMilliseconds(base, -1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testGetImplicitLowerBounds() throws Exception { [EOL]         final WildcardType wildcardType = (WildcardType) getClass().getField("hello").getGenericType(); [EOL]         final Type[] expected = new Type[] {String.class}; [EOL]         Assert.assertArrayEquals(expected, TypeUtils.getImplicitLowerBounds(wildcardType)); [EOL]         Assert.assertArrayEquals(expected, TypeUtils.getImplicitLowerBounds(null)); [EOL]     } [EOL]  [EOL]     public Iterable<? extends Map<Integer, ? extends Collection<?>>> iterable; [EOL]  [EOL]     public static <G extends Comparable<G>> G stub() { [EOL]         return null; [EOL]     } [EOL]  [EOL]     public static <T extends Comparable<? extends T>> T stub2() { [EOL]         return null; [EOL]     } [EOL]  [EOL]     public static <T extends Comparable<? extends T>> T stub3() { [EOL]         return null; [EOL]     } [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testIsRegistered() { [EOL]         assertFalse(HashCodeBuilder.isRegistered(null)); [EOL]         assertTrue(HashCodeBuilder.isRegistered(new Object())); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new String(""))); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new int[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new long[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new short[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new char[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new char[] { 'f', 'o', 'o' })); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new float[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new double[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new float[] { 'f', 'O', 'O' })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDelete_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.delete(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.delete("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.delete("", new String[0])); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.delete("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.delete("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", "")); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.delete("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.delete("hello", new String[] { "l" })); [EOL]     } [EOL]      [EOL] } [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testAppend() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testIdentityToStringStringBuilder() { [EOL]         final Integer i = Integer.valueOf(45); [EOL]         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); [EOL]  [EOL]         final StringBuilder builder = new StringBuilder(); [EOL]         ObjectUtils.identityToString(builder, i); [EOL]         assertEquals(expected, builder.toString()); [EOL]  [EOL]         try { [EOL]             ObjectUtils.identityToString((StringBuilder)null, "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), null); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphas() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertFalse(StringUtils.isAlpha("a")); [EOL]         assertFalse(StringUtils.isAlpha("A")); [EOL]         assertFalse(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertTrue(StringUtils.isAlpha("1")); [EOL]         assertTrue(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToString() { [EOL]         assertEquals("{}", ArrayUtils.toString(null)); [EOL]         assertEquals("{}", ArrayUtils.toString(new Object[0])); [EOL]         assertEquals("{}", ArrayUtils.toString(new String[0])); [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null})); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"})); [EOL]          [EOL]         assertEquals("<empty>", ArrayUtils.toString(null, "<empty>")); [EOL]         assertEquals("{}", ArrayUtils.toString(new Object[0], "<empty>")); [EOL]         assertEquals("{}", ArrayUtils.toString(new String[0], "<empty>")); [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]          [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testAddValueObject() { [EOL]         final MutableDouble mutNum = new MutableDouble(1); [EOL]         mutNum.add(Double.valueOf(1.1d)); [EOL]          [EOL]         assertEquals(2.1d, mutNum.doubleValue(), 0.01d); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDeserializeBytesOfNull() throws Exception { [EOL]         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); [EOL]         final ObjectOutputStream oos = new ObjectOutputStream(streamReal); [EOL]         oos.writeObject(null); [EOL]         oos.flush(); [EOL]         oos.close(); [EOL]  [EOL]         final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); [EOL]         assertNull(test); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.shutdown(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(0, new BitField(0).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(1, new BitField(1).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(2, new BitField(2).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(4, new BitField(4).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(8, new BitField(8).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(16, new BitField(16).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(32, new BitField(32).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(64, new BitField(64).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(-128, new BitField(128).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(1, new BitField(0).setByteBoolean((byte) 1, false)); [EOL]         assertEquals(0, new BitField(1).setByteBoolean((byte) 1, false)); [EOL]         assertEquals(0, new BitField(2).setByteBoolean((byte) 2, false)); [EOL]         assertEquals(0, new BitField(4).setByteBoolean((byte) 4, false)); [EOL]         assertEquals(0, new BitField(8).setByteBoolean((byte) 8, false)); [EOL]         assertEquals(0, new BitField(16).setByteBoolean((byte) 16, false)); [EOL]         assertEquals(0, new BitField(32).setByteBoolean((byte) 32, false)); [EOL]         assertEquals(0, new BitField(64).setByteBoolean((byte) 64, false)); [EOL]         assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false)); [EOL]         assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false)); [EOL]         final byte clearedBit = new Bit
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 1)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final String formattedDate = DateFormatUtils.format(d, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",  [EOL]                         DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",  [EOL]                         DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",  [EOL]                         DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", false, false, false); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",  [EOL]                       DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",  [EOL]                       DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",  [EOL]                       DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4")); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9")); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10.11")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:0:12.13")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:12.14")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.15")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.16")); [EOL]         assertEquals("0", DurationFormatUtils.formatDuration(time,
@Test [EOL]     public void testLexx() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.lexx("0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.lexx("0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.lexx("0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.lexx("0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.lexx("0:00:00.4")); [EOL]          [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.lexx("0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.lexx("0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.lexx("0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.lexx("0:00:00.8")); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.lexx("0:00:00.9")); [EOL]          [EOL]         assertEquals("0:00:00", DurationFormatUtils.lexx("0:00:00.10")); [EOL]         assertEquals("0:00:00", DurationFormatUtils.lexx("0:00:00.11")); [EOL]         assertEquals("0:00:12", DurationFormatUtils.lexx("0:12:13.4")); [EOL]         assertEquals("0:13:14", DurationFormatUtils.lexx("0:14:15.6")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10", false)); [EOL]         assertEquals("0:00:11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14", DurationFormatUtils.formatDuration(time, "0:14", false)); [EOL]         assertEquals("0:15", DurationFormatUtils.formatDuration(
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("one"), new Token("two"), new Token("three"), new Token("four") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("one"), new Token("two"), new Token("three") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("x"), new Token("y"), new Token("z") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]          [EOL]         assertEquals("2004-02-23T09:00:00.000Z", fdf.format(d)); [EOL]          [EOL]         assertEquals("2004-02-23T09:00:00.000Z", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(timeZone); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS Z", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(0, "00:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(0, "00:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(0, "00:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(0, "00:00:00.3", true)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(0, "00:00:00.4", false)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(0, "00:00:00.5", true)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(0, "00:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(0, "00:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(8, "00:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(8, "00:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(10, "00:00:00.5", false)); [EOL]         assertEquals("0:00:00.11", DurationFormatUtils.formatDuration(11, "00:00:12", false)); [EOL]         assertEquals("12:00:13", DurationFormatUtils.formatDuration(12, "00:13", false)); [EOL]         assertEquals("14:00:14.15", DurationFormatUtils.formatDuration(14, "00:15", false)); [EOL]         assertEquals("
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4")); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9")); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10.11")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:0:12.13")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:12.14")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.15")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.16")); [EOL]         assertEquals("0", DurationFormatUtils.formatDuration(time,
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("one"), new Token("two"), new Token("three"), new Token("four") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("one"), new Token("two"), new Token("three") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("x"), new Token("y"), new Token("z") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4")); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9")); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10.11")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:0:12.13")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:12.14")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.15")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.16")); [EOL]         assertEquals("0", DurationFormatUtils.formatDuration(time,
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(0, "00:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(0, "00:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(0, "00:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(0, "00:00:00.3", true)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(0, "00:00:00.4", false)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(0, "00:00:00.5", true)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(0, "00:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(0, "00:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(8, "00:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(8, "00:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(10, "00:00:00.5", false)); [EOL]         assertEquals("0:00:00.11", DurationFormatUtils.formatDuration(11, "00:00:12", false)); [EOL]         assertEquals("12:00:13", DurationFormatUtils.formatDuration(12, "00:13", false)); [EOL]         assertEquals("14:00:14.15", DurationFormatUtils.formatDuration(14, "00:15", false)); [EOL]         assertEquals("
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final String formattedDate = [EOL]             DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d); [EOL]             assertEquals("1970-01-01T12:00:00", formattedDate); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]             final long millis2 = System.currentTimeMillis(); [EOL]             final String formattedDate3 = [EOL]             DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]             assertEquals("1971-01-01T12:00:00", formattedDate3); [EOL]             assertEquals("1971-01-01T12:00:00", formattedDate4); [EOL]             assertEquals("1971-01-01T12:00:00", formattedDate5); [EOL]             assertEquals("1971-01-01T12:00:00", formattedDate6); [EOL]             assertEquals("1971-01-01T12:00:00", formattedDate7); [EOL]  [EOL]             formattedDate = [EOL]             DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d); [EOL]             assertEquals("1971-01-01T12:00:00", formattedDate7); [EOL]             assertEquals("1971-01-01T12:00:00", formattedDate8); [EOL]             assertEquals("1971-01-01T12:00:00", formattedDate9); [EOL]  [EOL]             formattedDate = [EOL]             DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); [EOL]             assertEquals("1971-01-01T12:00:00", formatted
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, TokenUtils.lexx(null)); [EOL]         assertEquals(0, TokenUtils.lexx("").length); [EOL]  [EOL]         assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, TokenUtils.lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(ArrayUtils.isEquals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, TokenUtils.lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, TokenUtils.lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, TokenUtils.lexx("number5"))); [EOL]          [EOL]         assertTrue(ArrayUtils.isEquals(new String[] { "foo", "B", "ar" }, TokenUtils.lexx("fooBar"))); [EOL]         assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "B", "ar" }, TokenUtils.lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, TokenUtils.lexx("ASFRules"))); [EOL]         assertTrue(ArrayUtils.isEquals(new String[] { "ASFRules" }, TokenUtils.lexx("ASFRules"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4")); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9")); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10.11")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:0:12.13")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:12.14")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.15")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.16")); [EOL]         assertEquals("0", DurationFormatUtils.formatDuration(time,
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[0], lexx("")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("a")}, lexx("a")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("b")}, lexx("b")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("c")}, lexx("c")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("d"), Token.valueOf("e")}, lexx("d e")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("1"), Token.valueOf("2")}, lexx("a b c")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("3")}, lexx("a b c")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("4"), Token.valueOf("5")}, lexx("a b c")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("6"), Token.valueOf("7")}, lexx("a b c")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("8"), Token.valueOf("9")}, lexx("a b c")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("10"), Token.valueOf("11")}, lexx("a b c")); [EOL]         assertArrayEquals(new Token[]{Token.valueOf("-14"), Token.valueOf("-15")}, lexx("-16")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(time, "0:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:00:10", false)); [EOL]         assertEquals("0:00:11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(timeZone); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4")); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9")); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10.11")); [EOL]         assertEquals("0:00:00.12", DurationFormatUtils.formatDuration(time, "0:0:12.13")); [EOL]         assertEquals("0:00:12.14", DurationFormatUtils.formatDuration(time, "0:0:14.15")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(time, "0:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:00:10", false)); [EOL]         assertEquals("0:00:11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.lexx("0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.lexx("0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.lexx("0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.lexx("0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.lexx("0:00:00.4")); [EOL]          [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.lexx("0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.lexx("0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.lexx("0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.lexx("0:00:00.8")); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.lexx("0:00:00.9")); [EOL]          [EOL]         assertEquals("0:00:00", DurationFormatUtils.lexx("0:00:00.10")); [EOL]         assertEquals("0:00:00", DurationFormatUtils.lexx("0:00:00.11")); [EOL]         assertEquals("0:00:12", DurationFormatUtils.lexx("0:12:13.4")); [EOL]         assertEquals("0:13:14", DurationFormatUtils.lexx("0:14:15.6")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat1() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final String formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2005-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2005-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2005-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmss
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat1() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, 11, 31); [EOL]  [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final String formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2005-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2005-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2005-11-31T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmss
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4")); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9")); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10.11")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:0:12.13")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:14:15.6")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:14:15.21")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:14:15.32")); [EOL]         assertEquals("0
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(time, "0:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:00:10", false)); [EOL]         assertEquals("0:00:11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         final String str = "a b c"; [EOL]         final Token[] tokens = lexx(str); [EOL]         assertEquals(3, tokens.length); [EOL]         assertEquals(Token.class, tokens[0].getClass()); [EOL]         assertEquals("a", tokens[0].getValue()); [EOL]         assertEquals("b", tokens[1].getClass()); [EOL]         assertEquals("c", tokens[2].getClass()); [EOL]  [EOL]         tokens = lexx(str); [EOL]         assertEquals(3, tokens.length); [EOL]         assertEquals(Token.class, tokens[0].getClass()); [EOL]         assertEquals("a", tokens[1].getClass()); [EOL]         assertEquals("b", tokens[2].getClass()); [EOL]  [EOL]         tokens = lexx(str); [EOL]         assertEquals(4, tokens.length); [EOL]         assertEquals(Token.class, tokens[0].getClass()); [EOL]         assertEquals("c", tokens[1].getClass()); [EOL]         assertEquals("a", tokens[2].getClass()); [EOL]  [EOL]         tokens = lexx(str + "b"); [EOL]         assertEquals(6, tokens.length); [EOL]         assertEquals(Token.class, tokens[0].getClass()); [EOL]         assertEquals("b", tokens[1].getClass()); [EOL]         assertEquals("c", tokens[2].getClass()); [EOL]  [EOL]         tokens = lexx(str); [EOL]         assertEquals(7, tokens.length); [EOL]         assertEquals(Token.class, tokens[0].getClass()); [EOL]         assertEquals("a", tokens[1].getClass()); [EOL]         assertEquals("b", tokens[2].getClass()); [EOL]         assertEquals("c", tokens[3].getClass()); [EOL]  [EOL]         tokens = lexx(
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10", false)); [EOL]         assertEquals("0:00:11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14", DurationFormatUtils.formatDuration(time, "0:14", true)); [EOL]         assertEquals("0:15", DurationFormatUtils.formatDuration(
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final String formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(m, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]          [EOL]         assertEquals("2004-02-23T09:00:00.000Z", fdf.format(d)); [EOL]          [EOL]         assertEquals("2004-02-23T09:00:00.000Z", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf.format(new Date(d.getTime()))); [EOL]          [EOL]         fdf = getInstance("-0500"); [EOL]         assertEquals("-0500", fdf
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", StringUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(time, "0:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:00:10", false)); [EOL]         assertEquals("0:00:11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10", false)); [EOL]         assertEquals("0:00:00.11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14", DurationFormatUtils.formatDuration(time, "0:14", false)); [EOL]         assertEquals("0:15", DurationFormatUtils.format
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.lexx("0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.lexx("0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.lexx("0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.lexx("0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.lexx("0:00:00.4")); [EOL]          [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.lexx("0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.lexx("0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.lexx("0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.lexx("0:00:00.8")); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.lexx("0:00:00.9")); [EOL]          [EOL]         assertEquals("0:00:00", DurationFormatUtils.lexx("0:00:00.10")); [EOL]         assertEquals("0:00:00", DurationFormatUtils.lexx("0:00:00.11")); [EOL]         assertEquals("0:12:12", DurationFormatUtils.lexx("0:12:12.13")); [EOL]         assertEquals("0:13:14", DurationFormatUtils.lexx("0:13:14.15")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(0, "00:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(0, "00:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(0, "00:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(0, "00:00:00.3", true)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(0, "00:00:00.4", false)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(0, "00:00:00.5", true)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(0, "00:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(0, "00:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(8, "00:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(8, "00:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(10, "00:00:00.5", false)); [EOL]         assertEquals("0:00:00.11", DurationFormatUtils.formatDuration(11, "00:00:12", false)); [EOL]         assertEquals("12:00:13", DurationFormatUtils.formatDuration(12, "00:13", false)); [EOL]         assertEquals("14:00:14.15", DurationFormatUtils.formatDuration(14, "00:15", false)); [EOL]         assertEquals("
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(time, "0:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:00:10", false)); [EOL]         assertEquals("0:00:11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testFormatDurationWords() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000", false)); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001", true)); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2", false)); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3", false)); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4", true)); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5", false)); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6", false)); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7", true)); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:00.8", false)); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatDuration(time, "0:00:00.9", false)); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:00:10", false)); [EOL]         assertEquals("0:00:11", DurationFormatUtils.formatDuration(time, "0:11", false)); [EOL]         assertEquals("0:12", DurationFormatUtils.formatDuration(time, "0:12", true)); [EOL]         assertEquals("0:13", DurationFormatUtils.formatDuration(time, "0:13", false)); [EOL]         assertEquals("0:14
@Test [EOL]     public void testFormatDurationWords_Long() { [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("0:00:00", DurationUtils.formatDurationWords(0L, false, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(0L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, true, false)); [EOL]          [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(1L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(2L, true, false)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, false, true)); [EOL]         assertEquals("00:00:00", DurationUtils.formatDurationWords(3L, true, false)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(timeZone); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, 0)); [EOL]         assertEquals(null, ObjectUtils.mode(null, 1)); [EOL]         assertEquals(null, ObjectUtils.mode(null, 2)); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("baz", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals(null, ObjectUtils.mode(null, null, "bar", "baz", "wah")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz", "wah", "wah")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.mode( (String) null ) ); [EOL]         assertNull(ObjectUtils.mode( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.mode( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, minComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( minComparable, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, minComparable, null, nonNullComparable1 ) ); [EOL]  [EOL]         assertNull( ObjectUtils.mode((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null, null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "any")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "any", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, null, "any")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "any", "other")); [EOL]         assertEquals("", ObjectUtils.mode("", "any", null)); [EOL]         assertEquals("", ObjectUtils.mode("", "any", "other")); [EOL]         assertEquals("", ObjectUtils.mode("", "any", "other")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null, null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo", -1)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo", 0)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo", 1)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo", 2)); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", null, -1)); [EOL]         assertEquals("foo", ObjectUtils.mode("foo", null, 2)); [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", 0)); [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", -1)); [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", 2)); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", -1)); [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", -2)); [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", 1)); [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", 2, -1)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         assertEquals(null, ObjectUtils.mode(null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "foo")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar")); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", null)); [EOL]         assertEquals(null, ObjectUtils.mode(null, "bar", "baz")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz")); [EOL]         assertEquals("bar", ObjectUtils.mode("foo", "bar", "baz", "blah")); [EOL]         assertEquals("blah", ObjectUtils.mode("foo", "bar", "baz", "blah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]          [EOL]         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah")); [EOL]         assertEquals("wah", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah")); [EOL]          [EOL]         assertEquals("f", ObjectUtils.mode("foo", "bar", "baz", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah", "wah
@Test [EOL]     public void testMode() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.mode( (String) null ) ); [EOL]         assertNull(ObjectUtils.mode( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.mode( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, minComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( minComparable, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, minComparable, null, nonNullComparable1 ) ); [EOL]  [EOL]         assertNull( ObjectUtils.mode((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMode() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.mode( (String) null ) ); [EOL]         assertNull(ObjectUtils.mode( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.mode( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, minComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( minComparable, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, minComparable, null, nonNullComparable1 ) ); [EOL]  [EOL]         assertNull( ObjectUtils.mode((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMode() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.mode( (String) null ) ); [EOL]         assertNull(ObjectUtils.mode( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.mode( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, minComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( minComparable, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, minComparable, null, nonNullComparable1 ) ); [EOL]  [EOL]         assertNull( ObjectUtils.mode((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMode() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.mode( (String) null ) ); [EOL]         assertNull(ObjectUtils.mode( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, nonNullComparable2 ) ); [EOL]         assertSame( nonNullComparable2, ObjectUtils.mode( nonNullComparable2, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( nonNullComparable1, minComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( minComparable, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.mode( null, minComparable, null, nonNullComparable1 ) ); [EOL]  [EOL]         assertNull( ObjectUtils.mode((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         sub.setSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testNoneLookup() { [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("none")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNoneLookup() { [EOL]         assertEquals(null, StrLookup.noneLookup().lookup(null)); [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("")); [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("any")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNoneLookup() { [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("none")); [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("any")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNoneLookup() { [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("none")); [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("any")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMapLookup() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("some key", "some value"); [EOL]         map.put("another key", "another value"); [EOL]         assertEquals("some value", StrLookup.mapLookup("some key").lookup("some")); [EOL]         assertEquals("another value", StrLookup.mapLookup("another key").lookup("another")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMapLookup_String() { [EOL]         assertEquals(null, StrLookup.mapLookup("").lookup("any")); [EOL]         assertEquals(null, StrLookup.mapLookup("any").lookup("any")); [EOL]         assertEquals(null, StrLookup.mapLookup("any").lookup("any")); [EOL]         try { [EOL]             StrLookup.mapLookup("any").lookup("any"); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             StrLookup.mapLookup("any").lookup("any"); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         assertEquals("any", StrLookup.mapLookup("any").lookup("any")); [EOL]         try { [EOL]             StrLookup.mapLookup("any").lookup("any"); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         assertEquals("any", StrLookup.mapLookup("any").lookup("any")); [EOL]         try { [EOL]             StrLookup.mapLookup("any").lookup("any"); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullMap() { [EOL]         assertEquals(null, StrLookup.noneLookup().lookup(null)); [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("")); [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("any")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNoneLookup() { [EOL]         assertEquals(null, StrLookup.noneLookup().lookup(null)); [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("")); [EOL]         assertEquals(null, StrLookup.noneLookup().lookup("any")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMapLookup() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("some key", "some value"); [EOL]         map.put("another key", "another value"); [EOL]         assertEquals("some value", StrLookup.mapLookup("some key").lookup("some")); [EOL]         assertEquals("another value", StrLookup.mapLookup("another key").lookup("another")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToString() { [EOL]         assertEquals("{}", StrLookup.toString(null)); [EOL]         assertEquals("{}", StrLookup.toString(new Object[0])); [EOL]         assertEquals("{}", StrLookup.toString(new String[0])); [EOL]         assertEquals("{<null>}", StrLookup.toString(new String[] {null})); [EOL]         assertEquals("{pink,blue}", StrLookup.toString(new String[] {"pink","blue"})); [EOL]          [EOL]         assertEquals("<empty>", StrLookup.toString(null, "<empty>")); [EOL]         assertEquals("{}", StrLookup.toString(new Object[0], "<empty>")); [EOL]         assertEquals("{<null>}", StrLookup.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", StrLookup.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]          [EOL]         assertEquals("{<null>}", StrLookup.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", StrLookup.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMapLookup_String() { [EOL]         assertEquals(null, StrLookup.mapLookup("").lookup("any")); [EOL]         assertEquals(null, StrLookup.mapLookup("any").lookup("any")); [EOL]         assertEquals(null, StrLookup.mapLookup("any").lookup("any")); [EOL]         try { [EOL]             StrLookup.mapLookup("any").lookup("any"); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             StrLookup.mapLookup("any").lookup("any"); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         assertEquals("any", StrLookup.mapLookup("any").lookup("any")); [EOL]         try { [EOL]             StrLookup.mapLookup("any").lookup("any"); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         assertEquals("any", StrLookup.mapLookup("any").lookup("any")); [EOL]         try { [EOL]             StrLookup.mapLookup("any").lookup("any"); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullCalendar() { [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMinutes((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullCalendar() { [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullCalendar() { [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]  [EOL]         try { [EOL]             DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND); [EOL]             fail(); [EOL]         } catch(final IllegalArgumentException iae) {} [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMinutesOfDayWithDate() { [EOL]         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); [EOL]         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;  [EOL]         assertEquals(expectedValue,testResult); [EOL]         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); [EOL]         assertEquals(expectedValue,testResult); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCloneNotSupportedException() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         try { [EOL]             tok.clone(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCloneReset() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         try { [EOL]             tkn.reset(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.reset(new char[0]); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.set("y"); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.set("a b c"); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         assertEquals("a", tkn.next()); [EOL]         assertEquals("b", tkn.next()); [EOL]         assertEquals("c", tkn.next()); [EOL]          [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertFalse(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.next(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.reset("d e"); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSplit_String_char_char() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCloneReset() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertFalse(tkn.hasPrevious()); [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.reset(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.add("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("a", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.next(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIteration() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertTrue(tkn.hasNext()); [EOL]         assertEquals("a", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]          [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.add("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals(" c", tok.next()); [EOL]          [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertEquals("d e", tok.next()); [EOL]          [EOL]         tok.reset("e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]          [EOL]         tok.reset("f"); [EOL]         assertEquals("f", tok.next()); [EOL]         assertEquals("g", tok.next()); [EOL]         assertEquals("h", tok.next()); [EOL]          [EOL]         tok.reset("i"); [EOL]         assertEquals("h", tok.next()); [EOL]         assertEquals("i", tok.next()); [EOL]          [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> tokens = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), tokens); [EOL]         assertEquals(3, tokens.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     private void testCSV(final String data) { [EOL]         this.testXSVAbc(StrTokenizer.getCSVInstance(data)); [EOL]         this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray())); [EOL]         this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIteration() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertFalse(tkn.hasPrevious()); [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]          [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("a", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]          [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]          [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset(""); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset(" "); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertEquals("d", tok.next()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(null, tok.next()); [EOL]         assertEquals("e", tok.next()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals("f", tok.next()); [EOL]         assertEquals("g", tok.next()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals("h", tok.next()); [EOL]         assertEquals("i", tok.next()); [EOL]         assertEquals("j", tok.next()); [EOL]          [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> tokens = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), tokens); [EOL]         assertEquals(3, tokens.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     private void testCSV(final String data) { [EOL]         this.testXSVAbc(StrTokenizer.getCSVInstance(data)); [EOL]         this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray())); [EOL]         this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> list = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), list); [EOL]         assertEquals(3, list.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIteration() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertFalse(tkn.hasPrevious()); [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]          [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("a", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]          [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]          [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCloneReset() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertFalse(tkn.hasPrevious()); [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.reset(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.add("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("a", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.next(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setTokenArray(new String[] { "a", "b", "c" }); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setTokenArray(new String[] { "a", "b", "c" }); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [
@Test [EOL]     public void testCloneReset() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertFalse(tkn.hasPrevious()); [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.reset(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.add("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("a", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.next(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         try { [EOL]             tok = new StrTokenizer(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok = new StrTokenizer(); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) {} [EOL]         try { [EOL]             tok = new StrTokenizer(); [EOL]             fail(); [EOL]         } catch (final IllegalStateException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIteration() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertTrue(tkn.hasNext()); [EOL]         assertEquals("a", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]          [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.add("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         try { [EOL]             tok = new StrTokenizer(); [EOL]             fail("Expected NoSuchElementException"); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok = new StrTokenizer(); [EOL]             fail("Expected NoSuchElementException"); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]             fail("Expected NoSuchElementException"); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]          [EOL]         try { [EOL]             tok = new StrTokenizer(); [EOL]             fail("Expected NoSuchElementException"); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]          [EOL]         try { [EOL]             tok = new StrTokenizer(); [EOL]             fail("Expected NoSuchElementException"); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals(" c", tok.next()); [EOL]          [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertEquals("d e", tok.next()); [EOL]          [EOL]         tok.reset("e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]          [EOL]         tok.reset("f"); [EOL]         assertEquals("f", tok.next()); [EOL]         assertEquals("g", tok.next()); [EOL]         assertEquals("h", tok.next()); [EOL]          [EOL]         tok.reset("i"); [EOL]         assertEquals("h", tok.next()); [EOL]         assertEquals("i", tok.next()); [EOL]          [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]          [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCloneReset() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         try { [EOL]             tkn.reset(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.reset(new char[0]); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         try { [EOL]             tkn.set("y"); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]          [EOL]         assertEquals("a", tkn.next()); [EOL]         assertEquals("b", tkn.next()); [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertFalse(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.next(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.set("d"); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals(" c", tok.next()); [EOL]          [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertEquals("d e", tok.next()); [EOL]          [EOL]         tok.reset("e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]          [EOL]         tok.reset("f"); [EOL]         assertEquals("f", tok.next()); [EOL]         assertEquals("g", tok.next()); [EOL]         assertEquals("h", tok.next()); [EOL]          [EOL]         tok.reset("i"); [EOL]         assertEquals("h", tok.next()); [EOL]         assertEquals("i", tok.next()); [EOL]          [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset(""); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset(" "); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset("e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset("f"); [EOL]         assertEquals("b", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset("g"); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset("h"); [EOL]         assertEquals("h", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset("i"); [EOL]         assertTrue(tok.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIteration() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertTrue(tkn.hasNext()); [EOL]         assertEquals("a", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]          [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.add("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCloneNotSupportedException() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         try { [EOL]             tok.clone(); [EOL]             fail(); [EOL]         } catch (final CloneNotSupportedException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCloneNotSupportedException() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         try { [EOL]             tok.clone(); [EOL]             fail("Expected NullPointerException"); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals(" c", tok.next()); [EOL]          [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertEquals("d e", tok.next()); [EOL]          [EOL]         tok.reset("e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]          [EOL]         tok.reset("f"); [EOL]         assertEquals("f", tok.next()); [EOL]         assertEquals("g", tok.next()); [EOL]         assertEquals("h", tok.next()); [EOL]          [EOL]         tok.reset("i"); [EOL]         assertEquals("h", tok.next()); [EOL]         assertEquals("i", tok.next()); [EOL]          [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setTokenArray(new String[] { "a", "b", "c" }); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setTokenArray(new String[] { "a", "b", "c" }); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok.next(); [EOL]             fail(); [
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSplit_String_char_char() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setTokenArray(new String[] { "a", "b", "c" }); [EOL]         tok.setStartIndex(2); [EOL]         tok.setEndIndex(4); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setTokenList(new String[] { "a", "b", "c" }); [EOL]         tok.setReset(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]          [EOL]         tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(' '); [EOL]         tok.setTokenArray(new String[] { "a", "b", "c" }); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setIgnoreEmptyTokens(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertEquals("d", tok.next()); [EOL]         assertEquals("e", tok.next()); [EOL]         assertEquals("f", tok.next()); [EOL]         assertEquals("g", tok.next()); [EOL]         assertEquals("h", tok.next()); [EOL]         assertEquals("i", tok.next()); [EOL]         assertEquals("j", tok.next()); [EOL]         assertEquals("k", tok.next()); [EOL]         assertEquals("m", tok.next()); [EOL]         assertEquals("n", tok.next()); [EOL]          [EOL]
@Test [EOL]     public void testReset_String() { [EOL]         StrTokenizer tok = new StrTokenizer("a b c"); [EOL]         tok.reset("d e"); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("b", tok.next()); [EOL]         assertEquals("c", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset(""); [EOL]         assertFalse(tok.hasNext()); [EOL]          [EOL]         tok.reset(" "); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Range<Integer> ri1 = Range.is(10); [EOL]         final Range<Integer> ri2 = Range.is(10); [EOL]         assertEquals(ri1, ri2); [EOL]         assertEquals(ri1.hashCode(), ri2.hashCode()); [EOL]         ri1.hashCode(); [EOL]         ri2.hashCode(); [EOL]         assertFalse(ri1.equals(ri2)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Range<Integer> ri1 = Range.is(10); [EOL]         final Range<Integer> ri2 = Range.is(10); [EOL]         assertEquals(ri1, ri2); [EOL]         assertEquals(ri1.hashCode(), ri2.hashCode()); [EOL]         ri1.hashCode(); [EOL]         ri2.hashCode(); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         final Range<Integer> ri = Range.is(10); [EOL]         assertEquals(ri.hashCode(), ri.hashCode()); [EOL]          [EOL]         ri = Range.is(5); [EOL]         assertEquals(ri.hashCode(), ri.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Range<Integer> ri1 = Range.is(10); [EOL]         final Range<Integer> ri2 = Range.is(10); [EOL]         assertEquals(ri1, ri2); [EOL]         assertEquals(ri1.hashCode(), ri2.hashCode()); [EOL]         ri1.hashCode(); [EOL]         ri2.hashCode(); [EOL]         assertFalse(ri1.equals(ri2)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Range<Integer> ri1 = Range.is(10); [EOL]         final Range<Integer> ri2 = Range.is(10); [EOL]         assertEquals(ri1, ri2); [EOL]         assertEquals(ri1.hashCode(), ri2.hashCode()); [EOL]         ri1.hashCode(); [EOL]         ri2.hashCode(); [EOL]         assertFalse(ri1.equals(ri2)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         final Range<Integer> ri = Range.is(10); [EOL]         assertEquals(ri.hashCode(), ri.hashCode()); [EOL]          [EOL]         ri = Range.is(5); [EOL]         assertEquals(ri.hashCode(), ri.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Range<Integer> ri1 = Range.is(10); [EOL]         final Range<Integer> ri2 = Range.is(10); [EOL]         assertEquals(ri1, ri2); [EOL]         assertEquals(ri1.hashCode(), ri2.hashCode()); [EOL]         ri1.hashCode(); [EOL]         ri2.hashCode(); [EOL]         assertFalse(ri1.equals(ri2)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHashCode() { [EOL]         final Range<Integer> ri = Range.is(10); [EOL]         assertEquals(ri.hashCode(), ri.hashCode()); [EOL]          [EOL]         ri = Range.is(5); [EOL]         assertEquals(ri.hashCode(), ri.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         int[] obj1 = new int[2]; [EOL]         obj1[0] = 5; [EOL]         obj1[1] = 6; [EOL]         int[] obj2 = new int[2]; [EOL]         obj2[0] = 5; [EOL]         obj2[1] = 6; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1[1] = 7; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]  [EOL]         obj2 = null; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         obj1 = null; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testIntArray() { [EOL]         int[] array = new int[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testOneArgNull() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null)); [EOL]         assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testOneArgNull() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null)); [EOL]         assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testOneArgNull() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null)); [EOL]         assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         long[] array = new long[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testPerson() { [EOL]         final Person p = new Person(); [EOL]         p.name = "John Doe"; [EOL]         p.age = 33; [EOL]         p.smoker = false; [EOL]         final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p)); [EOL]         assertEquals(pBaseStr + "[name=John Doe,age=33,smoker=false]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testIntArray() { [EOL]         int[] array = new int[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testDoubleArray() { [EOL]         double[] array = new double[] {1.0, 2.9876, -3.00001, 4.3}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testPerson() { [EOL]         final Person p = new Person(); [EOL]         p.name = "John Doe"; [EOL]         p.age = 33; [EOL]         p.smoker = false; [EOL]         final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p)); [EOL]         assertEquals(pBaseStr + "[name=John Doe,age=33,smoker=false]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testIntArray() { [EOL]         int[] array = new int[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testIntArray() { [EOL]         int[] array = new int[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testIntArray() { [EOL]         int[] array = new int[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testIntArray() { [EOL]         int[] array = new int[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testOneArgNull() { [EOL]         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null)); [EOL]         assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different Class [EOL]         other = new OtherExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("class, equals()",   emf.equals(other)); [EOL]         assertTrue("class, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]         final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]  [EOL]         final String pattern = "Pattern: {0,testfmt}"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]  [EOL]         ExtendedMessageFormat other = null; [EOL]  [EOL]         // Same object [EOL]         assertTrue("same, equals()",   emf.equals(emf)); [EOL]         assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]  [EOL]         // Equal Object [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]         assertTrue("equal, equals()",   emf.equals(other)); [EOL]         assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]         assertFalse("pattern, equals()",   emf.equals(other)); [EOL]         assertTrue("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]  [EOL]         // Different pattern [EOL]         other = new ExtendedMessageFormat("X" + pattern, Locale.US, otherRegitry); [EOL]         assertFalse("registry, equals()",   emf.equals(other)); [EOL]         assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]  [EOL]         // Different registry [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testEscapedQuote_LANG_477() { [EOL]         final String pattern = "it''s a {0,lower} 'test'!"; [EOL]         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test extended and built in formats. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, [EOL]             Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, [EOL]             Conversion.hexToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 4)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 4)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789A7856785678L, Conversion.hexToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToLong(String, int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 4)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToInt() { [EOL]         assertEquals(0, Conversion.hexDigitToInt('0')); [EOL]         assertEquals(1, Conversion.hexDigitToInt('1')); [EOL]         assertEquals(2, Conversion.hexDigitToInt('2')); [EOL]         assertEquals(3, Conversion.hexDigitToInt('3')); [EOL]         assertEquals(4, Conversion.hexDigitToInt('4')); [EOL]         assertEquals(5, Conversion.hexDigitToInt('5')); [EOL]         assertEquals(6, Conversion.hexDigitToInt('6')); [EOL]         assertEquals(7, Conversion.hexDigitToInt('7')); [EOL]         assertEquals(8, Conversion.hexDigitToInt('8')); [EOL]         assertEquals(9, Conversion.hexDigitToInt('9')); [EOL]         assertEquals(10, Conversion.hexDigitToInt('A')); [EOL]         assertEquals(11, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(12, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(13, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(14, Conversion.hexDigitToInt('E')); [EOL]         assertEquals(15, Conversion.hexDigitToInt('F')); [EOL]         assertEquals(16, Conversion.hexDigitToInt('a')); [EOL]         assertEquals(32, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(6, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(7, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(8, Conversion.hexDigitToInt('E')); [EOL]         assertEquals(9, Conversion.hexDigitToInt('F')); [EOL]         assertEquals(10, Conversion.hexDigitToInt('a')); [EOL]         assertEquals(11, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(12, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(13, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(14, Conversion.hexDigitToInt('E
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, [EOL]             Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, [EOL]             Conversion.hexToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, [EOL]             Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, [EOL]             Conversion.hexToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, [EOL]             Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, [EOL]             Conversion.hexToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexDigitToInt() { [EOL]         assertEquals(0, Conversion.hexDigitToInt('0')); [EOL]         assertEquals(1, Conversion.hexDigitToInt('1')); [EOL]         assertEquals(2, Conversion.hexDigitToInt('2')); [EOL]         assertEquals(3, Conversion.hexDigitToInt('3')); [EOL]         assertEquals(4, Conversion.hexDigitToInt('4')); [EOL]         assertEquals(5, Conversion.hexDigitToInt('5')); [EOL]         assertEquals(6, Conversion.hexDigitToInt('6')); [EOL]         assertEquals(7, Conversion.hexDigitToInt('7')); [EOL]         assertEquals(8, Conversion.hexDigitToInt('8')); [EOL]         assertEquals(9, Conversion.hexDigitToInt('9')); [EOL]         assertEquals(10, Conversion.hexDigitToInt('A')); [EOL]         assertEquals(11, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(12, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(13, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(14, Conversion.hexDigitToInt('E')); [EOL]         assertEquals(15, Conversion.hexDigitToInt('F')); [EOL]         assertEquals(16, Conversion.hexDigitToInt('a')); [EOL]         assertEquals(32, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(6, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(7, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(8, Conversion.hexDigitToInt('E')); [EOL]         assertEquals(9, Conversion.hexDigitToInt('F')); [EOL]         assertEquals(10, Conversion.hexDigitToInt('a')); [EOL]         assertEquals(11, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(12, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(13, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(14, Conversion.hexDigitToInt('E
@Test [EOL]     public void testHexDigitToInt() { [EOL]         assertEquals(0, Conversion.hexDigitToInt('0')); [EOL]         assertEquals(1, Conversion.hexDigitToInt('1')); [EOL]         assertEquals(2, Conversion.hexDigitToInt('2')); [EOL]         assertEquals(3, Conversion.hexDigitToInt('3')); [EOL]         assertEquals(4, Conversion.hexDigitToInt('4')); [EOL]         assertEquals(5, Conversion.hexDigitToInt('5')); [EOL]         assertEquals(6, Conversion.hexDigitToInt('6')); [EOL]         assertEquals(7, Conversion.hexDigitToInt('7')); [EOL]         assertEquals(8, Conversion.hexDigitToInt('8')); [EOL]         assertEquals(9, Conversion.hexDigitToInt('9')); [EOL]         assertEquals(10, Conversion.hexDigitToInt('A')); [EOL]         assertEquals(11, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(12, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(13, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(14, Conversion.hexDigitToInt('E')); [EOL]         assertEquals(15, Conversion.hexDigitToInt('F')); [EOL]         assertEquals(16, Conversion.hexDigitToInt('a')); [EOL]         assertEquals(32, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(6, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(7, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(8, Conversion.hexDigitToInt('E')); [EOL]         assertEquals(9, Conversion.hexDigitToInt('F')); [EOL]         assertEquals(10, Conversion.hexDigitToInt('a')); [EOL]         assertEquals(11, Conversion.hexDigitToInt('B')); [EOL]         assertEquals(12, Conversion.hexDigitToInt('C')); [EOL]         assertEquals(13, Conversion.hexDigitToInt('D')); [EOL]         assertEquals(14, Conversion.hexDigitToInt('E
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, [EOL]             Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, [EOL]             Conversion.hexToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, [EOL]             Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, [EOL]             Conversion.hexToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToLong(String, int, long, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 1)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 2)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, [EOL]             Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, [EOL]             Conversion.hexToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToLong() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); [EOL]         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 100, 0)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0L, 0, 4)); [EOL]         assertEquals(0x00000000CDF1F0C10F12345678L, Conversion.hexToLong(src, 1, 0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); [EOL]         assertEquals( [EOL]             0x12345678CDF1F0C10F12345678L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 1)); [EOL]         assertEquals( [EOL]             0x123456789ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456789ABCDEF0L, 0, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 2)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 2)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testHexToInt() { [EOL]         final String src = "CDF1F0C10F12345678"; [EOL]         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); [EOL]         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); [EOL]         assertEquals(0x1C0F1, Conversion.hexToInt(src, 0, 0, 0, 4)); [EOL]         assertEquals(0x1FDC, Conversion.hexToInt(src, 1, 0, 0, 4)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0xCDF15678, Conversion.hexToInt(src, 0, 0x12345678, 0, 0)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 0, 0x12345678, 24, 1)); [EOL]         assertEquals(0x12345678, Conversion.hexToInt(src, 15, 0x12345678, 16, 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. [EOL]      */ [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfDoubles() { [EOL]         assertEquals(null, StringUtils.join((double[]) null, ',')); [EOL]         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToBinary() { [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('1')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('2')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('3')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('4')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('5')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('7')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('8')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('A')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('a')); [EOL]         assertBinaryEquals( [EOL]             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('B')
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('a', Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals('e', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('f', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x10, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x11, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0x12, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0x13, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals('c')); [EOL]         assertEquals(0x14, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0x15,
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('b', Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals('e', Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals('f', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('a'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('b', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x10, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x11, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0x12, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0x13, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals('c')); [EOL]         assertEquals(0x14, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0x15, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x13, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x14,
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('a', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x10, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x11, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0x12, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0x13, Conversion.hexDigitMsb0ToInt('d')); [EOL]         assertEquals(0x14, Conversion.hexDigitMsb0ToInt('e')); [EOL]         assertEquals(0x15, Conversion.hexDigitMsb0ToInt('F')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('a')); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final boolean[] src) { [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         for (final boolean e : src) { [
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('a', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals(0x10, Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals(0x11, Conversion.hexDigitMsb0ToInt('a')); [EOL]         assertEquals(0x12, Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals(0x13, Conversion.hexDigitMsb0ToInt('b')); [EOL]         assertEquals('c')); [EOL]         assertEquals(0x14, Conversion.hexDigitMsb0ToInt('c')); [EOL]         assertEquals(0x15,
@Test [EOL]     public void testHexDigitMsb0ToInt() { [EOL]         assertEquals('0', Conversion.hexDigitMsb0ToInt('0')); [EOL]         assertEquals('1', Conversion.hexDigitMsb0ToInt('1')); [EOL]         assertEquals('2', Conversion.hexDigitMsb0ToInt('2')); [EOL]         assertEquals('3', Conversion.hexDigitMsb0ToInt('3')); [EOL]         assertEquals('4', Conversion.hexDigitMsb0ToInt('4')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('6')); [EOL]         assertEquals('7', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('8')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('5', Conversion.hexDigitMsb0ToInt('5')); [EOL]         assertEquals('6', Conversion.hexDigitMsb0ToInt('7')); [EOL]         assertEquals('8', Conversion.hexDigitMsb0ToInt('9')); [EOL]         assertEquals('9', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('A')); [EOL]         assertEquals('B', Conversion.hexDigitMsb0ToInt('B')); [EOL]         assertEquals('c', Conversion.hexDigitMsb0ToInt('C')); [EOL]         assertEquals('d', Conversion.hexDigitMsb0ToInt('E')); [EOL]         assertEquals('F', Conversion.hexDigitMsb0ToInt('f')); [EOL]         try { [EOL]             Conversion.hexDigitMsb0ToInt('A'); [EOL]             fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // OK [EOL]         } [EOL]     } [EOL]  [EOL]     static String dbgPrint(final
@Test [EOL]     public void testGetCharsInt_charArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         char[] a = new char[10]; [EOL]         sb.getChars(0, 0, a, 0); [EOL]         assertEquals(0, a.length); [EOL]          [EOL]         sb.append("junit"); [EOL]         a = sb.getChars(0, 1, a, 0); [EOL]         assertEquals(3, a.length); [EOL]         assertEquals("junit", new String(a, 0, 3)); [EOL]          [EOL]         a = sb.getChars(0, 4, a, 0); [EOL]         assertEquals(4, a.length); [EOL]         assertEquals("junit", new String(a, 0, 3)); [EOL]          [EOL]         a = sb.getChars(0, 1, a, 0); [EOL]         assertEquals(1, a.length); [EOL]         assertEquals("junit", new String(a, 0, 3)); [EOL]          [EOL]         try { [EOL]             sb.getChars(-1, 5, a, -1); [EOL]             fail("no string index out of bound on -1"); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]         try { [EOL]             sb.getChars(6, a, a, -1); [EOL]             fail("no string index out of bound on -1"); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]          [EOL]         try { [EOL]             sb.getChars(3, 5, a, 0); [EOL]             fail("no string index out of bound on -1"); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]          [EOL]         try { [EOL]             sb.getChars(-1, 5, a, 0); [EOL]             fail("no string index out of bound on -1"); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]          [EOL]         try { [EOL]             sb.getChars(6, a, -1); [EOL]             fail
@Test [EOL]     public void testGetCharsInt_charArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         char[] a = new char[10]; [EOL]         sb.getChars(0, 0, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, 1, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, -1, a, 0); [EOL]         try { [EOL]             sb.getChars(0, -1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(0, 1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, 1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(-1, 1, a, 0); [EOL]             fail("getChars(int, int, char[], 0) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars
@Test [EOL]     public void testGetCharsInt_charArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         char[] a = new char[10]; [EOL]         sb.getChars(0, 0, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, 1, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, -1, a, 0); [EOL]         try { [EOL]             sb.getChars(0, -1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(0, 1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, 1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(-1, 1, a, 0); [EOL]             fail("getChars(int, int, char[], 0) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars
@Test [EOL]     public void testGetCharsInt_charArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         char[] a = new char[10]; [EOL]         sb.getChars(0, 0, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, 1, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, -1, a, 0); [EOL]         try { [EOL]             sb.getChars(0, -1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(0, 1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(-1, 1, a, 0); [EOL]             fail("getChars(int, int, char[], 0) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.get
@Test [EOL]     public void testGetCharsInt_charArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         char[] a = new char[10]; [EOL]         sb.getChars(0, 0, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, 1, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, -1, a, 0); [EOL]         try { [EOL]             sb.getChars(0, -1, a, 0); [EOL]             fail("getChars(int, int, char[], int) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(0, 1, a, -1); [EOL]             fail("getChars(int, int, char[], int) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, 0); [EOL]             fail("getChars(int, int, char[], int) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(-1, 1, a, -1); [EOL]             fail("getChars(int, int, char[], int) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, 0); [EOL]             fail("getChars(int, int, char[], int) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(-1,
@Test [EOL]     public void testGetCharsInt_charArray() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         char[] a = new char[10]; [EOL]         sb.getChars(0, 0, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, 1, a, 0); [EOL]         assertEquals(0, a.length); [EOL]         sb.getChars(0, -1, a, 0); [EOL]         try { [EOL]             sb.getChars(0, -1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(0, 1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, 0); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(-1, 1, a, 0); [EOL]             fail("getChars(int, int, char[], 0) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.getChars(1, -1, a, -1); [EOL]             fail("getChars(int, int, char[], -1) expected IndexOutOfBoundsException"); [EOL]         } catch (final IndexOutOfBoundsException e) { [EOL]             // expected [EOL]         } [EOL]          [EOL]         try { [EOL]             sb.get
@Test [EOL]     public void testNullToEmptyFloatObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Float[]) null)); [EOL]         // Test valid array handling [EOL]         final Float[] original = new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                 Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Float[] empty = new Float[]{}; [EOL]         final Float[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyFloatObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Float[]) null)); [EOL]         // Test valid array handling [EOL]         final Float[] original = new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                 Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Float[] empty = new Float[]{}; [EOL]         final Float[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testNullToEmptyFloatObject() { [EOL]         // Test null handling [EOL]         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Float[]) null)); [EOL]         // Test valid array handling [EOL]         final Float[] original = new Float[] {Float.valueOf(Float.MIN_VALUE),  [EOL]                 Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)}; [EOL]         assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); [EOL]         // Test empty array handling [EOL]         final Float[] empty = new Float[]{}; [EOL]         final Float[] result = ArrayUtils.nullToEmpty(empty); [EOL]         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, result); [EOL]         assertTrue(empty != result); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], new double[0]); [EOL]             fail("IllegalArgumentException expected for empty
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch (final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch (final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch (final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch (final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch (final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch (final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch (final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch (final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0], (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0], (double[]) null); [EOL]             fail("IllegalArgumentException expected
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (float[]) null, (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null, (double[]) null); [EOL]
@Test [EOL]     public void testEnforceExceptions() { [EOL]         try { [EOL]             IEEE754rUtils.min( (float[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min(new float[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.min( (double[]) null); [EOL]             fail("IllegalArgumentException expected for null input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double[0]); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max( (double[]) null); [EOL]             fail("IllegalArgumentException expected for empty input"); [EOL]         } catch(final IllegalArgumentException iae) { /* expected */ } [EOL]  [EOL]         try { [EOL]             IEEE754rUtils.max(new double
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(4d)); [EOL]         assertEquals(4d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(5d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(4d)); [EOL]         assertEquals(4d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(5d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.0001d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testPrimitiveValues() { [EOL]         final MutableDouble mutNum = new MutableDouble(1.7); [EOL]          [EOL]         assertEquals( 1.7F, mutNum.floatValue(), 0 ); [EOL]         assertEquals( 1.7, mutNum.doubleValue(), 0 ); [EOL]         assertEquals( (byte) 1, mutNum.byteValue() ); [EOL]         assertEquals( (short) 1, mutNum.shortValue() ); [EOL]         assertEquals( 1, mutNum.intValue() ); [EOL]         assertEquals( 1L, mutNum.longValue() ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final MutableDouble mutNum = new MutableDouble(0d); [EOL]         assertEquals(0d, new MutableDouble().doubleValue(), 0.01d); [EOL]         assertEquals(Double.valueOf(0), new MutableDouble().getValue()); [EOL]          [EOL]         mutNum.setValue(1); [EOL]         assertEquals(1d, mutNum.doubleValue(), 0.01d); [EOL]         assertEquals(Double.valueOf(1d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(Double.valueOf(2d)); [EOL]         assertEquals(2d, mutNum.doubleValue(), 0.01d); [EOL]         assertEquals(Double.valueOf(2d), mutNum.getValue()); [EOL]          [EOL]         mutNum.setValue(new MutableDouble(3d)); [EOL]         assertEquals(3d, mutNum.doubleValue(), 0.01d); [EOL]         assertEquals(Double.valueOf(3d), mutNum.getValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testPrimitiveValues() { [EOL]         final MutableDouble mutNum = new MutableDouble(1.7); [EOL]          [EOL]         assertEquals( 1.7F, mutNum.floatValue(), 0 ); [EOL]         assertEquals( 1.7, mutNum.doubleValue(), 0 ); [EOL]         assertEquals( (byte) 1, mutNum.byteValue() ); [EOL]         assertEquals( (short) 1, mutNum.shortValue() ); [EOL]         assertEquals( 1, mutNum.intValue() ); [EOL]         assertEquals( 1L, mutNum.longValue() ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCapitalize_String() { [EOL]         assertEquals(null, StringUtils.capitalize(null)); [EOL]         assertEquals("", StringUtils.capitalize("")); [EOL]         assertEquals("  ", StringUtils.capitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.capitalize("I") ); [EOL]         assertEquals("I", WordUtils.capitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.capitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.capitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.capitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.capitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.capitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testLowerCase_Locale() { [EOL]         assertEquals(null, StringUtils.lowerCase(null, null)); [EOL]         assertEquals("", StringUtils.lowerCase("", Locale.getDefault())); [EOL]         assertEquals("  ", StringUtils.lowerCase("  ", Locale.getDefault())); [EOL]          [EOL]         assertEquals("i", WordUtils.lowerCase("I", Locale.getDefault())); [EOL]         assertEquals("I", WordUtils.lowerCase("i", Locale.getDefault())); [EOL]         assertEquals("I AM HERE 123", StringUtils.lowerCase("i am here 123", Locale.getDefault())); [EOL]         assertEquals("i aM hERE 123", StringUtils.lowerCase("I Am Here 123", Locale.getDefault())); [EOL]         assertEquals("I AM here 123", StringUtils.lowerCase("i am HERE 123", Locale.getDefault())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUncapitalize_String() { [EOL]         assertEquals(null, StringUtils.uncapitalize(null)); [EOL]         assertEquals("", StringUtils.uncapitalize("")); [EOL]         assertEquals("  ", StringUtils.uncapitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.uncapitalize("I") ); [EOL]         assertEquals("I", WordUtils.uncapitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.uncapitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.uncapitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.uncapitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.uncapitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a Title"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C8"; [EOL]         assertEquals(expect, WordUtils.uncapitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUncapitalize_String() { [EOL]         assertEquals(null, StringUtils.uncapitalize(null)); [EOL]         assertEquals("", StringUtils.uncapitalize("")); [EOL]         assertEquals("  ", StringUtils.uncapitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.uncapitalize("I") ); [EOL]         assertEquals("I", WordUtils.uncapitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.uncapitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.uncapitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.uncapitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.uncapitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a Title"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C8"; [EOL]         assertEquals(expect, WordUtils.uncapitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testCapitalize_String() { [EOL]         assertEquals(null, StringUtils.capitalize(null)); [EOL]         assertEquals("", StringUtils.capitalize("")); [EOL]         assertEquals("  ", StringUtils.capitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.capitalize("I") ); [EOL]         assertEquals("I", WordUtils.capitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.capitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.capitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.capitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.capitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.capitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUncapitalize_String() { [EOL]         assertEquals(null, StringUtils.uncapitalize(null)); [EOL]         assertEquals("", StringUtils.uncapitalize("")); [EOL]         assertEquals("  ", StringUtils.uncapitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.uncapitalize("I") ); [EOL]         assertEquals("I", WordUtils.uncapitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.uncapitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.uncapitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.uncapitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.uncapitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a Title"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C8"; [EOL]         assertEquals(expect, WordUtils.uncapitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testLowerCase_Locale() { [EOL]         assertEquals(null, StringUtils.lowerCase(null, null)); [EOL]         assertEquals("", StringUtils.lowerCase("", Locale.getDefault())); [EOL]         assertEquals("  ", StringUtils.lowerCase("  ", Locale.getDefault())); [EOL]          [EOL]         assertEquals("i", WordUtils.lowerCase("I", Locale.getDefault())); [EOL]         assertEquals("I", WordUtils.lowerCase("i", Locale.getDefault())); [EOL]         assertEquals("I AM HERE 123", StringUtils.lowerCase("i am here 123", Locale.getDefault())); [EOL]         assertEquals("i aM hERE 123", StringUtils.lowerCase("I Am Here 123", Locale.getDefault())); [EOL]         assertEquals("I AM here 123", StringUtils.lowerCase("i am HERE 123", Locale.getDefault())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLowerCase() { [EOL]         assertEquals(null, StringUtils.lowerCase(null)); [EOL]         assertEquals("", StringUtils.lowerCase("")); [EOL]         assertEquals("  ", StringUtils.lowerCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.lowerCase("I") ); [EOL]         assertEquals("I", WordUtils.lowerCase("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.lowerCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.lowerCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.lowerCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.lowerCase("I AM HERE 123") ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUpperCase() { [EOL]         assertEquals(null, StringUtils.upperCase(null)); [EOL]         assertEquals("", StringUtils.upperCase("")); [EOL]         assertEquals("  ", StringUtils.upperCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.upperCase("I") ); [EOL]         assertEquals("I", WordUtils.upperCase("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.upperCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.upperCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.upperCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.upperCase("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUpperCase() { [EOL]         assertEquals(null, StringUtils.upperCase(null)); [EOL]         assertEquals("", StringUtils.upperCase("")); [EOL]         assertEquals("  ", StringUtils.upperCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.upperCase("I") ); [EOL]         assertEquals("I", WordUtils.upperCase("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.upperCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.upperCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.upperCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.upperCase("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUncapitalize_String() { [EOL]         assertEquals(null, StringUtils.uncapitalize(null)); [EOL]         assertEquals("", StringUtils.uncapitalize("")); [EOL]         assertEquals("  ", StringUtils.uncapitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.uncapitalize("I") ); [EOL]         assertEquals("I", WordUtils.uncapitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.uncapitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.uncapitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.uncapitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.uncapitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a Title"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C8"; [EOL]         assertEquals(expect, WordUtils.uncapitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUpperCase() { [EOL]         assertEquals(null, StringUtils.upperCase(null, null)); [EOL]         assertEquals("", StringUtils.upperCase("", Locale.getDefault())); [EOL]         assertEquals("  ", StringUtils.upperCase("  ", Locale.getDefault())); [EOL]          [EOL]         assertEquals("i", WordUtils.upperCase("I", Locale.getDefault())); [EOL]         assertEquals("I", WordUtils.upperCase("i", Locale.getDefault())); [EOL]         assertEquals("I AM HERE 123", StringUtils.upperCase("i am here 123", Locale.getDefault())); [EOL]         assertEquals("i aM hERE 123", StringUtils.upperCase("I Am Here 123", Locale.getDefault())); [EOL]         assertEquals("I AM here 123", StringUtils.upperCase("i am HERE 123", Locale.getDefault())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUncapitalize_String() { [EOL]         assertEquals(null, StringUtils.uncapitalize(null)); [EOL]         assertEquals("", StringUtils.uncapitalize("")); [EOL]         assertEquals("  ", StringUtils.uncapitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.uncapitalize("I") ); [EOL]         assertEquals("I", WordUtils.uncapitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.uncapitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.uncapitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.uncapitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.uncapitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a Title"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C8"; [EOL]         assertEquals(expect, WordUtils.uncapitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testLowerCase() { [EOL]         assertEquals(null, StringUtils.lowerCase(null)); [EOL]         assertEquals("", StringUtils.lowerCase("")); [EOL]         assertEquals("  ", StringUtils.lowerCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.lowerCase("I") ); [EOL]         assertEquals("I", WordUtils.lowerCase("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.lowerCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.lowerCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.lowerCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.lowerCase("I AM HERE 123") ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLowerCase_Locale() { [EOL]         assertEquals(null, StringUtils.lowerCase(null, null)); [EOL]         assertEquals("", StringUtils.lowerCase("", Locale.getDefault())); [EOL]         assertEquals("  ", StringUtils.lowerCase("  ", Locale.getDefault())); [EOL]          [EOL]         assertEquals("i", WordUtils.lowerCase("I", Locale.getDefault())); [EOL]         assertEquals("I", WordUtils.lowerCase("i", Locale.getDefault())); [EOL]         assertEquals("I AM HERE 123", StringUtils.lowerCase("i am here 123", Locale.getDefault())); [EOL]         assertEquals("i aM hERE 123", StringUtils.lowerCase("I Am Here 123", Locale.getDefault())); [EOL]         assertEquals("I AM here 123", StringUtils.lowerCase("i am HERE 123", Locale.getDefault())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUpperCase() { [EOL]         assertEquals(null, StringUtils.upperCase(null, null)); [EOL]         assertEquals("", StringUtils.upperCase("", Locale.getDefault())); [EOL]         assertEquals("  ", StringUtils.upperCase("  ", Locale.getDefault())); [EOL]          [EOL]         assertEquals("i", WordUtils.upperCase("I", Locale.getDefault())); [EOL]         assertEquals("I", WordUtils.upperCase("i", Locale.getDefault())); [EOL]         assertEquals("I AM HERE 123", StringUtils.upperCase("i am here 123", Locale.getDefault())); [EOL]         assertEquals("i aM hERE 123", StringUtils.upperCase("I Am Here 123", Locale.getDefault())); [EOL]         assertEquals("I AM here 123", StringUtils.upperCase("i am HERE 123", Locale.getDefault())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUncapitalize_String() { [EOL]         assertEquals(null, StringUtils.uncapitalize(null)); [EOL]         assertEquals("", StringUtils.uncapitalize("")); [EOL]         assertEquals("  ", StringUtils.uncapitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.uncapitalize("I") ); [EOL]         assertEquals("I", WordUtils.uncapitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.uncapitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.uncapitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.uncapitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.uncapitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a Title"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C8"; [EOL]         assertEquals(expect, WordUtils.uncapitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testCapitalize_String() { [EOL]         assertEquals(null, StringUtils.capitalize(null)); [EOL]         assertEquals("", StringUtils.capitalize("")); [EOL]         assertEquals("  ", StringUtils.capitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.capitalize("I") ); [EOL]         assertEquals("I", WordUtils.capitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.capitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.capitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.capitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.capitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.capitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testCapitalize_String() { [EOL]         assertEquals(null, StringUtils.capitalize(null)); [EOL]         assertEquals("", StringUtils.capitalize("")); [EOL]         assertEquals("  ", StringUtils.capitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.capitalize("I") ); [EOL]         assertEquals("I", WordUtils.capitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.capitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.capitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.capitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.capitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.capitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testLowerCase() { [EOL]         assertEquals(null, StringUtils.lowerCase(null)); [EOL]         assertEquals("", StringUtils.lowerCase("")); [EOL]         assertEquals("  ", StringUtils.lowerCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.lowerCase("I") ); [EOL]         assertEquals("I", WordUtils.lowerCase("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.lowerCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.lowerCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.lowerCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.lowerCase("I AM HERE 123") ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCapitalize_String() { [EOL]         assertEquals(null, StringUtils.capitalize(null)); [EOL]         assertEquals("", StringUtils.capitalize("")); [EOL]         assertEquals("  ", StringUtils.capitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.capitalize("I") ); [EOL]         assertEquals("I", WordUtils.capitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.capitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.capitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.capitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.capitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.capitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUpperCase() { [EOL]         assertEquals(null, StringUtils.upperCase(null, null)); [EOL]         assertEquals("", StringUtils.upperCase("", Locale.getDefault())); [EOL]         assertEquals("  ", StringUtils.upperCase("  ", Locale.getDefault())); [EOL]          [EOL]         assertEquals("i", WordUtils.upperCase("I", Locale.getDefault())); [EOL]         assertEquals("I", WordUtils.upperCase("i", Locale.getDefault())); [EOL]         assertEquals("I AM HERE 123", StringUtils.upperCase("i am here 123", Locale.getDefault())); [EOL]         assertEquals("i aM hERE 123", StringUtils.upperCase("I Am Here 123", Locale.getDefault())); [EOL]         assertEquals("I AM here 123", StringUtils.upperCase("i am HERE 123", Locale.getDefault())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUncapitalize_String() { [EOL]         assertEquals(null, StringUtils.uncapitalize(null)); [EOL]         assertEquals("", StringUtils.uncapitalize("")); [EOL]         assertEquals("  ", StringUtils.uncapitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.uncapitalize("I") ); [EOL]         assertEquals("I", WordUtils.uncapitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.uncapitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.uncapitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.uncapitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.uncapitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a Title"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C8"; [EOL]         assertEquals(expect, WordUtils.uncapitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testCapitalize_String() { [EOL]         assertEquals(null, StringUtils.capitalize(null)); [EOL]         assertEquals("", StringUtils.capitalize("")); [EOL]         assertEquals("  ", StringUtils.capitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.capitalize("I") ); [EOL]         assertEquals("I", WordUtils.capitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.capitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.capitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.capitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.capitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a TitleCase character: \u01C8"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; [EOL]         assertEquals(expect, WordUtils.capitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUncapitalize_String() { [EOL]         assertEquals(null, StringUtils.uncapitalize(null)); [EOL]         assertEquals("", StringUtils.uncapitalize("")); [EOL]         assertEquals("  ", StringUtils.uncapitalize("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.uncapitalize("I") ); [EOL]         assertEquals("I", WordUtils.uncapitalize("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.uncapitalize("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.uncapitalize("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.uncapitalize("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.uncapitalize("I AM HERE 123") ); [EOL]  [EOL]         final String test = "This String contains a Title"; [EOL]         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C8"; [EOL]         assertEquals(expect, WordUtils.uncapitalize(test)); [EOL]     } [EOL]  [EOL] } [EOL]
@Test [EOL]     public void testUpperCase() { [EOL]         assertEquals(null, StringUtils.upperCase(null, null)); [EOL]         assertEquals("", StringUtils.upperCase("", Locale.getDefault())); [EOL]         assertEquals("  ", StringUtils.upperCase("  ", Locale.getDefault())); [EOL]          [EOL]         assertEquals("i", WordUtils.upperCase("I", Locale.getDefault())); [EOL]         assertEquals("I", WordUtils.upperCase("i", Locale.getDefault())); [EOL]         assertEquals("I AM HERE 123", StringUtils.upperCase("i am here 123", Locale.getDefault())); [EOL]         assertEquals("i aM hERE 123", StringUtils.upperCase("I Am Here 123", Locale.getDefault())); [EOL]         assertEquals("I AM here 123", StringUtils.upperCase("i am HERE 123", Locale.getDefault())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLowerCase() { [EOL]         assertEquals(null, StringUtils.lowerCase(null)); [EOL]         assertEquals("", StringUtils.lowerCase("")); [EOL]         assertEquals("  ", StringUtils.lowerCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.lowerCase("I") ); [EOL]         assertEquals("I", WordUtils.lowerCase("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.lowerCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.lowerCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.lowerCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.lowerCase("I AM HERE 123") ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUpperCase() { [EOL]         assertEquals(null, StringUtils.upperCase(null)); [EOL]         assertEquals("", StringUtils.upperCase("")); [EOL]         assertEquals("  ", StringUtils.upperCase("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.upperCase("I") ); [EOL]         assertEquals("I", WordUtils.upperCase("i") ); [EOL]         assertEquals("I AM HERE 123", StringUtils.upperCase("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", StringUtils.upperCase("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", StringUtils.upperCase("i am HERE 123") ); [EOL]         assertEquals("i am here 123", StringUtils.upperCase("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLowerCase_Locale() { [EOL]         assertEquals(null, StringUtils.lowerCase(null, null)); [EOL]         assertEquals("", StringUtils.lowerCase("", Locale.getDefault())); [EOL]         assertEquals("  ", StringUtils.lowerCase("  ", Locale.getDefault())); [EOL]          [EOL]         assertEquals("i", WordUtils.lowerCase("I", Locale.getDefault())); [EOL]         assertEquals("I", WordUtils.lowerCase("i", Locale.getDefault())); [EOL]         assertEquals("I AM HERE 123", StringUtils.lowerCase("i am here 123", Locale.getDefault())); [EOL]         assertEquals("i aM hERE 123", StringUtils.lowerCase("I Am Here 123", Locale.getDefault())); [EOL]         assertEquals("I AM here 123", StringUtils.lowerCase("i am HERE 123", Locale.getDefault())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0.0); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1.0); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2.0); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1.0); [EOL]         assertEquals(-16.0, f.getNumerator()); [EOL]         assertEquals(1, f.get
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/2"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getReducedFraction(-6, -10); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MAX_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getReducedFraction(-6, 10); [EOL]         assertEquals(-3, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getReducedFraction(1, -6); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getReducedFraction(-6, 5); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MAX_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex)
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getReducedFraction(-6, 5); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MAX_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getReducedFraction(-6, 10); [EOL]         assertEquals(-3, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getReducedFraction(1, -6); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(3, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction(Double.NaN); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         assertEquals(-1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]         assertEquals(-1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0.0); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1.0); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2.0); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0.0); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1.0); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2.0); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [
@Test [EOL]     public void testFactory_double_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex)
@Test [EOL]     public void testFactory_double_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex)
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getReducedFraction(-6, 10); [EOL]         assertEquals(-3, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getReducedFraction(1, -6); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getReducedFraction(-6, 5); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(1, -6); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(1, -6); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(3, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0.0); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1.0); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2.0); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1.0); [EOL]         assertEquals(-16.0, f.getNumerator()); [EOL]         assertEquals(1, f.get
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0.0); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1.0); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2.0); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getReducedFraction(-6, 10); [EOL]         assertEquals(-3, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getReducedFraction(1, -6); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0.0); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1.0); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2.0); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4.0); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1.0); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL
@Test [EOL]     public void testFactory_double_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex)
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testReducedFactory_int_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getReducedFraction(0, 1); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(1, 1); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getReducedFraction(2, 1); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getReducedFraction(3, 1); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getReducedFraction(-6, -10); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MIN_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getReducedFraction(Integer.MAX_VALUE, 1); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testSubtract() { [EOL]         Fraction f = null; [EOL]         Fraction f1 = null; [EOL]         Fraction f2 = null; [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(1, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(2, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(3, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [EOL]         f = f1.subtract(f2); [EOL]         assertEquals(-6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f1 = Fraction.getFraction(3, 5); [EOL]         f2 = Fraction.getFraction(-4, 5); [
@Test [EOL]     public void testFactory_double_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex)
@Test [EOL]     public void testFactory_double_int() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex)
@Test [EOL]     public void testFactory_String_proper() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction("0 0/1"); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 1/5"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(5, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("7 1/2"); [EOL]         assertEquals(15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("1 2/4"); [EOL]         assertEquals(6, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction("-7 1/2"); [EOL]         assertEquals(-15, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 3/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("a 3"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction("2 b/4"); [EOL]             fail("expecting NumberFormatException"); [EOL]         } catch (final NumberFormatException ex) {} [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(4d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NaN); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.NEGATIVE_INFINITY); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negative [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]
@Test [EOL]     public void testFactory_double() { [EOL]         Fraction f = null; [EOL]          [EOL]         // zero [EOL]         f = Fraction.getFraction(0d); [EOL]         assertEquals(0, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(1d); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(2d); [EOL]         assertEquals(2, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         // normal [EOL]         f = Fraction.getFraction(3d); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(2, f.getDenominator()); [EOL]          [EOL]         // negatives [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MIN_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(Double.MAX_VALUE); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]          [EOL]         // negatives [EOL]         f = Fraction.getFraction(-1d); [EOL]         assertEquals(-16, f.getNumerator()); [EOL]         assertEquals(1, f.getDenominator()); [EOL]          [EOL]         try { [EOL]             f = Fraction.getFraction(1d); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         final short[][] array3 = new short[2][3]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array2[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array3[i][j] = (short)((i + 1) * (j + 1)); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         final short[][] array3 = new short[2][3]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array2[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array3[i][j] = (short)((i + 1) * (j + 1)); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         final short[][] array3 = new short[2][3]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array2[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array3[i][j] = (short)((i + 1) * (j + 1)); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiShortArray() { [EOL]         final short[][] array1 = new short[2][2]; [EOL]         final short[][] array2 = new short[2][2]; [EOL]         final short[][] array3 = new short[2][3]; [EOL]         for (short i = 0; i < array1.length; ++i) { [EOL]             for (short j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array2[i][j] = (short)((i + 1) * (j + 1)); [EOL]                 array3[i][j] = (short)((i + 1) * (j + 1)); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> list = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), list); [EOL]         assertEquals(3, list.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> list = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), list); [EOL]         assertEquals(3, list.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final StrTokenizer tok = new StrTokenizer(); [EOL]         assertEquals(tok, tok.reset()); [EOL]         assertEquals(tok, tok.reset("")); [EOL]         assertEquals(tok, tok.setDelimiterMatcher(null)); [EOL]         assertEquals(tok, tok.setQuoteMatcher(null)); [EOL]         assertEquals(tok, tok.setIgnoredMatcher(null)); [EOL]         assertEquals(tok, tok.setTrimmerMatcher(null)); [EOL]         assertEquals(tok, tok.setIgnoreEmptyTokens(false)); [EOL]         assertEquals(tok, tok.setEmptyTokenAsNull(true)); [EOL]         assertEquals(tok, tok.setIgnoreEmptyTokens(false)); [EOL]         assertEquals(tok, tok.setIgnoreEmptyTokens(true)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("a", tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("b", tok.getContent()); [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("c", tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("d", tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("e", tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("f", tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("g", tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals("h", tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> list = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), list); [EOL]         assertEquals(3, list.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> list = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), list); [EOL]         assertEquals(3, list.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertEquals(null, tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final StrTokenizer tkn = new StrTokenizer("a b c"); [EOL]         assertFalse(tkn.hasPrevious()); [EOL]         try { [EOL]             tkn.previous(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("a", tkn.next()); [EOL]         try { [EOL]             tkn.remove(); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.set("x"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         try { [EOL]             tkn.add("y"); [EOL]             fail(); [EOL]         } catch (final UnsupportedOperationException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("b", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("c", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertTrue(tkn.hasNext()); [EOL]          [EOL]         assertEquals("d", tkn.next()); [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]          [EOL]         try { [EOL]             tkn.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         assertTrue(tkn.hasPrevious()); [EOL]         assertFalse(tkn.hasNext()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]         try { [EOL]             tok = tok.next(); [EOL]             fail(); [EOL]         } catch (final NoSuchElementException ex) {} [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> list = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), list); [EOL]         assertEquals(3, list.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testChaining() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testListArray() { [EOL]         final String input = "a  b c"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         final String[] array = tok.getTokenArray(); [EOL]         final List<?> list = tok.getTokenList(); [EOL]          [EOL]         assertEquals(Arrays.asList(array), list); [EOL]         assertEquals(3, list.size()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testBasicIgnoreTrimmed1() { [EOL]         final String input = "a: bIGNOREc : "; [EOL]         final StrTokenizer tok = new StrTokenizer(input, ':'); [EOL]         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); [EOL]         tok.setTrimmerMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         assertEquals("a", tok.next()); [EOL]         assertEquals("bc", tok.next()); [EOL]         assertFalse(tok.hasNext()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]  [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]         final String expected[] = new String[]{"a", "b", "c", "d", "e", "f"}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void test5() { [EOL]  [EOL]         final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; [EOL]         final StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.setDelimiterChar(';'); [EOL]         tok.setQuoteChar('"'); [EOL]         tok.setIgnoredMatcher(StrMatcher.trimMatcher()); [EOL]         tok.setIgnoreEmptyTokens(false); [EOL]         tok.setEmptyTokenAsNull(true); [EOL]         final String tokens[] = tok.getTokenArray(); [EOL]  [EOL]         final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; [EOL]  [EOL]         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", [EOL]                     ObjectUtils.equals(expected[i], tokens[i])); [EOL]         } [EOL]  [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUncapitalizeWithDelimiters_String() { [EOL]         assertEquals(null, WordUtils.uncapitalize(null, null)); [EOL]         assertEquals("", WordUtils.uncapitalize("", new char[0])); [EOL]         assertEquals("  ", WordUtils.uncapitalize("  ", new char[0])); [EOL]          [EOL]         char[] chars = new char[] { '-', '+', ' ', '@' }; [EOL]         assertEquals("i", WordUtils.uncapitalize("I", chars) ); [EOL]         assertEquals("i", WordUtils.uncapitalize("i", chars) ); [EOL]         assertEquals("i am-here+123", WordUtils.uncapitalize("i am-here+123", chars) ); [EOL]         assertEquals("i+am here-123", WordUtils.uncapitalize("I+Am Here-123", chars) ); [EOL]         assertEquals("i-am+hERE 123", WordUtils.uncapitalize("i-am+HERE 123", chars) ); [EOL]         assertEquals("i aM-hERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]         assertEquals("I AM-HERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]         assertEquals("i aM-hERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]         assertEquals("i am.fINE", WordUtils.uncapitalize("I AM-FINE", chars) ); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUncapitalizeWithDelimiters_String() { [EOL]         assertEquals(null, WordUtils.uncapitalize(null, null)); [EOL]         assertEquals("", WordUtils.uncapitalize("", new char[0])); [EOL]         assertEquals("  ", WordUtils.uncapitalize("  ", new char[0])); [EOL]          [EOL]         char[] chars = new char[] { '-', '+', ' ', '@' }; [EOL]         assertEquals("i", WordUtils.uncapitalize("I", chars) ); [EOL]         assertEquals("i", WordUtils.uncapitalize("i", chars) ); [EOL]         assertEquals("i am-here+123", WordUtils.uncapitalize("i am-here+123", chars) ); [EOL]         assertEquals("i+am here-123", WordUtils.uncapitalize("I+Am Here-123", chars) ); [EOL]         assertEquals("i-am+hERE 123", WordUtils.uncapitalize("i-am+HERE 123", chars) ); [EOL]         assertEquals("i aM-hERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]         assertEquals("I AM-HERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]         assertEquals("i aM-hERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testUncapitalizeWithDelimiters_String() { [EOL]         assertEquals(null, WordUtils.uncapitalize(null, null)); [EOL]         assertEquals("", WordUtils.uncapitalize("", new char[0])); [EOL]         assertEquals("  ", WordUtils.uncapitalize("  ", new char[0])); [EOL]          [EOL]         char[] chars = new char[] { '-', '+', ' ', '@' }; [EOL]         assertEquals("i", WordUtils.uncapitalize("I", chars) ); [EOL]         assertEquals("i", WordUtils.uncapitalize("i", chars) ); [EOL]         assertEquals("i am-here+123", WordUtils.uncapitalize("i am-here+123", chars) ); [EOL]         assertEquals("i+am here-123", WordUtils.uncapitalize("I+Am Here-123", chars) ); [EOL]         assertEquals("i-am+hERE 123", WordUtils.uncapitalize("i-am+HERE 123", chars) ); [EOL]         assertEquals("i aM-hERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]         assertEquals("I AM-HERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]         assertEquals("i aM-hERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); [EOL]         assertEquals("i am.fINE", WordUtils.uncapitalize("I AM-FINE", chars) ); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String_charArray() { [EOL]         assertEquals(null, WordUtils.initials(null, null)); [EOL]         assertEquals("", WordUtils.initials("", new char[0])); [EOL]         assertEquals("  ", WordUtils.initials("  ", new char[0])); [EOL]          [EOL]         char[] chars = new char[] { '-', '+', ' ', '@' }; [EOL]         assertEquals("i", WordUtils.initials("I", chars) ); [EOL]         assertEquals("i", WordUtils.initials("i", chars) ); [EOL]         assertEquals("i am-here+123", WordUtils.initials("i am-here+123", chars) ); [EOL]         assertEquals("i+am here-123", WordUtils.initials("I+Am Here-123", chars) ); [EOL]         assertEquals("i-am+hERE 123", WordUtils.initials("i-am+HERE 123", chars) ); [EOL]         assertEquals("i aM-hERE+123", WordUtils.initials("I AM-HERE+123", chars) ); [EOL]         assertEquals("i aM-hERE+123", WordUtils.initials("I AM-HERE+123", chars) ); [EOL]         assertEquals("i am.fINE", WordUtils.initials("I AM-FINE", null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testInitials_String() { [EOL]         assertEquals(null, WordUtils.initials(null)); [EOL]         assertEquals("", WordUtils.initials("")); [EOL]         assertEquals("  ", WordUtils.initials("  ")); [EOL]          [EOL]         assertEquals("i", WordUtils.initials("I") ); [EOL]         assertEquals("I", WordUtils.initials("i") ); [EOL]         assertEquals("I AM HERE 123", WordUtils.initials("i am here 123") ); [EOL]         assertEquals("i aM hERE 123", WordUtils.initials("I Am Here 123") ); [EOL]         assertEquals("I AM here 123", WordUtils.initials("i am HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]         assertEquals("i am here 123", WordUtils.initials("I AM HERE 123") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExcludeCollectionWithNulls() { [EOL]         final List<String> excludeList = new ArrayList<String>(); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]         this.validateSecretFieldPresent(toString); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]
@Test [EOL]     public void test_toStringExcludeCollectionWithNulls() { [EOL]         final List<String> excludeList = new ArrayList<String>(); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]         this.validateSecretFieldPresent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExcludeCollectionWithNulls() { [EOL]         final List<String> excludeList = new ArrayList<String>(); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]         this.validateSecretFieldPresent(toString); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExcludeCollectionWithNulls() { [EOL]         final List<String> excludeList = new ArrayList<String>(); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]         this.validateSecretFieldPresent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExcludeCollectionWithNulls() { [EOL]         final List<String> excludeList = new ArrayList<String>(); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]         this.validateSecretFieldPresent(toString); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toStringExcludeCollectionWithNulls() { [EOL]         final List<String> excludeList = new ArrayList<String>(); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         excludeList.add(null); [EOL]         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); [EOL]         this.validateSecretFieldPresent(toString); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionStatics() { [EOL]         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); [EOL]         assertEquals( [EOL]             this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", [EOL]             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRawType() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); [EOL]         Assert [EOL]                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, [EOL]                         null)); [EOL]         Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 StringParameterizedChild.class)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, [EOL]                 stringParentFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], [EOL]                 foosFieldType)); [EOL]         Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); [EOL]         Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class [EOL]                 .getDeclaredField("barParents").getGenericType(), null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testWrapperToPrimitive() { [EOL] //        assertEquals(boolean.class, ClassUtils.wrapperToPrimitive(boolean.class)); [EOL]         assertEquals(byte.class, ClassUtils.wrapperToPrimitive(byte.class)); [EOL]         assertEquals(char.class, ClassUtils.wrapperToPrimitive(char.class)); [EOL]         assertEquals(short.class, ClassUtils.wrapperToPrimitive(short.class)); [EOL]         assertEquals(int.class, ClassUtils.wrapperToPrimitive(int.class)); [EOL]         assertEquals(long.class, ClassUtils.wrapperToPrimitive(long.class)); [EOL]         assertEquals(float.class, ClassUtils.wrapperToPrimitive(float.class)); [EOL]         assertEquals(double.class, ClassUtils.wrapperToPrimitive(double.class)); [EOL]  [EOL]         //        assertEquals(boolean.class, ClassUtils.wrapperToPrimitive(boolean.class)); [EOL]         assertEquals(byte.class, ClassUtils.wrapperToPrimitive(byte.class)); [EOL]         assertEquals(char.class, ClassUtils.wrapperToPrimitive(char.class)); [EOL]         assertEquals(short.class, ClassUtils.wrapperToPrimitive(short.class)); [EOL]         assertEquals(int.class, ClassUtils.wrapperToPrimitive(int.class)); [EOL]         assertEquals(long.class, ClassUtils.wrapperToPrimitive(long.class)); [EOL]         assertEquals(float.class, ClassUtils.wrapperToPrimitive(float.class)); [EOL]  [EOL]         //        assertEquals(boolean.class, ClassUtils.wrapperToPrimitive(boolean.class)); [EOL]         assertEquals(byte.class, ClassUtils.wrapperToPrimitive(byte.class)); [EOL]         assertEquals(char.class, ClassUtils.wrapperToPrimitive(char.class)); [EOL]         assertEquals(short.class, ClassUtils.wrapperToPrimitive(short.class)); [EOL]         assertEquals(int.class, ClassUtils.wrapperToPrimitive(int.class)); [EOL]         assertEquals(long.class, ClassUtils.wrapperToPrimitive(long.class)); [EOL]  [EOL]         //        assertEquals(boolean.class, ClassUtils.wrapperToPrimitive(float.class)); [EOL]
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable((Class[]) null, (Class[]) null, true)); [EOL]         assertTrue(ClassUtils.isAssignable((Class[]) null, (Class<?>) null, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(Class
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1s, array1s, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1s, array1s, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void testGetPublicMethod() throws Exception { [EOL]         // Tests with Collections$UnmodifiableSet [EOL]         final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); [EOL]         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty",  new Class[0]); [EOL]             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); [EOL]  [EOL]         try { [EOL]             isEmptyMethod.invoke(set, new Object[0]); [EOL]         } catch(final java.lang.IllegalAccessException iae) { [EOL]             fail("Should not have thrown IllegalAccessException"); [EOL]         } [EOL]  [EOL]         // Tests with a public Class [EOL]         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString",  new Class[0]); [EOL]             assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable((Class[]) null, (Class[]) null, true)); [EOL]         assertTrue(ClassUtils.isAssignable((Class[]) null, (Class<?>) null, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]         assertTrue(ClassUtils.
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {Object.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array1, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testWeekIterator() throws Exception { [EOL]         final Calendar now = Calendar.getInstance(); [EOL]         for (int i = 0; i< 7; i++) { [EOL]             final Calendar today = DateUtils.truncate(now, Calendar.DATE); [EOL]             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); [EOL]             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); [EOL]             final Calendar monday = DateUtils.truncate(now, Calendar.DATE); [EOL]             if (monday.get(Calendar.DAY_OF_WEEK) == 1) { [EOL]                 //This is sunday... roll back 6 days [EOL]                 monday.add(Calendar.DATE, -6); [EOL]             } else { [EOL]                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); [EOL]             } [EOL]             final Calendar centered = DateUtils.truncate(now, Calendar.DATE); [EOL]             centered.add(Calendar.DATE, -3); [EOL]              [EOL]             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); [EOL]             assertWeekIterator(it, sunday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); [EOL]             assertWeekIterator(it, monday); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); [EOL]             assertWeekIterator(it, today); [EOL]             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); [EOL]             assertWeekIterator(it, centered); [EOL]             try { [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, -1, -2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]         assertEquals("",
@Test [EOL]     public void testJoin_IterableString() { [EOL]         assertEquals(null, StringUtils.join((Iterable<?>) null, null)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), null)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), "")); [EOL]         assertEquals("foo", StringUtils.join(Collections.singleton("foo"), "foo")); [EOL]         assertEquals("foo", StringUtils.join(Collections.singleton("foo"), null)); [EOL]  [EOL]         assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), "")); [EOL]         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), null)); [EOL]  [EOL]         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), "")); [EOL]         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), "foo")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]          [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 3, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 3, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayStringIntInt() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, ",", 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayStringIntInt() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, ",", 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_IterableString() { [EOL]         assertEquals(null, StringUtils.join((Iterable<?>) null, (String) null)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), (String) null)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), "")); [EOL]         assertEquals("foo", StringUtils.join(Collections.singleton("foo"), "foo")); [EOL]         assertEquals("foo", StringUtils.join(Collections.singleton("foo"), null)); [EOL]  [EOL]         assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), "")); [EOL]         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), null)); [EOL]  [EOL]         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), "")); [EOL]         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), "foo")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, "")); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, "")); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayStringIntInt() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, ",", 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, "")); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayStringIntInt() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 1)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 2)); [EOL]          [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, -1, -2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "", 0, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "", 1, 2)); [EOL]         assertEquals("",
@Test [EOL]     public void testJoin_ArrayStringIntInt() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, ",", 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayStringIntInt() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 1)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, "")); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayString() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, null, 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 1)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, null, 0, 1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); [EOL]          [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, null, 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, null, 2, 1)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayStringIntInt() { [EOL]         assertEquals(null, StringUtils.join((Object[]) null, ",", 0, 0)); [EOL]         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR, 0, 0)); [EOL]         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR, 0, 1)); [EOL]  [EOL]         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); [EOL]         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); [EOL]         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); [EOL]         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); [EOL]         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); [EOL]         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test [EOL]     public void testRemoveElementObjectArray() { [EOL]         Object[] array; [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); [EOL]         assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((Object[]) null, "a", "b"); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); [EOL]         assertEquals(Integer.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new Object[] { "
@Test(expected=IllegalArgumentException.class) [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         ExceptionUtils.removeCommonFrames(null, null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackTrace_Throwable() { [EOL]         Throwable th = null; [EOL]         String stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new IllegalArgumentException("Base"); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new ExceptionWithCause("Wrapper", th); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(4, list.size()); [EOL]         assertEquals("IllegalArgumentException", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         ByteArrayOutputStream out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(out)); [EOL]          [EOL]         assertEquals(0, out.toString().length()); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         String stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         ByteArrayOutputStream out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(out)); [EOL]          [EOL]         assertEquals(0, out.toString().length()); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         String stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2));
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         List<String> list = null; [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         List<String> list1 = new ArrayList<String>(); [EOL]         list1.add("Frame 0"); [EOL]         list1.add("Frame 1"); [EOL]         list1.add("Frame 2"); [EOL]         list = new ArrayList<String>(); [EOL]         list1.add("Frame 3"); [EOL]         list1.add("Frame 4"); [EOL]         list1.add("Frame 5"); [EOL]         list1.add("Frame 6"); [EOL]         list1.add("Frame 7"); [EOL]         assertEquals(5, list.size()); [EOL]         assertEquals("Frame 0", list.get(0)); [EOL]         assertEquals("Frame 1", list.get(1)); [EOL]         assertEquals("Frame 2", list.get(2)); [EOL]         assertEquals("Frame 3", list.get(3)); [EOL]         assertEquals("Frame 4", list.get(5)); [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, list1); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("Frame 5", list.get(0)); [EOL]         assertEquals("Frame 6", list.get(1)); [EOL]         assertEquals("Frame 7", list.get(2)); [EOL]         assertEquals("Frame 8", list.get(3)); [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, list1); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals
@Test [EOL]     public void testGetStackTrace_Throwable() { [EOL]         Throwable th = null; [EOL]         String stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new IllegalArgumentException("Base"); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new ExceptionWithCause("Wrapper", th); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertSame(ArrayUtils.EMPTY_STRING_ARRAY, ExceptionUtils.getRootCauseStackTrace(withoutCause)); [EOL]         assertSame(ArrayUtils.EMPTY_STRING_ARRAY, ExceptionUtils.getRootCauseStackTrace(nested)); [EOL]         assertSame(ArrayUtils.EMPTY_STRING_ARRAY, ExceptionUtils.getRootCauseStackTrace(withCause)); [EOL]         assertSame(ArrayUtils.EMPTY_STRING_ARRAY, ExceptionUtils.getRootCauseStackTrace(withCause)); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new String[] { ExceptionUtils.WRAPPED_MARKER + "withoutCause" }, ExceptionUtils.getRootCauseStackTrace(withoutCause))); [EOL]         assertTrue(Arrays.equals( [EOL]             new String[] { ExceptionUtils.WRAPPED_MARKER + "nested" }, ExceptionUtils.getRootCauseStackTrace(nested))); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new String[] { ExceptionUtils.WRAPPED_MARKER + "withCause" }, ExceptionUtils.getRootCauseStackTrace(withCause))); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new String[] { ExceptionUtils.WRAPPED_MARKER + "nested", ExceptionUtils.WRAPPED_MARKER + "withCause" }, ExceptionUtils.getRootCauseStackTrace(withCause))); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new String[] { ExceptionUtils.WRAPPED_MARKER + "withCause" }, ExceptionUtils.getRootCauseStackTrace(withCause))); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new String[] { ExceptionUtils.WRAPPED_MARKER + "withCause" }, ExceptionUtils.getRootCauseStackTrace(withCause))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(jdkNoCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(cyclicCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         List<String> list = null; [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         List<String> list1 = new ArrayList<String>(); [EOL]         list1.add("Frame 0"); [EOL]         list1.add("Frame 1"); [EOL]         list1.add("Frame 2"); [EOL]         list = new ArrayList<String>(); [EOL]         list1.add("Frame 3"); [EOL]         list1.add("Frame 4"); [EOL]         list1.add("Frame 5"); [EOL]         list1.add("Frame 6"); [EOL]         list1.add("Frame 7"); [EOL]         assertEquals(5, list.size()); [EOL]         assertEquals("Frame 0", list.get(0)); [EOL]         assertEquals("Frame 1", list.get(1)); [EOL]         assertEquals("Frame 2", list.get(2)); [EOL]         assertEquals("Frame 3", list.get(3)); [EOL]         assertEquals("Frame 4", list.get(5)); [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, list1); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("Frame 5", list.get(0)); [EOL]         assertEquals("Frame 6", list.get(1)); [EOL]         assertEquals("Frame 7", list.get(2)); [EOL]         assertEquals("Frame 8", list.get(3)); [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(null, list); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         List<String> list = new ArrayList<String>(); [EOL]         list.add("Frame 0"); [EOL]         list.add("Frame 1"); [EOL]         list.add("Frame 2"); [EOL]         list.add("Frame 3"); [EOL]         list.add("Frame 4"); [EOL]         List<String> list2 = new ArrayList<String>(); [EOL]         list2.add("Frame 5"); [EOL]         list2.add("Frame 6"); [EOL]         list.add("Frame 7"); [EOL]         list2.add("Frame 8"); [EOL]         list2.add("Frame 9"); [EOL]         ExceptionUtils.removeCommonFrames(list, list2); [EOL]         assertEquals(4, list.size()); [EOL]         assertEquals("Frame 0", list.get(0)); [EOL]         assertEquals("Frame 1", list.get(1)); [EOL]         assertEquals("Frame 2", list.get(2)); [EOL]         assertEquals("Frame 3", list.get(3)); [EOL]         assertEquals("Frame 4", list.get(5)); [EOL]          [EOL]         assertEquals(null, ExceptionUtils.getRootCause(null)); [EOL]         assertEquals(null, ExceptionUtils.getRootCause(list)); [EOL]          [EOL]         list = new ArrayList<String>(); [EOL]         list.add("Frame 0"); [EOL]         list.add("Frame 1"); [EOL]         list.add("Frame 2"); [EOL]         list.add("Frame 3"); [EOL]         list.add("Frame 4"); [EOL]         list.add("Frame 5"); [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, list); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(null, ExceptionUtils.getRootCause(list)); [
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         ByteArrayOutputStream out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(out)); [EOL]          [EOL]         assertEquals(0, out.toString().length()); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         String stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackTrace_Throwable() { [EOL]         Throwable th = null; [EOL]         String stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new IllegalArgumentException("Base"); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new ExceptionWithCause("Wrapper", th); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new ExceptionWithoutCause("Wrapper", th); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2));
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         List<String> list = new ArrayList<String>(); [EOL]         list.add("Frame 0"); [EOL]         list.add("Frame 1"); [EOL]         list.add("Frame 2"); [EOL]         list.add("Frame 3"); [EOL]         list.add("Frame 4"); [EOL]         List<String> list2 = new ArrayList<String>(); [EOL]         list2.add("Frame 5"); [EOL]         list2.add("Frame 6"); [EOL]         list.add("Frame 7"); [EOL]         list2.add("Frame 8"); [EOL]         list.add("Frame 9"); [EOL]         ExceptionUtils.removeCommonFrames(list, list2); [EOL]         assertEquals(4, list.size()); [EOL]         assertEquals("Frame 0", list.get(0)); [EOL]         assertEquals("Frame 1", list.get(1)); [EOL]         assertEquals("Frame 2", list.get(2)); [EOL]         assertEquals("Frame 3", list.get(3)); [EOL]         assertEquals("Frame 4", list.get(5)); [EOL]          [EOL]         assertEquals(null, ExceptionUtils.getRootCause(null)); [EOL]         assertEquals(null, ExceptionUtils.getRootCause(list)); [EOL]          [EOL]         list = new ArrayList<String>(); [EOL]         list.add("Frame 0"); [EOL]         list.add("Frame 1"); [EOL]         list.add("Frame 2"); [EOL]         list.add("Frame 3"); [EOL]         list.add("Frame 4"); [EOL]         list.add("Frame 5"); [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, list); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(null, ExceptionUtils.getRootCause(list)); [EOL
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2));
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         ByteArrayOutputStream out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(out)); [EOL]          [EOL]         assertEquals(0, out.toString().length()); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         String stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(jdkNoCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(cyclicCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_Throwable() throws Exception { [EOL]         ByteArrayOutputStream out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(out)); [EOL]         assertEquals(0, out.toString().length()); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(out)); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         String stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2));
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         ByteArrayOutputStream out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(out)); [EOL]          [EOL]         assertEquals(0, out.toString().length()); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         String stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(
@Test(expected=IllegalArgumentException.class) [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         ExceptionUtils.removeCommonFrames(null, null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         ByteArrayOutputStream out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(out)); [EOL]          [EOL]         assertEquals(0, out.toString().length()); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         String stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackTraceFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackTraceFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackTraceFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackTraceFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackTraceFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackTraceFrameList(t); [EOL]         assertEquals(4, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackTraceFrameList(t); [EOL]         assertEquals(5, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         List<String> list = new ArrayList<String>(); [EOL]         list.add("Frame 0"); [EOL]         list.add("Frame 1"); [EOL]         list.add("Frame 2"); [EOL]         list.add("Frame 3"); [EOL]         list.add("Frame 4"); [EOL]         List<String> list2 = new ArrayList<String>(); [EOL]         list2.add("Frame 5"); [EOL]         list2.add("Frame 6"); [EOL]         list.add("Frame 7"); [EOL]         list2.add("Frame 8"); [EOL]         list2.add("Frame 9"); [EOL]         ExceptionUtils.removeCommonFrames(list, list2); [EOL]         assertEquals(4, list.size()); [EOL]         assertEquals("Frame 0", list.get(0)); [EOL]         assertEquals("Frame 1", list.get(1)); [EOL]         assertEquals("Frame 2", list.get(2)); [EOL]         assertEquals("Frame 3", list.get(3)); [EOL]         assertEquals("Frame 4", list.get(5)); [EOL]          [EOL]         assertEquals(null, ExceptionUtils.getRootCause(null)); [EOL]         assertEquals(null, ExceptionUtils.getRootCause(list)); [EOL]          [EOL]         list = new ArrayList<String>(); [EOL]         list.add("Frame 0"); [EOL]         list.add("Frame 1"); [EOL]         list.add("Frame 2"); [EOL]         list.add("Frame 3"); [EOL]         list.add("Frame 4"); [EOL]         list.add("Frame 5"); [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, list); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(null, ExceptionUtils.getRootCause(list)); [
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]         ExceptionUtils.removeCommonFrames(withoutCause, null); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(withoutCause, Arrays.asList(new String[]{"Throwable"})); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(withoutCause, Arrays.asList(new String[]{"Throwable"})); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(withoutCause, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(withoutCause, new ArrayList<String>()); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(withoutCause, new ArrayList<String>()); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); [EOL]         assertEquals(1, throwables.length); [EOL]         assertSame(withoutCause, throwables[0]); [EOL]         ExceptionUtils.removeCommonFrames(withoutCause, null); [EOL]         assertEquals(0, throwables.length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetRootCauseStackTrace_Throwable() { [EOL]         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withoutCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(nested).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]          [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]         assertEquals(1, ExceptionUtils.getRootCauseStackTrace(withCause).length); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveCommonFrames_ListList() throws Exception { [EOL]         List<String> list = new ArrayList<String>(); [EOL]         list.add("Frame 0"); [EOL]         list.add("Frame 1"); [EOL]         list.add("Frame 2"); [EOL]         list.add("Frame 3"); [EOL]         list.add("Frame 4"); [EOL]         ExceptionUtils.removeCommonFrames(list, null); [EOL]         assertEquals(0, list.size()); [EOL]         list = null; [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, list); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("Frame 0", ExceptionUtils.getRootCause(list).getMessage()); [EOL]          [EOL]         list = new ArrayList<String>(); [EOL]         list.add("Frame 1"); [EOL]         list.add("Frame 2"); [EOL]         list.add("Frame 3"); [EOL]         list.add("Frame 4"); [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, list); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("Frame 2", ExceptionUtils.getRootCause(list).getMessage()); [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(list, null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("Frame 3", ExceptionUtils.getRootCause(list).getMessage()); [EOL]         } catch (final IllegalStateException ex) {} [EOL]          [EOL]         try { [EOL]             ExceptionUtils.removeCommonFrames(null, list); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) {} [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("Frame 4", ExceptionUtils.getRootCause(list).getMessage());
@Test [EOL]     public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { [EOL]         ByteArrayOutputStream out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); [EOL]         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(out)); [EOL]          [EOL]         assertEquals(0, out.toString().length()); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         try { [EOL]             ExceptionUtils.printRootCauseStackTrace(withoutCause, (PrintWriter) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]         } [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         final Throwable withCause = createExceptionWithCause(); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         String stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]          [EOL]         out = new ByteArrayOutputStream(1024); [EOL]         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(out)); [EOL]         stackTrace = out.toString(); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(
@Test [EOL]     public void testGetStackTrace_Throwable() { [EOL]         Throwable th = null; [EOL]         String stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new IllegalArgumentException("Base"); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new ExceptionWithCause("Wrapper", th); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(4, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2));
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2));
@Test [EOL]     public void testGetStackFrameList_Throwable() { [EOL]         Throwable t = null; [EOL]         List<String> list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(0, list.size()); [EOL]          [EOL]         t = new IllegalArgumentException("Message"); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(1, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(2, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Wrapper", list.get(1)); [EOL]         assertEquals("Message", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2)); [EOL]          [EOL]         t = new ExceptionWithCause("Wrapper", t); [EOL]         list = ExceptionUtils.getStackFrameList(t); [EOL]         assertEquals(3, list.size()); [EOL]         assertEquals("IllegalArgumentException: Message", list.get(0)); [EOL]         assertEquals("Message", list.get(1)); [EOL]         assertEquals("Wrapper", list.get(2));
@Test [EOL]     public void testGetStackTrace_Throwable() { [EOL]         Throwable th = null; [EOL]         String stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new IllegalArgumentException("Base"); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]          [EOL]         th = new ExceptionWithCause("Wrapper", th); [EOL]         stackTrace = ExceptionUtils.getStackTrace(th); [EOL]         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) >= 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(4, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "1", "2", "3", "4" }); [EOL]         assertEquals(5, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assertEquals("4
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToMap_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("2", map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", "4" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assert
@Test [EOL]     public void testToMap_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(4, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "1", "2", "3", "4" }); [EOL]         assertEquals(5, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assertEquals("4
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(4, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "1", "2", "3", "4" }); [EOL]         assertEquals(5, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assertEquals("4
@Test [EOL]     public void testToMap_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("2", map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", "4" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assert
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] b = null; [EOL]         assertEquals(null, ArrayUtils.toMap(b)); [EOL]          [EOL]         assertSame(null, ArrayUtils.toMap(new Object[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {Boolean.TRUE, Boolean.FALSE})) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {Boolean.TRUE, null, Boolean.FALSE})) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {Boolean.TRUE, null, Boolean.FALSE})) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(4, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "1", "2", "3", "4" }); [EOL]         assertEquals(5, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assertEquals("4
@Test [EOL]     public void testToMap_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("2", map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", "4" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assert
@Test [EOL]     public void testToMap_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("2", map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", "4" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assert
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(4, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]         assertEquals("3", map.get("3")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] b = null; [EOL]         assertEquals(null, ArrayUtils.toMap(b)); [EOL]          [EOL]         assertSame(null, ArrayUtils.toMap(new Object[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {Boolean.TRUE, Boolean.FALSE})) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {Boolean.TRUE, null, Boolean.FALSE})) [EOL]         ); [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {Boolean.TRUE, null, Boolean.FALSE})) [EOL]         ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] b = null; [EOL]         assertEquals(null, ArrayUtils.toMap(b)); [EOL]          [EOL]         assertSame(null, ArrayUtils.toMap(new Object[0])); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {new String(new char[] { 'f', 'o', 'o' }))); [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {new char[] { 'f', 'O', 'O' }))); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {new char[] { 'f', 'O', 'O' }))); [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {new char[] { 'f', 'O', 'O' }))); [EOL]          [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {new boolean[] { true, false }))); [EOL]         assertTrue(Arrays.equals( [EOL]             new HashMap<Object, Object>(), [EOL]             ArrayUtils.toMap(new Object[] {new boolean[] { true, false }))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToMap_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("2", map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", "4" }); [EOL]         assertEquals(6, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assert
@Test [EOL]     public void testToObject_object() { [EOL]         final Object[] obj = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         final Map<Object, Object> map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]         assertEquals(null, map.get("3")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(obj); [EOL]         assertEquals(3, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "0", "1", "2", "3", null, "0" }); [EOL]         assertEquals(4, map.size()); [EOL]         assertEquals("0", map.get("0")); [EOL]         assertEquals("1", map.get("1")); [EOL]         assertEquals("2", map.get("2")); [EOL]          [EOL]         map = ArrayUtils.toMap(new Object[] { "1", "2", "3", "4" }); [EOL]         assertEquals(5, map.size()); [EOL]         assertEquals("0", map.get("1")); [EOL]         assertEquals("1", map.get("2")); [EOL]         assertEquals("3", map.get("3")); [EOL]         assertEquals("4
@Test [EOL]     public void testLongArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode()); [EOL]         final long[] obj = new long[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5L; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6L; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6L, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode()); [EOL]         final long[] obj = new long[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5L; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6L; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6L, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode()); [EOL]         final long[] obj = new long[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5L; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6L; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6L, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode()); [EOL]         final long[] obj = new long[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5L; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6L; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6L, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLongArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode()); [EOL]         final long[] obj = new long[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5L; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6L; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6L, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDateDefaults() { [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getDateInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getDateInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             total
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testTimeDateDefaults() { [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDateDefaults() { [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTimeDefaults() { [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); [EOL]  [EOL]         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), [EOL]                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testHandleCauseCheckedChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex)); [EOL]             fail("ConcurrentRuntimeException not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException crex) { [EOL]             assertEquals("Wrong cause", ex, crex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests handleCauseChecked() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testHandleCauseChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.handleCause(new ExecutionException(ex)); [EOL]             fail("ConcurrentException not thrown!"); [EOL]         } catch (final ConcurrentException cex) { [EOL]             assertEquals("Wrong cause", ex, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests handleCause() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testExtractCauseChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.extractCauseChecked(new ExecutionException(ex)); [EOL]             fail("ConcurrentRuntimeException not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException cex) { [EOL]             assertEquals("Wrong cause", ex, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests extractCause() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testHandleCauseChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex)); [EOL]             fail("ConcurrentRuntimeException not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException crex) { [EOL]             assertEquals("Wrong cause", ex, crex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests handleCauseUnchecked() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testExtractCauseChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.extractCauseChecked(new ExecutionException(ex)); [EOL]             fail("ConcurrentRuntimeException not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException cex) { [EOL]             assertEquals("Wrong cause", ex, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testExtractCauseChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.extractCauseChecked(new ExecutionException(ex)); [EOL]             fail("ConcurrentRuntimeException not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException cex) { [EOL]             assertEquals("Wrong cause", ex, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests extractCauseChecked() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testHandleCauseCheckedChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex)); [EOL]             fail("ConcurrentRuntimeException not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException crex) { [EOL]             assertEquals("Wrong cause", ex, crex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests handleCauseUnchecked() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testConcurrentRuntimeExceptionCauseUnchecked() { [EOL]         new ConcurrentRuntimeException(new RuntimeException()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tries to create a ConcurrentRuntimeException with an error as cause. [EOL]      */ [EOL]
@Test [EOL]     public void testHandleCauseCheckedChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex)); [EOL]             fail("ConcurrentRuntimeException not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException crex) { [EOL]             assertEquals("Wrong cause", ex, crex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests handleCauseUnchecked() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testHandleCauseChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.handleCause(new ExecutionException(ex)); [EOL]             fail("ConcurrentException not thrown!"); [EOL]         } catch (final ConcurrentException cex) { [EOL]             assertEquals("Wrong cause", ex, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests handleCause() for a null parameter or a null cause. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testExtractCauseChecked() { [EOL]         final Exception ex = new Exception("Test"); [EOL]         try { [EOL]             ConcurrentUtils.extractCauseChecked(new ExecutionException(ex)); [EOL]             fail("ConcurrentRuntimeException not thrown!"); [EOL]         } catch (final ConcurrentRuntimeException cex) { [EOL]             assertEquals("Wrong cause", ex, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_String_int_int() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, 0, 1, 2); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(0, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(1, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(2, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(3, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(4, 1, 2, -1); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll(5, 1, 2, -1); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll(6, 1, 2, -1); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4");
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceAll_String_int_int() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, 0, 1, 2); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(0, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(1, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(2, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(3, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(4, 1, 2, -1); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll(5, 1, 2, -1); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll(6, 1, 2, -1); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4");
@Test [EOL]     public void testReplaceAll_String_int_int() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, 0, 1, 2); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(0, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(1, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(2, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(3, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(4, 1, 2, -1); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll(5, 1, 2, -1); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll(6, 1, 2, -1); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4");
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceAll_String_int_int() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, 0, 1, 2); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(0, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(1, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(2, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(3, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(4, 1, 2, -1); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll(5, 1, 2, -1); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll(6, 1, 2, -1); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4");
@Test [EOL]     public void testReplaceAll_String_int_int() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, 0, 1, 2); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(0, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(1, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(2, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(3, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(4, 1, 2, -1); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll(5, 1, 2, -1); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll(6, 1, 2, -1); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4");
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder
@Test [EOL]     public void testIndexOf_char_int() { [EOL]         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); [EOL]         assertEquals(2, sb.indexOf('a', -1)); [EOL]         assertEquals(2, sb.indexOf('z', 0)); [EOL]         assertEquals(-1, sb.indexOf('a', 1)); [EOL]         assertEquals(-1, sb.indexOf('z', 2)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(4, sb.indexOf('a', 3)); [EOL]         assertEquals(4, sb.indexOf('z', 2)); [EOL]         assertEquals(-1, sb.indexOf('z', -1)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(6, sb.indexOf('a', 5)); [EOL]         assertEquals(5, sb.indexOf('z', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_char_int() { [EOL]         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); [EOL]         assertEquals(2, sb.indexOf('a', -1)); [EOL]         assertEquals(2, sb.indexOf('z', 0)); [EOL]         assertEquals(-1, sb.indexOf('a', 1)); [EOL]         assertEquals(-1, sb.indexOf('z', 2)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(4, sb.indexOf('a', 3)); [EOL]         assertEquals(4, sb.indexOf('z', 2)); [EOL]         assertEquals(-1, sb.indexOf('z', -1)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(6, sb.indexOf('a', 5)); [EOL]         assertEquals(5, sb.indexOf('z', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_char_int() { [EOL]         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); [EOL]         assertEquals(2, sb.indexOf('a', -1)); [EOL]         assertEquals(2, sb.indexOf('z', 0)); [EOL]         assertEquals(-1, sb.indexOf('a', 1)); [EOL]         assertEquals(-1, sb.indexOf('z', 2)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(4, sb.indexOf('a', 3)); [EOL]         assertEquals(4, sb.indexOf('z', 2)); [EOL]         assertEquals(-1, sb.indexOf('z', -1)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(6, sb.indexOf('a', 5)); [EOL]         assertEquals(5, sb.indexOf('z', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_char_int() { [EOL]         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); [EOL]         assertEquals(2, sb.indexOf('a', -1)); [EOL]         assertEquals(2, sb.indexOf('z', 0)); [EOL]         assertEquals(-1, sb.indexOf('a', 1)); [EOL]         assertEquals(-1, sb.indexOf('z', 2)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(4, sb.indexOf('a', 3)); [EOL]         assertEquals(4, sb.indexOf('z', 2)); [EOL]         assertEquals(-1, sb.indexOf('z', -1)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(6, sb.indexOf('a', 5)); [EOL]         assertEquals(5, sb.indexOf('z', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_char_int() { [EOL]         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); [EOL]         assertEquals(2, sb.indexOf('a', -1)); [EOL]         assertEquals(2, sb.indexOf('z', 0)); [EOL]         assertEquals(-1, sb.indexOf('a', 1)); [EOL]         assertEquals(-1, sb.indexOf('z', 2)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(4, sb.indexOf('a', 3)); [EOL]         assertEquals(4, sb.indexOf('z', 2)); [EOL]         assertEquals(-1, sb.indexOf('z', -1)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(6, sb.indexOf('a', 5)); [EOL]         assertEquals(5, sb.indexOf('z', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll("b", "xbx"); [EOL]         assertEquals("axbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceAll_String_int_int() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, 0, 1, 2); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(0, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(1, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(2, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(3, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(4, 1, 2, -1); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll(5, 1, 2, -1); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll(6, 1, 2, -1); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4");
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_String_int_int() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, 1, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(0, 1, 0); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(1, 1, 1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(2, 1, 2); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(3, 1, 3); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll(4, 1, 4); [EOL]         assertEquals("bbccba", sb.toString()); [EOL]         sb.replaceAll(5, 1, 5); [EOL]         assertEquals("bccba", sb.toString()); [EOL]         sb.replaceAll(6, 1, 6); [EOL]         assertEquals("", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_String_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll((String) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("", "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceAll("x", "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll("a", "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll("d", null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll("cb", "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(null, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_char_int() { [EOL]         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); [EOL]         assertEquals(2, sb.indexOf('a', -1)); [EOL]         assertEquals(2, sb.indexOf('z', 0)); [EOL]         assertEquals(-1, sb.indexOf('a', 1)); [EOL]         assertEquals(-1, sb.indexOf('z', 2)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(4, sb.indexOf('a', 3)); [EOL]         assertEquals(4, sb.indexOf('z', 2)); [EOL]         assertEquals(-1, sb.indexOf('z', -1)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(6, sb.indexOf('a', 5)); [EOL]         assertEquals(5, sb.indexOf('z', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_char_int() { [EOL]         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); [EOL]         assertEquals(2, sb.indexOf('a', -1)); [EOL]         assertEquals(2, sb.indexOf('z', 0)); [EOL]         assertEquals(-1, sb.indexOf('a', 1)); [EOL]         assertEquals(-1, sb.indexOf('z', 2)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(4, sb.indexOf('a', 3)); [EOL]         assertEquals(4, sb.indexOf('z', 2)); [EOL]         assertEquals(-1, sb.indexOf('z', -1)); [EOL]          [EOL]         sb.append("junit"); [EOL]         assertEquals(6, sb.indexOf('a', 5)); [EOL]         assertEquals(5, sb.indexOf('z', 6)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReplaceAll_String_int_int() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceAll((String) null, 0, 1, 2); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(0, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(1, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(2, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(3, 1, 2, -1); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceAll(4, 1, 2, -1); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceAll(5, 1, 2, -1); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceAll(6, 1, 2, -1); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("xbxxbx", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceAll(0, 10, 10, "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4");
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOf_String_int() { [EOL]         final StrBuilder sb = new StrBuilder("abab"); [EOL]          [EOL]         assertEquals(2, sb.indexOf("a")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("a"), sb.indexOf("a")); [EOL]          [EOL]         assertEquals(2, sb.indexOf("ab")); [EOL]         //should work like String#indexOf [EOL]         assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); [EOL]          [EOL]         assertEquals(3, sb.indexOf("b")); [EOL]         assertEquals("abab".indexOf("b"), sb.indexOf("b")); [EOL]          [EOL]         assertEquals(1, sb.indexOf("ba")); [EOL]         assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf("z")); [EOL]          [EOL]         assertEquals(-1, sb.indexOf((String) null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsBeforeRange() { [EOL]         assertFalse(intRange.isBeforeRange(null)); [EOL]          [EOL]         assertTrue(intRange.isBeforeRange(Range.between(5, 9))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare(){ [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsBeforeRange() { [EOL]         assertFalse(intRange.isBeforeRange(null)); [EOL]          [EOL]         assertTrue(intRange.isBeforeRange(Range.between(5, 9))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsBeforeRange() { [EOL]         assertFalse(intRange.isBeforeRange(null)); [EOL]          [EOL]         assertTrue(intRange.isBeforeRange(Range.between(5, 9))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsBeforeRange() { [EOL]         assertFalse(intRange.isBeforeRange(null)); [EOL]          [EOL]         assertTrue(intRange.isBeforeRange(Range.between(5, 9))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare(){ [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCompareObject() { [EOL]         final Object o1 = new Object(); [EOL]         final Object o2 = new Object(); [EOL]         final Comparator<Object> c = new Comparator<Object>(){ [EOL]             @Override [EOL]             public int compare(final Object o1, final Object o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Object> ri = Range.is(o1); [EOL]         assertEquals(-1, ri.compare(o1, o1)); [EOL]         assertEquals(0, ri.compare(o1, o2)); [EOL]          [EOL]         ri = Range.is(null); [EOL]         assertEquals(-1, ri.compare(null, o1)); [EOL]         assertEquals(-1, ri.compare(null, o2)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertEquals(-1, ri.compare(null, null)); [EOL]         assertEquals(-1, ri.compare(null, "Ni!")); [EOL]          [EOL]         ri = Range.is(10,c); [EOL]         assertEquals(0, ri.compare(null, "Ni!")); [EOL]         assertEquals(+1, ri.compare("Ni!")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsBeforeRange() { [EOL]         assertFalse(intRange.isBeforeRange(null)); [EOL]          [EOL]         assertTrue(intRange.isBeforeRange(Range.between(5, 9))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBetween() { [EOL]         final Integer low = Integer.valueOf(10); [EOL]         final Integer mid = Integer.valueOf(11); [EOL]         final Integer high = Integer.valueOf(12); [EOL]         final Range<Integer> ri = Range.between(low, mid); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 0",ri.contains(0)); [EOL]         assertTrue("should contain 1",ri.contains(1)); [EOL]         assertTrue("should contain 2",ri.contains(2)); [EOL]          [EOL]         ri = Range.between(low, mid); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 0",ri.contains(0)); [EOL]         assertTrue("should contain 1",ri.contains(1)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsBeforeRange() { [EOL]         assertFalse(intRange.isBeforeRange(null)); [EOL]          [EOL]         assertTrue(intRange.isBeforeRange(Range.between(5, 9))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare() { [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsWithCompare(){ [EOL]         final Comparator<Integer> c = new Comparator<Integer>(){ [EOL]             @Override [EOL]             public int compare(final Integer o1, final Integer o2) { [EOL]                 return 0; // all integers are equal [EOL]             } [EOL]         }; [EOL]         Range<Integer> ri = Range.is(10); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]         ri = Range.is(10,c); [EOL]         assertFalse("should not contain null",ri.contains(null)); [EOL]         assertTrue("should contain 10",ri.contains(10)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsBeforeRange() { [EOL]         assertFalse(intRange.isBeforeRange(null)); [EOL]          [EOL]         assertTrue(intRange.isBeforeRange(Range.between(5, 9))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 10))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 20))); [EOL]         assertFalse(intRange.isBeforeRange(Range.between(5, 25))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparator_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; [EOL]  [EOL]         final String stringToSplitOnNulls = "ab   de fg" ; [EOL]         final String[] splitOnNullExpectedResults = { "ab", "", "de" } ; [EOL]         final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null, 2 ) ; [EOL]         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ); [EOL]         } [EOL]  [EOL]         final String stringToSplitOnCharactersAndString = "ab   de fg" ; [EOL]         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, null, 2 ) ; [EOL]         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; [EOL]         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) { [EOL]             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ); [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringIntInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1, -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1, -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1, -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1, -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitByWholeSeparator_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".")); [EOL]         assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length); [EOL]          [EOL]         String str = "a b c"; [EOL]         String[] res = StringUtils.splitByWholeSeparator(str, null, 2); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.splitByWholeSeparator(str, null, 2); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.splitByWholeSeparator(str, null, 2); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.splitByWholeSeparator(str, "b", 2); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.splitByWholeSeparator(str, "b", 2); [EOL]         assertEquals(6, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; [EOL]  [EOL]         assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; [EOL]  [EOL]         // test whitespace [EOL]         String input = "ab   de fg" ; [EOL]         String[] expected = new String[] { "ab", "", "", "de", "fg" } ; [EOL]  [EOL]         String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter singlechar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "", "2", "", "3", "", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual.length ; i+= 1 ) { [EOL]             assertEquals( expected[i], actual[i] ); [EOL]         } [EOL]  [EOL]         // test delimiter multichar [EOL]         input = "1::2:::3::::4"; [EOL]         expected = new String[] { "1", "2", ":3", "", "4" }; [EOL]  [EOL]         actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; [EOL]         assertEquals( expected.length, actual.length ) ; [EOL]         for ( int i = 0 ; i < actual
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testAddInitializerNullName() { [EOL]         initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue("Wrong success flag", res.isSuccessful()); [EOL]         assertEquals("Wrong number of child initializers", 1, res.getChildInitializers().size()); [EOL]         assertSame("Wrong child initializers", child1, res.getChildInitializers().iterator().next()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_13, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_14, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_15, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_16, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_17, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_14, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.getResultObject(CHILD_INIT)); [EOL]         assertTrue(res.isException(CHILD_INIT)); [EOL]         assertFalse(res.isException(null)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testGetResultObject() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]          [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res [EOL]         assertEquals(6, res.getResultObjects().size()); [EOL]         assertTrue(res.getResultObjects().contains(CHILD_INIT)); [EOL]         assertTrue(res.getResultObjects().contains(CHILD_INIT)); [EOL]         assertTrue(res.getResultObjects().contains(CHILD_INIT)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.ex); [EOL]         assertTrue(res.isException(CHILD_INIT)); [EOL]         assertFalse(res.isException(null)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); [EOL]         child.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(child, res.getInitializer(CHILD_INIT)); [EOL]         assertSame(child, res.getResultObject(CHILD_INIT)); [EOL]         assertTrue(res.getException(CHILD_INIT) instanceof Exception); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testGetException() { [EOL]         exception = null; [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         try { [EOL]             initializer.getException(CHILD_INIT); [EOL]             fail("ConcurrentException not thrown!"); [EOL]         } catch (final ConcurrentException cex) { [EOL]             assertEquals("Wrong cause", exception, cex.getCause()); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get an exception. In this case [EOL]      * the method should do nothing. We can only test that no exception is [EOL]      * thrown. [EOL]      */ [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeUnsuccessful() { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]  [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertFalse("Wrong success flag", res.isSuccessful()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsException() { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializer.isException() is false. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue("Wrong success flag", res.isSuccessful()); [EOL]         assertEquals("Wrong number of child initializers", 1, res.getChildInitializers().size()); [EOL]         assertSame("Wrong child initializers", child1, res.getChildInitializers().iterator().next()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testAddInitializerNullName() { [EOL]         initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); [EOL]         child.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue("Wrong success flag", res.isSuccessful()); [EOL]         assertEquals("Wrong number of child initializers", 1, res.getChildInitializers().size()); [EOL]         assertSame("Wrong child initializers", child, res.getChildInitializers().iterator().next()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the child initializers() method. [EOL]      */ [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testAddInitializerNullName() { [EOL]         initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeUnsuccessful() { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_13, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_14, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT_15, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTaskCount() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]  [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get(); [EOL]         assertEquals(5, res.getTaskCount()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeResults() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testAddInitializerNullName() { [EOL]         initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeResults() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]          [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res [EOL]         assertEquals(5, res.getResultCount()); [EOL]         assertEquals(6, res2.getResultCount()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.ex); [EOL]         assertTrue(res.isException(CHILD_INIT)); [EOL]         assertFalse(res.isException(null)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeResults() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]          [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res [EOL]         assertEquals(5, res.getResultCount()); [EOL]         assertEquals(6, res2.getResultCount()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetException() { [EOL]         final String ex = "Test Exception"; [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]  [EOL]         final ConcurrentException cex = initializer.getException(CHILD_INIT); [EOL]         assertTrue("Wrong cause", cex instanceof ConcurrentException); [EOL]         assertEquals("Wrong cause", ex, cex.getCause()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeResults() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeResults() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); [EOL]         child.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue("Wrong success flag", res.isSuccessful()); [EOL]         assertEquals("Wrong number of initializers", 1, res.getInitializers().size()); [EOL]         assertSame("Wrong child", child, res.getInitializers().iterator().next()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers fail. [EOL]      */ [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeResults() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeResults() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeResults() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.ex); [EOL]         assertFalse(res.isSuccessful()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializers can be combined in multiple child initializers. [EOL]      */ [EOL]
@Test [EOL]     public void testGetTaskCount() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]  [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get(); [EOL]         assertEquals(5, res.getTaskCount()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.getResultObject(CHILD_INIT)); [EOL]         assertTrue(res.isException(CHILD_INIT)); [EOL]         assertFalse(res.isException(null)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testAddInitializerNullName() { [EOL]         initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsException() { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 1, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(CHILD_INIT + 13, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializer.isException() is false. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.ex); [EOL]         assertTrue(res.isException(CHILD_INIT)); [EOL]         assertFalse(res.isException(null)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testInitialize() throws ConcurrentException { [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_2, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_3, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_4, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_5, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_6, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_7, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_8, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_9, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_10, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_11, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_12, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_13, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_14, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_15, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_16, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_17, new ChildBackgroundInitializer()); [EOL]         initializer.addInitializer(INIT_14, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testAddInitializerNullName() { [EOL]         initializer.addInitializer(null, new ChildBackgroundInitializer()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetException() { [EOL]         exception = null; [EOL]         initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); [EOL]         initializer.getException(CHILD_INIT); [EOL]         assertTrue("Wrong success flag", initializer.isException(CHILD_INIT)); [EOL]         assertTrue("Wrong exception flag", initializer.isException(CHILD_INIT + 1)); [EOL]         assertTrue("Wrong exception flag", initializer.isException(CHILD_INIT + 2)); [EOL]         assertTrue("Wrong exception flag", initializer.isException(CHILD_INIT + 3)); [EOL]         exception = null; [EOL]         initializer.addInitializer(INIT_2, new ChildBackgroundInitializer()); [EOL]         initializer.getException(CHILD_INIT); [EOL]         assertTrue("Wrong exception flag", initializer.isException(CHILD_INIT + 1)); [EOL]         assertTrue("Wrong exception flag", initializer.isException(CHILD_INIT + 2)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests whether MultiBackgroundInitializer.getException() invocations always return true. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.ex); [EOL]         assertTrue(res.isException(CHILD_INIT)); [EOL]         assertFalse(res.isException(null)); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testInitializeEx() throws ConcurrentException { [EOL]         final ChildBackgroundInitializer child1 = new ChildBackgroundInitializer(); [EOL]         child1.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child1); [EOL]         initializer.start(); [EOL]         final ChildBackgroundInitializer child2 = new ChildBackgroundInitializer(); [EOL]         child2.ex = new Exception(); [EOL]         initializer.addInitializer(CHILD_INIT, child2); [EOL]         initializer.start(); [EOL]         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer [EOL]                 .get(); [EOL]         assertTrue(res.isSuccessful()); [EOL]         assertSame(res.getResultObject(CHILD_INIT), child1.ex); [EOL]         assertFalse(res.isSuccessful()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the behavior of the initializer if one of the child initializers [EOL]      * throws a runtime exception. [EOL]      */ [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(5, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(5, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementBooleanArray() { [EOL]         boolean[] array; [EOL]         array = ArrayUtils.removeElement((boolean[]) null, true); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true}, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false, true}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(5, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(5, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfWithStartIndex() { [EOL]         final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); [EOL]         assertEquals(0, ArrayUtils.indexOf(array, "0", 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, "1", 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "3", -1)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, null, 5)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 5)); [EOL]          [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, null, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, "0", 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementBooleanArray() { [EOL]         boolean[] array; [EOL]         array = ArrayUtils.removeElement((boolean[]) null, true); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true}, true); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true); [EOL]         assertTrue(Arrays.equals(new boolean[] {false, true}, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringInt() { [EOL]         final StrBuilder sb = new StrBuilder ("hello goodbye"); [EOL]         assertEquals ("goodbye", sb.substring(6)); [EOL]         assertEquals ("hello goodbye".substring(6), sb.substring(6)); [EOL]         assertEquals ("hello goodbye", sb.substring(0)); [EOL]         assertEquals ("hello goodbye".substring(0), sb.substring(0)); [EOL]         try { [EOL]             sb.substring(-1); [EOL]             fail (); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]          [EOL]         try { [EOL]             sb.substring(15); [EOL]             fail (); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]      [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringInt() { [EOL]         final StrBuilder sb = new StrBuilder ("hello goodbye"); [EOL]         assertEquals ("goodbye", sb.substring(6)); [EOL]         assertEquals ("hello goodbye".substring(6), sb.substring(6)); [EOL]         assertEquals ("hello goodbye", sb.substring(0)); [EOL]         assertEquals ("hello goodbye".substring(0), sb.substring(0)); [EOL]         try { [EOL]             sb.substring(-1); [EOL]             fail (); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]          [EOL]         try { [EOL]             sb.substring(15); [EOL]             fail (); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]      [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAsWriter() throws Exception { [EOL]         final StrBuilder sb = new StrBuilder("base"); [EOL]         final Writer writer = sb.asWriter(); [EOL]          [EOL]         writer.write('l'); [EOL]         assertEquals("basel", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'i', 'n'}); [EOL]         assertEquals("baselin", sb.toString()); [EOL]          [EOL]         writer.write(new char[] {'n', 'e', 'r'}, 1, 2); [EOL]         assertEquals("baseliner", sb.toString()); [EOL]          [EOL]         writer.write(" rout"); [EOL]         assertEquals("baseliner rout", sb.toString()); [EOL]          [EOL]         writer.write("ping that server", 1, 3); [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.flush();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.close();  // no effect [EOL]         assertEquals("baseliner routing", sb.toString()); [EOL]          [EOL]         writer.write(" hi");  // works after close [EOL]         assertEquals("baseliner routing hi", sb.toString()); [EOL]          [EOL]         sb.setLength(4);  // mix and match [EOL]         writer.write('d'); [EOL]         assertEquals("based", sb.toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubstringInt() { [EOL]         final StrBuilder sb = new StrBuilder ("hello goodbye"); [EOL]         assertEquals ("goodbye", sb.substring(6)); [EOL]         assertEquals ("hello goodbye".substring(6), sb.substring(6)); [EOL]         assertEquals ("hello goodbye", sb.substring(0)); [EOL]         assertEquals ("hello goodbye".substring(0), sb.substring(0)); [EOL]         try { [EOL]             sb.substring(-1); [EOL]             fail (); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]          [EOL]         try { [EOL]             sb.substring(15); [EOL]             fail (); [EOL]         } catch (final IndexOutOfBoundsException e) {} [EOL]      [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testAppendln_StringBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder_int_int() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]                 count[0]++; [EOL]                 return super.append(str, startIndex, length); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo"), 0, 3); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent explicit cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent explicit cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent explicit cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testPrimitivesToWrappersNull() { [EOL] //        assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers(null)); // generates warning [EOL]         assertNull("Wrong result for null input", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent explicit cast [EOL]          [EOL]         // Other possible casts for null [EOL]         assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); [EOL]         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} [EOL]         assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.clear(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]  [
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testFormatPeriod() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatPeriod(0, 0, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatPeriod(0, 1, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatPeriod(0, 2, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatPeriod(0, 3, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatPeriod(0, 4, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatPeriod(0, 5, "0:00:00.5", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatPeriod(0, 6, "0:00:00.6", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatPeriod(0, 7, "0:00:00.7", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatPeriod(14, 15, "0:00:00.8", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatPeriod(14, 15, "0:00:00.9", false, TimeZone.getDefault())); [EOL]          [EOL]         assertEquals("0:00:00.999", DurationFormatUtils.formatPeriod(0, 0, "0:00:00.999", false, TimeZone.getDefault())); [EOL]         assertEquals("0
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -1, -1, -1, -1); [EOL
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -1, -1, -1, -1); [EOL
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(); [EOL]         cal5.clear(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1,
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -1, -1, -1, -1); [EOL
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.clear(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]  [
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -1, -1, -1, -1); [EOL
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -1, -1, -1, -1); [EOL
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -1, -1, -1, -1); [EOL
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -
@Test [EOL]     public void testFormatPeriod() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatPeriod(time, 0, "0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatPeriod(time, 1, "0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatPeriod(time, 2, "0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatPeriod(time, 3, "0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatPeriod(time, 4, "0:00:00.4")); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatPeriod(time, 5, "0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatPeriod(time, 6, "0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatPeriod(time, 7, "0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatPeriod(time, 8, "0:00:00.8")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -1, -1, -1, -1); [EOL
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal7.set
@Test [EOL]     public void testLexx() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatPeriod(0, 0, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatPeriod(0, 1, "0:00:00.001", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatPeriod(0, 2, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatPeriod(0, 3, "0:00:00.001", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatPeriod(0, 4, "0:00:00.001", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatPeriod(0, 5, "0:00:00.5", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatPeriod(0, 6, "0:00:00.6", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatPeriod(0, 7, "0:00:00.7", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatPeriod(12, 14, "0:00:00.8", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatPeriod(14, 15, "0:00:00.9", false, TimeZone.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar calendar = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         calendar.clear(); [EOL]         calendar.set(2003, 1, 10, 15, 33, 20); [EOL]         calendar.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 9, 00, 00); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final long startMillis = calendar.getTimeInMillis(); [EOL]         final long endMillis = calendar.getTimeInMillis(); [EOL]  [EOL]         assertEquals("2/10/15", DurationFormatUtils.formatPeriod(startMillis, endMillis, "yyyyMdH", false, NEW_YORK)); [EOL]  [EOL]         assertEquals("2003/02/10T15:33:20", DurationFormatUtils.formatPeriod(startMillis, endMillis, "yyyyMdH", false, NEW_YORK)); [EOL]  [EOL]         assertEquals("2003/02/10T15:33:20", DurationFormatUtils.formatPeriod(startMillis, endMillis, "yyyyMdH", false, NEW_YORK)); [EOL]          [EOL]         assertEquals("2003/02/10T15:33:20", DurationFormatUtils.formatPeriod(startMillis, startMillis, "yyyyMdH", false, NEW_YORK)); [EOL]         assertEquals("2003/02/10T15:33:20", DurationFormatUtils.formatPeriod(startMillis, endMillis, "yyyyMdH", false, NEW_
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.clear(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final long startMillis = cal.getTime().getTime(); [EOL]  [
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]  [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8.set(-1, -1, -1, -1, -1); [EOL
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final Calendar cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         cal7.set(Calendar.MILLISECOND, 0
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]          [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5 = Calendar.getInstance(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal8 = Calendar.getInstance(); [EOL]         cal8.set(2003, 1, 10, 9, 00, 00); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal5.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7 = Calendar.getInstance(NEW_YORK, Locale.US); [EOL]         cal7.set(2003, 1, 10, 9, 00, 00); [EOL]         cal7.set(Calendar.MILLISECOND, 989); [EOL]
@Test [EOL]     public void testLexx() { [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatPeriod(0, 0, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatPeriod(0, 1, "0:00:00.001", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatPeriod(0, 2, "0:00:00.000", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatPeriod(0, 3, "0:00:00.001", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatPeriod(0, 4, "0:00:00.001", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatPeriod(0, 5, "0:00:00.5", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatPeriod(0, 6, "0:00:00.6", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatPeriod(0, 7, "0:00:00.7", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatPeriod(12, 14, "0:00:00.8", false, TimeZone.getDefault())); [EOL]         assertEquals("0:00:00.9", DurationFormatUtils.formatPeriod(14, 15, "0:00:00.9", false, TimeZone.getDefault())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2003, 1, 10, 15, 33, 20); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.clear(); [EOL]         cal2.set(2003, 1, 10, 9, 00, 00); [EOL]         cal2.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal3 = Calendar.getInstance(); [EOL]         cal3.clear(); [EOL]         cal3.set(2003, 1, 10, 9, 00, 00); [EOL]         cal3.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal4 = Calendar.getInstance(); [EOL]         cal4.clear(); [EOL]         cal4.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Calendar cal5 = Calendar.getInstance(); [EOL]         cal5.clear(); [EOL]         cal5.set(2003, 1, 10, 9, 00, 00); [EOL]         cal4.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal5.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal6 = Calendar.getInstance(); [EOL]         cal6.clear(); [EOL]         cal6.set(2003, 1, 10, 9, 00, 00); [EOL]         cal6.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         cal7 = Calendar.getInstance(); [EOL]         cal7.set(2003, 1, 10, 9, 00,
@Test [EOL]     public void testReplaceFirst_StrMatcher_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceFirst((StrMatcher) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst((StrMatcher) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceFirst(StrMatcher.charMatcher('x'), "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('a'), "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('d'), null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.stringMatcher("cb"), "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx"); [EOL]         assertEquals("xbxb", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceFirst(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL
@Test [EOL]     public void testCharSetMatcher_String() { [EOL]         final StrMatcher matcher = StrMatcher.charSetMatcher("ace"); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 4)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher("")); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceFirst_StrMatcher_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceFirst((StrMatcher) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst((StrMatcher) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceFirst(StrMatcher.charMatcher('x'), "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('a'), "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('d'), null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.stringMatcher("cb"), "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx"); [EOL]         assertEquals("xbxb", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceFirst(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL
@Test [EOL]     public void testCharSetMatcher_String() { [EOL]         final StrMatcher matcher = StrMatcher.charSetMatcher("ace"); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 4)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher("")); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCharSetMatcher_String() { [EOL]         final StrMatcher matcher = StrMatcher.charSetMatcher("ace"); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 4)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher("")); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCharSetMatcher_String() { [EOL]         final StrMatcher matcher = StrMatcher.charSetMatcher("ace"); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 4)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher("")); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testCharSetMatcher_String() { [EOL]         final StrMatcher matcher = StrMatcher.charSetMatcher("ace"); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 0)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 1)); [EOL]         assertEquals(1, matcher.isMatch(BUFFER2, 2)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 3)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 4)); [EOL]         assertEquals(0, matcher.isMatch(BUFFER2, 5)); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher("")); [EOL]         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceFirst_StrMatcher_String() { [EOL]         StrBuilder sb = new StrBuilder("abcbccba"); [EOL]         sb.replaceFirst((StrMatcher) null, null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst((StrMatcher) null, "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.noneMatcher(), null); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]          [EOL]         sb.replaceFirst(StrMatcher.charMatcher('x'), "y"); [EOL]         assertEquals("abcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('a'), "d"); [EOL]         assertEquals("dbcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('d'), null); [EOL]         assertEquals("bcbccba", sb.toString()); [EOL]         sb.replaceFirst(StrMatcher.stringMatcher("cb"), "-"); [EOL]         assertEquals("b-ccba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("abcba"); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx"); [EOL]         assertEquals("axbxcba", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("bb"); [EOL]         sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx"); [EOL]         assertEquals("xbxb", sb.toString()); [EOL]          [EOL]         sb = new StrBuilder("A1-A2A3-A4"); [EOL]         sb.replaceFirst(A_NUMBER_MATCHER, "***"); [EOL]         assertEquals("***-A2A3-A4", sb.toString()); [EOL]     } [EOL]  [EOL
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneIfPossible() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.cloneIfPossible( (String) null ) ); [EOL]         assertNull(ObjectUtils.cloneIfPossible( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1, minComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1, maxComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1, maxComparable ) ); [EOL]  [EOL]         assertNull( ObjectUtils.cloneIfPossible((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneIfPossible() { [EOL]         final Calendar calendar = Calendar.getInstance(); [EOL]         final Date nonNullComparable1 = calendar.getTime(); [EOL]         final Date nonNullComparable2 = calendar.getTime(); [EOL]         final String[] nullAray = null; [EOL]          [EOL]         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); [EOL]         final Date minComparable = calendar.getTime(); [EOL]          [EOL]         assertNotSame( nonNullComparable1, nonNullComparable2 ); [EOL]          [EOL]         assertNull(ObjectUtils.cloneIfPossible( (String) null ) ); [EOL]         assertNull(ObjectUtils.cloneIfPossible( nullAray ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( null, nonNullComparable1 ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1, null ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( nonNullComparable1, minComparable ) ); [EOL]         assertSame( nonNullComparable1, ObjectUtils.cloneIfPossible( null, minComparable ) ); [EOL]  [EOL]         assertNull( ObjectUtils.cloneIfPossible((String)null, (String)null) ); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testClone() { [EOL]         final CloneFailedException ex = new CloneFailedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE)); [EOL]         assertEquals(TEST_MESSAGE_2, ex.getMessage()); [EOL]         assertSame(TEST_MESSAGE_2, ex.getCause()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testCloneOfStringArray() { [EOL]         assertTrue(Arrays.deepEquals( [EOL]             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. [EOL]      */ [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloat() { [EOL]         assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((float) 3.2).toString()); [EOL]         assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (float) 3.2).toString()); [EOL]         assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (float) 3.2).append("b", (float) 4.3).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloat() { [EOL]         assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((float) 3.2).toString()); [EOL]         assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (float) 3.2).toString()); [EOL]         assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (float) 3.2).append("b", (float) 4.3).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionBooleanArray() { [EOL]         boolean[] array = new boolean[] { true, false, false }; [EOL]         final String baseStr = this.toBaseString(array); [EOL]         assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); [EOL]         array = null; [EOL]         assertReflectionArray("<null>", array); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArray() { [EOL]         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testStripStart_StringString() { [EOL]         // null stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, null)); [EOL]         assertEquals("", StringUtils.stripStart("", null)); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("  ", StringUtils.stripStart("  ", "")); [EOL]          [EOL]         // " " stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, " ")); [EOL]         assertEquals("", StringUtils.stripStart("", " ")); [EOL]         assertEquals("", StringUtils.stripStart("  ", " ")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " ")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("ab", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" strip
@Test [EOL]     public void testStrip_StringString() { [EOL]         assertEquals(null, StringUtils.strip(null, null)); [EOL]         assertEquals("", StringUtils.strip("", null)); [EOL]         assertEquals("", StringUtils.strip("", "")); [EOL]         assertEquals("", StringUtils.strip("        ", null)); [EOL]         assertEquals("abc  ", StringUtils.strip("  abc  ", null)); [EOL]          [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null)); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]          [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testStripToNull() { [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals("", StringUtils.stripToNull("")); [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]          [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]         assertEquals("abc", StringUtils.stripToNull("  abc  ")); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testStripStart_StringString() { [EOL]         // null stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, null)); [EOL]         assertEquals("", StringUtils.stripStart("", null)); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("  ", StringUtils.stripStart("  ", "")); [EOL]          [EOL]         // " " stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, " ")); [EOL]         assertEquals("", StringUtils.stripStart("", " ")); [EOL]         assertEquals("", StringUtils.stripStart("  ", " ")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " ")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("ab", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" strip
@Test [EOL]     public void testStrip_StringString() { [EOL]         assertEquals(null, StringUtils.strip(null, null)); [EOL]         assertEquals("", StringUtils.strip("", null)); [EOL]         assertEquals("", StringUtils.strip("", "")); [EOL]         assertEquals("", StringUtils.strip("        ", null)); [EOL]         assertEquals("abc  ", StringUtils.strip("  abc  ", null)); [EOL]          [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null)); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]          [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testStrip_StringString() { [EOL]         assertEquals(null, StringUtils.strip(null, null)); [EOL]         assertEquals("", StringUtils.strip("", null)); [EOL]         assertEquals("", StringUtils.strip("", "")); [EOL]         assertEquals(null, StringUtils.strip(null, "ab")); [EOL]          [EOL]         assertEquals("", StringUtils.strip("", "")); [EOL]         assertEquals("", StringUtils.strip("", "ab")); [EOL]         assertEquals("", StringUtils.strip("", "ab")); [EOL]          [EOL]         assertEquals("", StringUtils.strip("        ", "ab")); [EOL]         assertEquals("  abc", StringUtils.strip("  abc  ", "ab")); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null) ); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "") ); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testStripStart_StringString() { [EOL]         // null stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, null)); [EOL]         assertEquals("", StringUtils.stripStart("", null)); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("  ", StringUtils.stripStart("  ", "")); [EOL]          [EOL]         // " " stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, " ")); [EOL]         assertEquals("", StringUtils.stripStart("", " ")); [EOL]         assertEquals("", StringUtils.stripStart("  ", " ")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " ")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("ab", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" strip
@Test [EOL]     public void testStripStart_StringString() { [EOL]         // null stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, null)); [EOL]         assertEquals("", StringUtils.stripStart("", null)); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("  ", StringUtils.stripStart("  ", "")); [EOL]          [EOL]         // " " stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, " ")); [EOL]         assertEquals("", StringUtils.stripStart("", " ")); [EOL]         assertEquals("", StringUtils.stripStart("  ", " ")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " ")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab"
@Test [EOL]     public void testStripEnd_StringString() { [EOL]         // null stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, null)); [EOL]         assertEquals("", StringUtils.stripEnd("", null)); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", null)); [EOL]          [EOL]         // "" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals("", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.strip
@Test [EOL]     public void testStripToNull() { [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals("", StringUtils.stripToNull("")); [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]          [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]         assertEquals("abc", StringUtils.stripToNull("  abc  ")); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]          [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals("", StringUtils.stripToNull("")); [EOL]         assertEquals("abc", StringUtils.stripToNull("  abc  ")); [EOL]          [EOL]         assertEquals("i am a robot", StringUtils.stripToNull("I am a robot")); [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals("i am a machine", StringUtils.stripToNull("i am a robot")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testStripEnd_StringString() { [EOL]         // null stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, null)); [EOL]         assertEquals("", StringUtils.stripEnd("", null)); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("", StringUtils.stripEnd("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripEnd(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]          [EOL]         // " " stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, " ")); [EOL]         assertEquals("", StringUtils.stripEnd("", " ")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", " ")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals("", StringUtils.stripEnd
@Test [EOL]     public void testStripEnd_StringString() { [EOL]         // null stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, null)); [EOL]         assertEquals("", StringUtils.stripEnd("", null)); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", null)); [EOL]          [EOL]         // "" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals("", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.strip
@Test [EOL]     public void testStrip_StringString() { [EOL]         assertEquals(null, StringUtils.strip(null, null)); [EOL]         assertEquals("", StringUtils.strip("", null)); [EOL]         assertEquals("", StringUtils.strip("", "")); [EOL]         assertEquals("", StringUtils.strip("        ", null)); [EOL]         assertEquals("abc  ", StringUtils.strip("  abc  ", null)); [EOL]          [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null)); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", null)); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]          [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testStripStart_StringString() { [EOL]         // null stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, null)); [EOL]         assertEquals("", StringUtils.stripStart("", null)); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("  ", StringUtils.stripStart("  ", "")); [EOL]          [EOL]         // " " stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, " ")); [EOL]         assertEquals("", StringUtils.stripStart("", " ")); [EOL]         assertEquals("", StringUtils.stripStart("  ", " ")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " ")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("ab", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" strip
@Test [EOL]     public void testStripEnd_StringString() { [EOL]         // null stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, null)); [EOL]         assertEquals("", StringUtils.stripEnd("", null)); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", null)); [EOL]          [EOL]         // "" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals("", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.strip
@Test [EOL]     public void testStripEnd_StringString() { [EOL]         // null stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, null)); [EOL]         assertEquals("", StringUtils.stripEnd("", null)); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("", StringUtils.stripEnd("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripEnd(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]          [EOL]         // " " stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, " ")); [EOL]         assertEquals("", StringUtils.stripEnd("", " ")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", " ")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab ")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab ")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab ")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals("", StringUtils.
@Test [EOL]     public void testStrip_StringString() { [EOL]         assertEquals(null, StringUtils.strip(null, null)); [EOL]         assertEquals("", StringUtils.strip("", null)); [EOL]         assertEquals("", StringUtils.strip("", "")); [EOL]         assertEquals("", StringUtils.strip("        ", null)); [EOL]         assertEquals("abc  ", StringUtils.strip("  abc  ", null)); [EOL]          [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null)); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]          [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip("  abc  ", "")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testStripStart_StringString() { [EOL]         // null stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, null)); [EOL]         assertEquals("", StringUtils.stripStart("", null)); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("  ", StringUtils.stripStart("  ", "")); [EOL]          [EOL]         // " " stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, " ")); [EOL]         assertEquals("", StringUtils.stripStart("", " ")); [EOL]         assertEquals("", StringUtils.stripStart("  ", " ")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " ")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("ab", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" strip
@Test [EOL]     public void testStripEnd_StringString() { [EOL]         // null stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, null)); [EOL]         assertEquals("", StringUtils.stripEnd("", null)); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("", StringUtils.stripEnd("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripEnd(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]          [EOL]         // " " stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, " ")); [EOL]         assertEquals("", StringUtils.stripEnd("", " ")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", " ")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals("", StringUtils.stripEnd
@Test [EOL]     public void testStripStart_StringString() { [EOL]         // null stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, null)); [EOL]         assertEquals("", StringUtils.stripStart("", null)); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("", StringUtils.stripStart("", "")); [EOL]         assertEquals("  ", StringUtils.stripStart("  ", "")); [EOL]          [EOL]         // " " stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, " ")); [EOL]         assertEquals("", StringUtils.stripStart("", " ")); [EOL]         assertEquals("", StringUtils.stripStart("  ", " ")); [EOL]         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " ")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("ab", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripStart [EOL]         assertEquals(null, StringUtils.stripStart(null, "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]         assertEquals("", StringUtils.stripStart("  abc  ", "ab")); [EOL]          [EOL]         // "ab" strip
@Test [EOL]     public void testStripToNull() { [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals("", StringUtils.stripToNull("")); [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]          [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]         assertEquals("abc", StringUtils.stripToNull("  abc  ")); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripToNull("  abc  ")); [EOL]          [EOL]         assertEquals(StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]         assertEquals(StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testStripEnd_StringString() { [EOL]         // null stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, null)); [EOL]         assertEquals("", StringUtils.stripEnd("", null)); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("", StringUtils.stripEnd("  ", null)); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripEnd(StringUtilsTest.WHITESPACE, "")); [EOL]          [EOL]         // "" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]          [EOL]         // " " stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, " ")); [EOL]         assertEquals("", StringUtils.stripEnd("", " ")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", " ")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab")); [EOL]         assertEquals("ab", StringUtils.stripEnd("ab", "ab ")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals("", StringUtils.
@Test [EOL]     public void testStripEnd_StringString() { [EOL]         // null stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, null)); [EOL]         assertEquals("", StringUtils.stripEnd("", null)); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", null)); [EOL]          [EOL]         // "" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "")); [EOL]         assertEquals("", StringUtils.stripEnd("", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("  ", StringUtils.stripEnd("  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("  abc  ", "ab")); [EOL]         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab")); [EOL]          [EOL]         // "ab" stripEnd [EOL]         assertEquals(null, StringUtils.stripEnd(null, "ab")); [EOL]         assertEquals("", StringUtils.stripEnd("  abc
@Test [EOL]     public void testStripToNull() { [EOL]         assertEquals(null, StringUtils.stripToNull(null)); [EOL]         assertEquals("", StringUtils.stripToNull("")); [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]          [EOL]         assertEquals("", StringUtils.stripToNull("  ")); [EOL]         assertEquals("abc", StringUtils.stripToNull("  abc  ")); [EOL]         assertEquals(StringUtilsTest.NON_WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]          [EOL]         assertEquals(StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.stripToNull("  abc  ")); [EOL]         assertEquals(StringUtilsTest.WHITESPACE,  [EOL]             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.WHITESPACE + StringUtilsTest.WHITESPACE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAppendIfMissingIgnoreCase() { [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("xyzabc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.appendIfMissingIgnoreCase("XYZabc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("
@Test [EOL]     public void testAppendIfMissingIgnoreCase() { [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("xyzabc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.appendIfMissingIgnoreCase("XYZabc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("
@Test [EOL]     public void testAppendIfMissingIgnoreCase() { [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("xyzabc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.appendIfMissingIgnoreCase("XYZabc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("
@Test [EOL]     public void testAppendIfMissingIgnoreCase() { [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("xyzabc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.appendIfMissingIgnoreCase("XYZabc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("
@Test [EOL]     public void testAppendIfMissingIgnoreCase() { [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("xyzabc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.appendIfMissingIgnoreCase("XYZabc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("
@Test [EOL]     public void testAppendIfMissingIgnoreCase() { [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("xyzabc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.appendIfMissingIgnoreCase("XYZabc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("
@Test [EOL]     public void testAppendIfMissingIgnoreCase() { [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.appendIfMissingIgnoreCase("xyzabc","xyz")); [EOL]         assertEquals("appendIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.appendIfMissingIgnoreCase("XYZabc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissingIgnoreCase(null,null null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); [EOL]         assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("appendIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.appendIfMissingIgnoreCase("mnoabc","xyz","mno")); [EOL]         assertEquals("
@Test [EOL]     public void testAppendIfMissing() { [EOL]         assertEquals(null, StringUtils.appendIfMissing(null, null)); [EOL]         assertEquals("", StringUtils.appendIfMissing("", null)); [EOL]         assertEquals("", StringUtils.appendIfMissing("", "")); [EOL]         assertEquals("abc", StringUtils.appendIfMissing("abc", null)); [EOL]         assertEquals("abc", StringUtils.appendIfMissing("abc", "")); [EOL]         assertEquals("abc", StringUtils.appendIfMissing("abc", "a")); [EOL]         assertEquals("abc", StringUtils.appendIfMissing("abc", "b")); [EOL]         assertEquals("abc", StringUtils.appendIfMissing("abc", "c")); [EOL]         assertEquals("abc", StringUtils.appendIfMissing("abc", "d")); [EOL]         assertEquals("abcba", StringUtils.appendIfMissing("abcba", "b")); [EOL]         assertEquals("abcba", StringUtils.appendIfMissing("abcba", "c")); [EOL]         assertEquals("abcba", StringUtils.appendIfMissing("abcba", "d")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAppendIfMissing() { [EOL]         assertEquals("appendIfMissing(null,null)", null, StringUtils.appendIfMissing(null,null)); [EOL]         assertEquals("appendIfMissing(abc,null)", "abc", StringUtils.appendIfMissing("abc",null)); [EOL]         assertEquals("appendIfMissing(\"\",xyz)", "xyz", StringUtils.appendIfMissing("","xyz")); [EOL]         assertEquals("appendIfMissing(abc,xyz)", "abcxyz", StringUtils.appendIfMissing("abc","xyz")); [EOL]  [EOL]         assertEquals("appendIfMissing(abc,xyz)", "abcxyz", StringUtils.appendIfMissing("abc","xyz")); [EOL]         assertEquals("appendIfMissing(abc,xyz,null)", "abcxyz", StringUtils.appendIfMissing("abc","xyz",(CharSequence[]) null)); [EOL]         assertEquals("appendIfMissing(abc,xyz,{null})","abcxyz", StringUtils.appendIfMissing("abc","xyz",new CharSequence[0])); [EOL]         assertEquals("appendIfMissing(abc,xyz,\"\")","abcxyz", StringUtils.appendIfMissing("abc","xyz","")); [EOL]         assertEquals("appendIfMissing(abc,xyz,mno)","xyzmno", StringUtils.appendIfMissing("abc","xyz","mno")); [EOL]  [EOL]         assertEquals("appendIfMissing(mno,xyz,mno)", "mno", StringUtils.appendIfMissing("mno","xyz","mno")); [EOL]         assertEquals("appendIfMissing(mno,xyz,mno)", "mno", StringUtils.appendIfMissing("mno","xyz","mno")); [EOL]         assertEquals("appendIfMissing(mno,xyz,mno)", "mno", StringUtils.appendIfMissing("mno","xyz","mno")); [EOL]  [EOL]         assertEquals("appendIfMissing(mno,xyz,mno)", "mno", StringUtils.appendIfMissing("mno","xyz","mno")); [EOL]         assertEquals("appendIfMissing(mno,xyz,mno)", "
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (false, true)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (false, true)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (false, true)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (false, true)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (false, true)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (false, true)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testOr_object_validInput_2items() { [EOL]         assertTrue( [EOL]             "True result for (true, true)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "True result for (false, false)", [EOL]             ! BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]  [EOL]         assertTrue( [EOL]             "False result for (true, false)", [EOL]             BooleanUtils [EOL]                 .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) [EOL]                 .booleanValue()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 00:00:00.000"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13, 45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]                 dateParser.parse("November 13, 45:01.231"), [EOL]                 DateUtils.round(date3, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assert
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 0, 2002"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 1, 2001"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 16, 2002"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 18, 2001"), [EOL]                 DateUtils.round(date2, Calendar.DATE)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 0, 2002"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 1, 2001"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 16, 2002"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 18, 2001"), [EOL]                 DateUtils.round(date2, Calendar.DATE)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [
@Test [EOL]     public void testAddSeconds() throws Exception { [EOL]         final Date base = new Date(MILLIS_TEST); [EOL]         Date result = DateUtils.addSeconds(base, 0); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, 1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, -1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAddSeconds() throws Exception { [EOL]         final Date base = new Date(MILLIS_TEST); [EOL]         Date result = DateUtils.addSeconds(base, 0); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, 1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, -1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 00:00:00.000"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13, 45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]                 dateParser.parse("November 13, 45:01.231"), [EOL]                 DateUtils.round(date3, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assert
@Test [EOL]     public void testAddSeconds() throws Exception { [EOL]         final Date base = new Date(MILLIS_TEST); [EOL]         Date result = DateUtils.addSeconds(base, 0); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, 1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, -1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 0, 2002"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 1, 2001"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 16, 2002"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 18, 2001"), [EOL]                 DateUtils.round(date2, Calendar.DATE)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]
@Test [EOL]     public void testAddSeconds() throws Exception { [EOL]         final Date base = new Date(MILLIS_TEST); [EOL]         Date result = DateUtils.addSeconds(base, 0); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, 1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, -1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("February 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 0, 2002"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 16, 2002"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 18, 2002"), [EOL]                 DateUtils.
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 00:00:00.000"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13, 45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]                 dateParser.parse("November 13, 45:01.231"), [EOL]                 DateUtils.round(date3, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assert
@Test [EOL]     public void testAddMilliseconds() throws Exception { [EOL]         final Date base = new Date(MILLIS_TEST); [EOL]         Date result = DateUtils.addMilliseconds(base, 0); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addMilliseconds(base, 1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addMilliseconds(base, -1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 0, 2002"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 1, 2001"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 16, 2002"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 18, 2001"), [EOL]                 DateUtils.round(date2, Calendar.DATE)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 00:00:00.000"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13, 45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]                 dateParser.parse("November 13, 45:01.231"), [EOL]                 DateUtils.round(date3, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assert
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 00:00:00.000"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13, 45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]                 dateParser.parse("November 13, 45:01.231"), [EOL]                 DateUtils.round(date3, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assert
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testAddSeconds() throws Exception { [EOL]         final Date base = new Date(MILLIS_TEST); [EOL]         Date result = DateUtils.addSeconds(base, 0); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, 1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, -1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 0, 2002"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 1, 2001"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 16, 2002"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [EOL]                 dateParser.parse("November 18, 2001"), [EOL]                 DateUtils.round(date2, Calendar.DATE)); [EOL]          [EOL]         assertEquals("round date-3 failed", [EOL]
@Test [EOL]     public void testRound() throws Exception { [EOL]         // tests for public static Date round(Date date, int field) [EOL]         assertEquals("round year-1 failed", [EOL]                 dateParser.parse("January 1, 2002 14:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.YEAR)); [EOL]         assertEquals("round year-2 failed", [EOL]                 dateParser.parse("January 1, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.YEAR)); [EOL]         assertEquals("round month-1 failed", [EOL]                 dateParser.parse("February 1, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date1, Calendar.MONTH)); [EOL]         assertEquals("round month-2 failed", [EOL]                 dateParser.parse("December 1, 2001 13:45:01.231"), [EOL]                 DateUtils.round(date2, Calendar.MONTH)); [EOL]         assertEquals("round semimonth-0 failed", [EOL]                 dateParser.parse("February 16, 2002 00:00:00.000"), [EOL]                 DateUtils.round(date0, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, DateUtils.SEMI_MONTH)); [EOL]         assertEquals("round semimonth-2 failed", [EOL]                 dateParser.parse("November 16, 2002 13:45:01.231"), [EOL]                 DateUtils.round(date2, DateUtils.SEMI_MONTH)); [EOL]          [EOL]         assertEquals("round date-1 failed", [EOL]                 dateParser.parse("February 13:45:01.231"), [EOL]                 DateUtils.round(date1, Calendar.DATE)); [EOL]         assertEquals("round date-2 failed", [
@Test [EOL]     public void testAddSeconds() throws Exception { [EOL]         final Date base = new Date(MILLIS_TEST); [EOL]         Date result = DateUtils.addSeconds(base, 0); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, 1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]          [EOL]         result = DateUtils.addSeconds(base, -1); [EOL]         assertNotSame(base, result); [EOL]         assertDate(base, 2000, 6, 5, 4, 3, 2, 1); [EOL]         assertDate(result, 2000, 6, 5, 4, 3, 2, 1); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayLong() { [EOL]         final long[] nullArray = null; [EOL]         final long[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final long[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final long[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final long[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     @SuppressWarnings("cast") [EOL]     public void testRemoveElementFloatArray() { [EOL]         float[] array; [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); [EOL]         assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); [EOL]         assertEquals(Float.TYPE, array.getClass().getComponentType());
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testBinaryToHexDigitMsb0_4bits() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true,
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a",
@Test [EOL]     public void testShortArray() { [EOL]         short[] array = new short[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] array = new short[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] array = new short[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShort() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((short) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (short) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (short) 3).append("b", (short) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] array = new short[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShort() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((short) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (short) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (short) 3).append("b", (short) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] array = new short[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] array = new short[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectBuild() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).build()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).build()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).build()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).build()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).build()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, null).build()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).build()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).build()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).build()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).build()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).build()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).build()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a
@Test [EOL]     public void testShortArray() { [EOL]         short[] array = new short[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testShortArray() { [EOL]         short[] array = new short[] {1, 2, -3, 4}; [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]         array = null; [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode()); [EOL]         final int[] obj = new int[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInt() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode()); [EOL]         assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((int) 123).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode()); [EOL]         final int[] obj = new int[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInt() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(0).toHashCode()); [EOL]         assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append(123).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode()); [EOL]         final int[] obj = new int[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInt() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode()); [EOL]         assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((int) 123).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode()); [EOL]         final int[] obj = new int[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode()); [EOL]         final int[] obj = new int[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testJoin_ArrayOfInts() { [EOL]         assertEquals(null, StringUtils.join((int[]) null, ',')); [EOL]         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); [EOL]         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testToStringBuilder() { [EOL]         final StrBuilder sb = new StrBuilder(); [EOL]         assertEquals("", sb.toStringBuilder().toString()); [EOL]          [EOL]         sb.append("HelloWorld"); [EOL]         assertEquals("HelloWorld", sb.toStringBuilder().toString()); [EOL]          [EOL]         sb.append(""); [EOL]         assertEquals("HelloWorld", sb.toStringBuilder().toString()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(new String[]{}, (String[]) null)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY,
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIndexOfByteWithStartIndex() { [EOL]         byte[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         array = new byte[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, (byte) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveAllBooleanArray() { [EOL]         boolean[] array; [EOL]         array = ArrayUtils.removeAll(new boolean[] { true }, new BitSet(0)); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new boolean[] { true, false }, new BitSet(1)); [EOL]         assertTrue(Arrays.equals(new boolean[] { false }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new boolean[] { true, false, true }, new BitSet(2)); [EOL]         assertTrue(Arrays.equals(new boolean[] { true, false }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new boolean[] { true, true, false }, new BitSet(3)); [EOL]         assertTrue(Arrays.equals(new boolean[] { false, true }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new boolean[] { true, false, true }, new BitSet(1)); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new boolean[] { true, false, true }, new BitSet(2)); [EOL]         assertTrue(Arrays.equals(new boolean[] { true, false }, array)); [EOL]         assertEquals(Boolean.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIndexOfByteWithStartIndex() { [EOL]         byte[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         array = new byte[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, (byte) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(new String[]{}, (String[]) null)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY,
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(new String[]{}, (String[]) null)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY,
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testIndexOfByteWithStartIndex() { [EOL]         byte[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         array = new byte[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, (byte) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, new BitSet()); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, new BitSet()); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, new BitSet()); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, new BitSet()); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, new BitSet()); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, new BitSet()); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 1 }, new BitSet()); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 2, 3, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3,
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testIndexOfByteWithStartIndex() { [EOL]         byte[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         array = new byte[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, (byte) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIndexOfByteWithStartIndex() { [EOL]         byte[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         array = new byte[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, (byte) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIndexOfByteWithStartIndex() { [EOL]         byte[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         array = new byte[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, (byte) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, new BitSet(0)); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, new BitSet(1)); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, new BitSet(1)); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, new BitSet(1)); [EOL]         assertTrue(Arrays.equals(new long[] { 2, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, new BitSet(1)); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, new BitSet(1)); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 1 }, new BitSet(1)); [EOL]         assertTrue(Arrays.equals(new long[] { 3, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElements
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 1); [EOL]         assertTrue(Arrays.equals(new long[] { 4, 5 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4 }, 2); [EOL]         assertTrue(Arrays.equals(
@Test [EOL]     public void testAddObjectArrayToObjectArray() { [EOL]         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); [EOL]         Object[] newArray; [EOL]         final String[] stringArray1 = new String[]{"a", "b", "c"}; [EOL]         final String[] stringArray2 = new String[]{"1", "2", "3"}; [EOL]         newArray = ArrayUtils.addAll(stringArray1, (String[]) null); [EOL]         assertNotSame(stringArray1, newArray); [EOL]         assertTrue(Arrays.equals(stringArray1, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, stringArray2); [EOL]         assertNotSame(stringArray2, newArray); [EOL]         assertTrue(Arrays.equals(stringArray2, newArray)); [EOL]         assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(stringArray1, stringArray2); [EOL]         assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); [EOL]         assertTrue(Arrays.equals(new String[]{}, (String[]) null)); [EOL]         assertEquals(String.class, newArray.getClass().getComponentType()); [EOL]         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY,
@Test [EOL]     public void testIndexOfByteWithStartIndex() { [EOL]         byte[] array = null; [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         array = new byte[] { 0, 1, 2, 3, 0 }; [EOL]         assertEquals(0, ArrayUtils.indexOf(array, (byte) 0, 2)); [EOL]         assertEquals(1, ArrayUtils.indexOf(array, (byte) 1, 2)); [EOL]         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, 2)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 3, -1)); [EOL]         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99)); [EOL]         assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRemoveAllLongArray() { [EOL]         long[] array; [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 2 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]  [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 1 }, 2); [EOL]         assertTrue(Arrays.equals(new long[] { 3, 1 }, array)); [EOL]         assertEquals(Long.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testGetAccessibleMethod() throws Exception { [EOL]         assertEquals("()", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, (Class<?>[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); [EOL]         assertEquals("()", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, (Class<?>[]) null).toString()); [EOL]         assertEquals("(String)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, "").toString()); [EOL]         assertEquals("(Object)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, new Object()).toString()); [EOL]         assertEquals("(Object)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, Boolean.TRUE).toString()); [EOL]         assertEquals("(Integer)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, NumberUtils.INTEGER_ONE).toString()); [EOL]         assertEquals("(double)", ConstructorUtils.getAccessibleConstructor( [EOL]                 TestBean.class, new Object[] { NumberUtils.DOUBLE_ONE }, [EOL]                 new Class[] { Double.TYPE }).toString()); [EOL]  [EOL]         try { [EOL]             ConstructorUtils.getAccessibleConstructor(TestBean.class, [EOL]                     NumberUtils.BYTE_ONE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]         try { [EOL]             ConstructorUtils.getAccessibleConstructor(TestBean.class, [EOL]                     Boolean.FALSE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]         try { [EOL]             ConstructorUtils.getAccessibleConstructor(TestBean.class, [EOL]                     Boolean.TRUE); [EOL]             fail("should throw NoSuchMethodException"); [EOL]         } catch (final NoSuchMethodException e) { [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetAccessibleMethod() throws Exception { [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, [EOL]                 ArrayUtils.EMPTY_CLASS_ARRAY); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(String.class), singletonArray(String.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Object.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Boolean.class), singletonArray(Object.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Short.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Short.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Character.class), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Integer.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Integer.class), singletonArray(Integer.class)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Integer.TYPE), singletonArray(Integer.TYPE)); [EOL]         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, [EOL]                 singletonArray(Integer.class), singletonArray(Integer.class)); [EOL]         expectMatchingAccessibleConstructor
@Test [EOL]     public void testAddValuePrimitive() { [EOL]         final MutableFloat mutNum = new MutableFloat(1); [EOL]         mutNum.add(1); [EOL]          [EOL]         assertEquals(2.0f, mutNum.floatValue(), 0.01f); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvert() { [EOL]         Fraction f = null; [EOL]          [EOL]         f = Fraction.getFraction(50, 75); [EOL]         f = f.invert(); [EOL]         assertEquals(75, f.getNumerator()); [EOL]         assertEquals(50, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(4, 3); [EOL]         f = f.invert(); [EOL]         assertEquals(3, f.getNumerator()); [EOL]         assertEquals(4, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(-15, 47); [EOL]         f = f.invert(); [EOL]         assertEquals(-47, f.getNumerator()); [EOL]         assertEquals(15, f.getDenominator()); [EOL]          [EOL]         f = Fraction.getFraction(0, 3); [EOL]         try { [EOL]             f = f.invert(); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         // large values [EOL]         f = Fraction.getFraction(Integer.MIN_VALUE, 1); [EOL]         try { [EOL]             f = f.invert(); [EOL]             fail("expecting ArithmeticException"); [EOL]         } catch (final ArithmeticException ex) {} [EOL]  [EOL]         f = Fraction.getFraction(Integer.MAX_VALUE, 1); [EOL]         f = f.invert(); [EOL]         assertEquals(1, f.getNumerator()); [EOL]         assertEquals(Integer.MAX_VALUE, f.getDenominator()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testGetContextValues() { [EOL]         exceptionContext.addContextValue("test2", "different value"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test1") == null); [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("some value")); [EOL]         assertTrue(exceptionContext.getFirstContextValue("crap") == null); [EOL]  [EOL]         exceptionContext.setContextValue("test2", "another"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("another")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContextValues() { [EOL]         exceptionContext.addContextValue("test2", "different value"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test1") == null); [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("some value")); [EOL]         assertTrue(exceptionContext.getFirstContextValue("crap") == null); [EOL]  [EOL]         exceptionContext.setContextValue("test2", "another"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("another")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContextValues() { [EOL]         exceptionContext.addContextValue("test2", "different value"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test1") == null); [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("some value")); [EOL]         assertTrue(exceptionContext.getFirstContextValue("crap") == null); [EOL]  [EOL]         exceptionContext.setContextValue("test2", "another"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("another")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContextValues() { [EOL]         exceptionContext.addContextValue("test2", "different value"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test1") == null); [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("some value")); [EOL]         assertTrue(exceptionContext.getFirstContextValue("crap") == null); [EOL]  [EOL]         exceptionContext.setContextValue("test2", "another"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("another")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContextValues() { [EOL]         exceptionContext.addContextValue("test2", "different value"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test1") == null); [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("some value")); [EOL]         assertTrue(exceptionContext.getFirstContextValue("crap") == null); [EOL]  [EOL]         exceptionContext.setContextValue("test2", "another"); [EOL]  [EOL]         assertTrue(exceptionContext.getFirstContextValue("test2").equals("another")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testNullExceptionPassing() { [EOL]         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) [EOL]         .addContextValue("test1", null) [EOL]         .addContextValue("test2", "some value") [EOL]         .addContextValue("test Date", new Date()) [EOL]         .addContextValue("test Nbr", Integer.valueOf(5)) [EOL]         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); [EOL]          [EOL]         final String message = exceptionContext.getMessage(); [EOL]         assertTrue(message != null); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testLang645() { [EOL]         final Locale locale = new Locale("sv", "SE"); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); [EOL]  [EOL]         assertEquals("fredag, week 53", fdf.format(d)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testLang645() { [EOL]         final Locale locale = new Locale("sv", "SE"); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); [EOL]  [EOL]         assertEquals("fredag, week 53", fdf.format(d)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testLang645() { [EOL]         final Locale locale = new Locale("sv", "SE"); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); [EOL]  [EOL]         assertEquals("fredag, week 53", fdf.format(d)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testLang645() { [EOL]         final Locale locale = new Locale("sv", "SE"); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); [EOL]  [EOL]         assertEquals("fredag, week 53", fdf.format(d)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testLang645() { [EOL]         final Locale locale = new Locale("sv", "SE"); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); [EOL]  [EOL]         assertEquals("fredag, week 53", fdf.format(d)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testLang645() { [EOL]         final Locale locale = new Locale("sv", "SE"); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); [EOL]  [EOL]         assertEquals("fredag, week 53", fdf.format(d)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testParseDate() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     @SuppressWarnings("cast") // cast is not really needed, keep for consistency [EOL]     public void testBoolean() { [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFloatArrayAsObject() { [EOL]         final float[] obj = new float[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = 5.4f; [EOL]         final int h1 = Float.floatToIntBits(5.4f); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = 6.3f; [EOL]         final int h2 = Float.floatToIntBits(6.3f); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     @SuppressWarnings("cast") // cast is not really needed, keep for consistency [EOL]     public void testBoolean() { [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode()); [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByteArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode()); [EOL]         final byte[] obj = new byte[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = (byte) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = (byte) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode()); [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode()); [EOL]         final double[] obj = new double[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5.4d; [EOL]         final long l1 = Double.doubleToLongBits(5.4d); [EOL]         final int h1 = (int) (l1 ^ l1 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6.3d; [EOL]         final long l2 = Double.doubleToLongBits(6.3d); [EOL]         final int h2 = (int) (l2 ^ l2 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode()); [EOL]         final double[] obj = new double[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5.4d; [EOL]         final long l1 = Double.doubleToLongBits(5.4d); [EOL]         final int h1 = (int) (l1 ^ l1 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6.3d; [EOL]         final long l2 = Double.doubleToLongBits(6.3d); [EOL]         final int h2 = (int) (l2 ^ l2 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArrayAsObject() { [EOL]         final double[] obj = new double[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = 5.4d; [EOL]         final long l1 = Double.doubleToLongBits(5.4d); [EOL]         final int h1 = (int) (l1 ^ l1 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = 6.3d; [EOL]         final long l2 = Double.doubleToLongBits(6.3d); [EOL]         final int h2 = (int) (l2 ^ l2 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode()); [EOL]         final double[] obj = new double[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5.4d; [EOL]         final long l1 = Double.doubleToLongBits(5.4d); [EOL]         final int h1 = (int) (l1 ^ l1 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6.3d; [EOL]         final long l2 = Double.doubleToLongBits(6.3d); [EOL]         final int h2 = (int) (l2 ^ l2 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayAsObject() { [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode()); [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode()); [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode()); [EOL]         final double[] obj = new double[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5.4d; [EOL]         final long l1 = Double.doubleToLongBits(5.4d); [EOL]         final int h1 = (int) (l1 ^ l1 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6.3d; [EOL]         final long l2 = Double.doubleToLongBits(6.3d); [EOL]         final int h2 = (int) (l2 ^ l2 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     @SuppressWarnings("cast") // cast is not really needed, keep for consistency [EOL]     public void testBoolean() { [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode()); [EOL]         final boolean[] obj = new boolean[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = true; [EOL]         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = false; [EOL]         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDoubleArray() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode()); [EOL]         final double[] obj = new double[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[0] = 5.4d; [EOL]         final long l1 = Double.doubleToLongBits(5.4d); [EOL]         final int h1 = (int) (l1 ^ l1 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]         obj[1] = 6.3d; [EOL]         final long l2 = Double.doubleToLongBits(6.3d); [EOL]         final int h2 = (int) (l2 ^ l2 >> 32); [EOL]         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTrimToEmpty() { [EOL]         assertEquals("", StringUtils.trimToEmpty(null)); [EOL]         assertEquals("", StringUtils.trimToEmpty("")); [EOL]         assertEquals("", StringUtils.trimToEmpty("  \u000C  \t\t\u001F\n\n \u000B  ")); [EOL]         assertEquals("", StringUtils.trimToEmpty("")); [EOL]         assertEquals("", StringUtils.trimToEmpty(StringUtilsTest.TRIMMABLE)); [EOL]         assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToEmpty(StringUtilsTest.NON_TRIMMABLE)); [EOL]         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.trimToEmpty(StringUtilsTest.WHITESPACE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSecond() throws Exception { [EOL]         final int calendarField = Calendar.SECOND; [EOL]         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); [EOL]         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); [EOL]     } [EOL]      [EOL]     /** [EOL]      * Test DateUtils.truncate()-method with Calendar.SECOND [EOL]      *  [EOL]      * @throws Exception [EOL]      * @since 3.0 [EOL]      */ [EOL]
@Test [EOL]     public void testRoundSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("Febr
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (3) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (4) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testTruncateSemiMonth() throws Exception { [EOL]         final int calendarField = DateUtils.SEMI_MONTH; [EOL]         Date truncatedDate, lastTruncateDate; [EOL]          [EOL]         //month with 28 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 28 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 16, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         lastTruncateDate = dateTimeParser.parse("February 29, 2007 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 29 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (1) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); [EOL]  [EOL]         //month with 30 days (2) [EOL]         truncatedDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); [EOL]         baseTruncateTest(truncatedDate, lastTruncateDate
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRightPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.rightPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, null)); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, "")); [EOL]          [EOL]         final String str = StringUtils.rightPad("aaa", 10000, "ab");  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testRightPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.rightPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, null)); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, "")); [EOL]          [EOL]         final String str = StringUtils.rightPad("aaa", 10000, "ab");  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRightPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.rightPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, null)); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, "")); [EOL]          [EOL]         final String str = StringUtils.rightPad("aaa", 10000, "ab");  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals("    ", StringUtils.center("", 5, "")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, "ab")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, "ab")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, "ab")); [EOL]         assertEquals("    ", StringUtils.center("", 5, "ab")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, "ab")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, "ab")); [EOL]          [EOL]         final String str = StringUtils.center("aaa", 10000, "ab");  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRightPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.rightPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, null)); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, "")); [EOL]          [EOL]         final String str = StringUtils.rightPad("aaa", 10000, "ab");  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals("    ", StringUtils.center("", 5, "")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, "ab")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, "ab")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, "ab")); [EOL]         assertEquals("    ", StringUtils.center("", 5, "ab")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, "ab")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, "ab")); [EOL]          [EOL]         final String str = StringUtils.center("aaa", 10000, "ab");  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRightPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.rightPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.rightPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", -1, null)); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 0, "")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.rightPad("abc", 2, "")); [EOL]          [EOL]         final String str = StringUtils.rightPad("aaa", 10000, "ab");  // bigger than pad length [EOL]         assertEquals(10000, str.length()); [EOL]         assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, 5, null)); [EOL]         assertEquals(null, StringUtils.center(null, 5, "")); [EOL]         assertEquals(null, StringUtils.center(null, 5, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 5, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 2, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 3, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 5, " ")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 6, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 5, "b")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 6, "b")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 7, "x")); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLeftPad_StringIntString() { [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, null)); [EOL]         assertEquals(null, StringUtils.leftPad(null, 5, "")); [EOL]         assertEquals("     ", StringUtils.leftPad("", 5, "")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 7, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", -1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 0, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 1, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 2, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 3, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 4, " ")); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 5, null)); [EOL]         assertEquals("  abc", StringUtils.leftPad("abc", 6, "")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCenter_StringIntString() { [EOL]         assertEquals(null, StringUtils.center(null, -1, " ")); [EOL]         assertEquals(null, StringUtils.center(null, 4, " ")); [EOL]         assertEquals("    ", StringUtils.center("", 4, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 0, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", -1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 1, " ")); [EOL]         assertEquals("ab", StringUtils.center("ab", 4, null)); [EOL]         assertEquals("    ", StringUtils.center("", 4, "")); [EOL]         assertEquals(" ab ", StringUtils.center("ab", 4, "")); [EOL]         assertEquals("abcd", StringUtils.center("abcd", 2, " ")); [EOL]         assertEquals(" a  ", StringUtils.center("a", 4, " ")); [EOL]         assertEquals("  a  ", StringUtils.center("a", 5, " ")); [EOL]         assertEquals("xxaxx", StringUtils.center("a", 5, "x")); [EOL]     } [EOL]      [EOL]
@Test(timeout = 666000) [EOL]     public void testGetShortClassName() throws Exception { [EOL]         assertEquals("Test", AnnotationUtils.getShortClassName(field1.getAnnotation(Test.class))); [EOL]         assertEquals("TestAnnotation1", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation1.class))); [EOL]         assertEquals("TestAnnotation2", AnnotationUtils.getShortClassName(field2.getAnnotation(TestAnnotation2.class))); [EOL]         assertEquals("TestAnnotation3", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation3.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testToString() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testToString").getAnnotation(Test.class); [EOL]         assertEquals(test.toString(), AnnotationUtils.toString(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.toString(), AnnotationUtils.toString(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.toString(), AnnotationUtils.toString(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testToString() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testToString").getAnnotation(Test.class); [EOL]         assertEquals(test.toString(), AnnotationUtils.toString(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.toString(), AnnotationUtils.toString(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.toString(), AnnotationUtils.toString(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testToString() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testToString").getAnnotation(Test.class); [EOL]         assertEquals(test.toString(), AnnotationUtils.toString(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.toString(), AnnotationUtils.toString(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.toString(), AnnotationUtils.toString(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testGetShortClassName() throws Exception { [EOL]         assertEquals("Test", AnnotationUtils.getShortClassName(field1.getAnnotation(Test.class))); [EOL]         assertEquals("TestAnnotation1", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation1.class))); [EOL]         assertEquals("TestAnnotation2", AnnotationUtils.getShortClassName(field2.getAnnotation(TestAnnotation2.class))); [EOL]         assertEquals("TestAnnotation3", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation3.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testGetShortClassName() throws Exception { [EOL]         assertEquals("Test", AnnotationUtils.getShortClassName(field1.getAnnotation(Test.class))); [EOL]         assertEquals("TestAnnotation1", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation1.class))); [EOL]         assertEquals("TestAnnotation2", AnnotationUtils.getShortClassName(field2.getAnnotation(TestAnnotation2.class))); [EOL]         assertEquals("TestAnnotation3", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation3.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testGetShortClassName() throws Exception { [EOL]         assertEquals("Test", AnnotationUtils.getShortClassName(field1.getAnnotation(Test.class))); [EOL]         assertEquals("TestAnnotation1", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation1.class))); [EOL]         assertEquals("TestAnnotation2", AnnotationUtils.getShortClassName(field2.getAnnotation(TestAnnotation2.class))); [EOL]         assertEquals("TestAnnotation3", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation3.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testGetShortClassName() throws Exception { [EOL]         assertEquals("Test", AnnotationUtils.getShortClassName(field1.getAnnotation(Test.class))); [EOL]         assertEquals("TestAnnotation1", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation1.class))); [EOL]         assertEquals("TestAnnotation2", AnnotationUtils.getShortClassName(field2.getAnnotation(TestAnnotation2.class))); [EOL]         assertEquals("TestAnnotation3", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation3.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testToString() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testToString").getAnnotation(Test.class); [EOL]         assertEquals(test.toString(), AnnotationUtils.toString(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.toString(), AnnotationUtils.toString(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.toString(), AnnotationUtils.toString(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testGetShortClassName() throws Exception { [EOL]         assertEquals("Test", AnnotationUtils.getShortClassName(field1.getAnnotation(Test.class))); [EOL]         assertEquals("TestAnnotation1", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation1.class))); [EOL]         assertEquals("TestAnnotation2", AnnotationUtils.getShortClassName(field2.getAnnotation(TestAnnotation2.class))); [EOL]         assertEquals("TestAnnotation3", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation3.class))); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testToString() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testToString").getAnnotation(Test.class); [EOL]         assertEquals(test.toString(), AnnotationUtils.toString(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.toString(), AnnotationUtils.toString(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.toString(), AnnotationUtils.toString(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testToString() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testToString").getAnnotation(Test.class); [EOL]         assertEquals(test.toString(), AnnotationUtils.toString(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.toString(), AnnotationUtils.toString(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.toString(), AnnotationUtils.toString(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testHashCode() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); [EOL]         assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testToString() throws Exception { [EOL]         final Test test = getClass().getDeclaredMethod("testToString").getAnnotation(Test.class); [EOL]         assertEquals(test.toString(), AnnotationUtils.toString(test)); [EOL]         final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation1.toString(), AnnotationUtils.toString(testAnnotation1)); [EOL]         final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); [EOL]         assertEquals(testAnnotation3.toString(), AnnotationUtils.toString(testAnnotation3)); [EOL]     } [EOL]  [EOL]
@Test(timeout = 666000) [EOL]     public void testGetShortClassName() throws Exception { [EOL]         assertEquals("Test", AnnotationUtils.getShortClassName(field1.getAnnotation(Test.class))); [EOL]         assertEquals("TestAnnotation1", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation1.class))); [EOL]         assertEquals("TestAnnotation2", AnnotationUtils.getShortClassName(field2.getAnnotation(TestAnnotation2.class))); [EOL]         assertEquals("TestAnnotation3", AnnotationUtils.getShortClassName(field3.getAnnotation(TestAnnotation3.class))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Object[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadFieldForceAccess() throws Exception { [EOL]         Field field = FieldUtils.getField(FieldUtilsTest.class, "s"); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "b"); [EOL]         assertEquals(Baz.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "i"); [EOL]         assertEquals(I0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "d"); [EOL]         assertEquals(D0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "s", true); [EOL]         assertEquals(S1.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "b", true); [EOL]         assertEquals(Baz.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "i", true); [EOL]         assertEquals(I0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "d", true); [EOL]         assertEquals(D0, FieldUtils.readField(field, publicChild, false)); [EOL]         try { [EOL]             FieldUtils.readField(field, publicChild, false); [EOL]             fail("a null field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readField((Field) null, publicChild, true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [
@Test [EOL]     public void testReadFieldForceAccess() throws Exception { [EOL]         Field field = FieldUtils.getField(FieldUtilsTest.class, "s"); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "b"); [EOL]         assertEquals(Baz.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "i"); [EOL]         assertEquals(I0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "d"); [EOL]         assertEquals(D0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "s", true); [EOL]         assertEquals(S1.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "b", true); [EOL]         assertEquals(Baz.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "i", true); [EOL]         assertEquals(I0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "d", true); [EOL]         assertEquals(D0, FieldUtils.readField(field, publicChild, false)); [EOL]         try { [EOL]             FieldUtils.readField(field, publicChild, false); [EOL]             fail("a null field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readField((Field) null, publicChild, true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [
@Test [EOL]     public void testReadFieldForceAccess() throws Exception { [EOL]         Field field = FieldUtils.getField(publicChild, "s"); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(field, publicChild, false); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, false)); [EOL]         field = FieldUtils.getField(field, publicChild, true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, false)); [EOL]         field = FieldUtils.getField(field, publicChild, true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(field, publicChild, false); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, false)); [EOL]          [EOL]         field = FieldUtils.getField(field, publicChild, true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         try { [EOL]             FieldUtils.readField(field, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readField((Field) null, (Field) null, true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE", true)); [EOL]         assertEquals("child", FieldUtils.readStaticField(PublicChild.class, "VALUE", true)); [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "VALUE", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(PublicChild.class, "VALUE", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true
@Test [EOL]     public void testReadDeclaredField() throws Exception { [EOL]         FieldUtils.readDeclaredField(publicChild, null); [EOL]         assertEquals(null, FieldUtils.readDeclaredField(publicChild, "s")); [EOL]         FieldUtils.readDeclaredField(publicChild, "b"); [EOL]         FieldUtils.readDeclaredField(publicChild, "i"); [EOL]         FieldUtils.readDeclaredField(publicChild, "d"); [EOL]         FieldUtils.readDeclaredField(publicChild, "d"); [EOL]         FieldUtils.readDeclaredField(publicChild, "e"); [EOL]         FieldUtils.readDeclaredField(publicChild, "f"); [EOL]         FieldUtils.readDeclaredField(publicChild, "g"); [EOL]         FieldUtils.readDeclaredField(publicChild, "h"); [EOL]         FieldUtils.readDeclaredField(publicChild, "i"); [EOL]         FieldUtils.readDeclaredField(publicChild, "j"); [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, "s"); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, "b"); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, "i"); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, "d"); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]
@Test [EOL]     public void testReadFieldForceAccess() throws Exception { [EOL]         Field field = FieldUtils.getField(FieldUtilsTest.class, "s"); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "b"); [EOL]         assertEquals(Baz.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "i"); [EOL]         assertEquals(I0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "d"); [EOL]         assertEquals(D0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "s", true); [EOL]         assertEquals(S1.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "b", true); [EOL]         assertEquals(Baz.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "i", true); [EOL]         assertEquals(I0, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(FieldUtilsTest.class, "d", true); [EOL]         assertEquals(D0, FieldUtils.readField(field, publicChild, false)); [EOL]         try { [EOL]             FieldUtils.readField(field, publicChild, false); [EOL]             fail("a null field should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readField((Field) null, publicChild, true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [
@Test [EOL]     public void testReadDeclaredField() throws Exception { [EOL]         FieldUtils.readDeclaredField(publicChild, null); [EOL]         assertEquals(null, FieldUtils.readDeclaredField(publicChild, "s")); [EOL]         FieldUtils.readDeclaredField(publicChild, "b"); [EOL]         FieldUtils.readDeclaredField(publicChild, "i"); [EOL]         FieldUtils.readDeclaredField(publicChild, "d"); [EOL]         FieldUtils.readDeclaredField(publicChild, "d"); [EOL]         FieldUtils.readDeclaredField(publicChild, "e"); [EOL]         FieldUtils.readDeclaredField(publicChild, "f"); [EOL]         FieldUtils.readDeclaredField(publicChild, "g"); [EOL]         FieldUtils.readDeclaredField(publicChild, "h"); [EOL]         FieldUtils.readDeclaredField(publicChild, "i"); [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, "j"); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, "k"); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, "k"); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readDeclaredField(publicChild, "l"); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]
@Test [EOL]     public void testInvokeMethod() throws Exception { [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 (Object[]) null)); [EOL]         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",  [EOL]                 (Object[]) null, (Class<?>[]) null)); [EOL]         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 "")); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 new Object())); [EOL]         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 Boolean.TRUE)); [EOL]         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.INTEGER_ONE)); [EOL]         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.BYTE_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.LONG_ONE)); [EOL]         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", [EOL]                 NumberUtils.DOUBLE_ONE)); [EOL]     } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL]     public void testReadStaticFieldAccessIllegalArgumentException1() throws Exception { [EOL]         FieldUtils.readStaticField(null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"), true)); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.class, "VALUE", true), true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.class, "VALUE", false)); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]
@Test [EOL]     public void testGetFieldForceAccess() { [EOL]         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); [EOL]         assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); [EOL]         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); [EOL]         assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(null, "none")); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "none")); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "I")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "I")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(null, "none")); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "none")); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "I")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "I")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(null, "none")); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "none")); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "I")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "I")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils
@Test [EOL]     public void testReadFieldForceAccess() throws Exception { [EOL]         Field field = FieldUtils.getField(publicChild, "s"); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(field, publicChild, false); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, false)); [EOL]         field = FieldUtils.getField(field, publicChild, true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, false)); [EOL]         field = FieldUtils.getField(field, publicChild, true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         field = FieldUtils.getField(field, publicChild, false); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, false)); [EOL]          [EOL]         field = FieldUtils.getField(field, publicChild, true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readField(field, publicChild, true)); [EOL]         try { [EOL]             FieldUtils.readField(field, null, true); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             FieldUtils.readField((Field) null, (Field) null, true); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(null); [EOL]             fail("a null field name should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(null, "none")); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]  [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "none")); [EOL]             fail("a null target should cause an IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "I")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"))); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "I")); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         assertEquals(Foo.VALUE, FieldUtils
@Test [EOL]     public void testReadStaticField() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReadStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"), true)); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.class, "VALUE", true), true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.class, "VALUE", false)); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]
@Test [EOL]     public void testReadStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"), true)); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.class, "VALUE", true), true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.class, "VALUE", false)); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]
@Test [EOL]     public void testReadStaticFieldForceAccess() throws Exception { [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(FieldUtils.class, "VALUE"), true)); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.class, "VALUE", true), true); [EOL]         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.class, "VALUE", false)); [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", true); [EOL]             fail("expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // pass [EOL]         } [EOL]         try { [EOL]             FieldUtils.readStaticField(FieldUtils.class, "none", false); [EOL]
@Test [EOL]     public void testMaxShort() { [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 1", [EOL]             5, [EOL]             NumberUtils.max(new short[] { 5 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 2", [EOL]             9, [EOL]             NumberUtils.max(new short[] { 6, 9 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 5", [EOL]             10, [EOL]             NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMaxShort() { [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 1", [EOL]             5, [EOL]             NumberUtils.max(new short[] { 5 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 2", [EOL]             9, [EOL]             NumberUtils.max(new short[] { 6, 9 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 5", [EOL]             10, [EOL]             NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMaxShort() { [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 1", [EOL]             5, [EOL]             NumberUtils.max(new short[] { 5 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 2", [EOL]             9, [EOL]             NumberUtils.max(new short[] { 6, 9 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 5", [EOL]             10, [EOL]             NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMaxShort() { [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 1", [EOL]             5, [EOL]             NumberUtils.max(new short[] { 5 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 2", [EOL]             9, [EOL]             NumberUtils.max(new short[] { 6, 9 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 5", [EOL]             10, [EOL]             NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMaxShort() { [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 1", [EOL]             5, [EOL]             NumberUtils.max(new short[] { 5 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 2", [EOL]             9, [EOL]             NumberUtils.max(new short[] { 6, 9 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 5", [EOL]             10, [EOL]             NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMaxShort() { [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 1", [EOL]             5, [EOL]             NumberUtils.max(new short[] { 5 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 2", [EOL]             9, [EOL]             NumberUtils.max(new short[] { 6, 9 })); [EOL]  [EOL]         assertEquals( [EOL]             "max(short[]) failed for array length 5", [EOL]             10, [EOL]             NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); [EOL]         assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormatDurationISO() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1; [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.1", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         try { [EOL]             DurationFormatUtils.formatDurationISO(time); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             DurationFormatUtils.formatDurationISO(time); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]         assertEquals(newToken("a"), lexx("a")); [EOL]         assertEquals(newToken("b"), lexx("b")); [EOL]         assertEquals(newToken("c"), lexx("c")); [EOL]         assertEquals(newToken("d"), lexx("d")); [EOL]         assertEquals(newToken("e"), lexx("e")); [EOL]         assertEquals(newToken("f"), lexx("f")); [EOL]         assertEquals(newToken("g"), lexx("g")); [EOL]         assertEquals(newToken("h"), lexx("h")); [EOL]         assertEquals(newToken("i"), lexx("i")); [EOL]         assertEquals(newToken("j"), lexx("j")); [EOL]         assertEquals(newToken("k"), lexx("k")); [EOL]         assertEquals(newToken("l"), lexx("l")); [EOL]         assertEquals(newToken("m"), lexx("m")); [EOL]         assertEquals(newToken("n"), lexx("n")); [EOL]         assertEquals(newToken("o"), lexx("o")); [EOL]         assertEquals(newToken("d"), lexx("d")); [EOL]         assertEquals(newToken("e"), lexx("e")); [EOL]         assertEquals(newToken("f", lexx("f")); [EOL]         assertEquals(newToken("g"), lexx("g")); [EOL]         assertEquals(newToken("h"), lexx("h")); [EOL]         assertEquals(newToken("i"), lexx("i")); [EOL]         assertEquals(newToken("j"), lexx("j")); [EOL]         assertEquals(newToken("k"), lexx("l")); [EOL]         assertEquals(newToken("m"), lexx("m"));
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final String formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("one"), new Token("two"), new Token("three"), new Token("four") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("one"), new Token("two"), new Token("three") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("x"), new Token("y"), new Token("z") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("one"), new Token("two"), new Token("three") }), lexx("a b c")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]         assertArrayEquals(new Token[] { new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("d") }, lexx("a b c")), lexx("a b c")); [EOL]  [EOL]         assertEquals(Arrays.asList(new Token[] { new Token("a"), new Token("b"), new Token("c"), new Token("
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLexx_String() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", " ", "de", " ", [EOL]                 "fg" }, lexx("ab de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", "   ", "de", " ", [EOL]                 "fg" }, lexx("ab   de fg"))); [EOL]  [EOL]         assertTrue(Arrays.equals(new String[] { "ab", ":", "cd", ":", [EOL]                 "ef" }, lexx("ab:cd:ef"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "number", "5" }, lexx("number5"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "B", "ar" }, lexx("fooBar"))); [EOL]         assertTrue(Arrays.equals(new String[] { "foo", "200", "B", "ar" }, lexx("foo200Bar"))); [EOL]          [EOL]         assertTrue(Arrays.equals(new String[] { "ASF", "Rules" }, lexx("ASFRules"))); [EOL]         assertTrue(Arrays.equals(new String[] { "ASFRules" }, lexx("ASFRules"))); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final String formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(d, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL]  [EOL]         formattedDate = DateFormatUtils.format(cal, new SimpleDateFormat("yyyyMMddHHmmssSSS")); [EOL]         assertEquals("2004-02-23T09:00:00", formattedDate); [EOL
@Test [EOL]     public void testLexx() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]         assertEquals(newToken("a"), lexx("a")); [EOL]         assertEquals(newToken("b"), lexx("b")); [EOL]         assertEquals(newToken("c"), lexx("c")); [EOL]         assertEquals(newToken("d"), lexx("d")); [EOL]         assertEquals(newToken("e"), lexx("e")); [EOL]         assertEquals(newToken("f"), lexx("f")); [EOL]         assertEquals(newToken("g"), lexx("g")); [EOL]         assertEquals(newToken("h"), lexx("h")); [EOL]         assertEquals(newToken("i"), lexx("i")); [EOL]         assertEquals(newToken("j"), lexx("j")); [EOL]         assertEquals(newToken("k"), lexx("k")); [EOL]         assertEquals(newToken("l"), lexx("l")); [EOL]         assertEquals(newToken("m"), lexx("m")); [EOL]         assertEquals(newToken("n"), lexx("n")); [EOL]         assertEquals(newToken("o"), lexx("o")); [EOL]         assertEquals(newToken("d"), lexx("d")); [EOL]         assertEquals(newToken("e"), lexx("e")); [EOL]         assertEquals(newToken("f", lexx("f")); [EOL]         assertEquals(newToken("g"), lexx("g")); [EOL]         assertEquals(newToken("h"), lexx("h")); [EOL]         assertEquals(newToken("i"), lexx("i")); [EOL]         assertEquals(newToken("j"), lexx("j")); [EOL]         assertEquals(newToken("k"), lexx("l")); [EOL]         assertEquals(newToken("m"), lexx("m"));
@Test [EOL]     public void testLexx() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDuration(time, "0:00:00.000")); [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDuration(time, "0:00:00.001")); [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDuration(time, "0:00:00.2")); [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDuration(time, "0:00:00.3")); [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDuration(time, "0:00:00.4")); [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDuration(time, "0:00:00.5")); [EOL]         assertEquals("0:00:00.6", DurationFormatUtils.formatDuration(time, "0:00:00.6")); [EOL]         assertEquals("0:00:00.7", DurationFormatUtils.formatDuration(time, "0:00:00.7")); [EOL]         assertEquals("0:00:00.8", DurationFormatUtils.formatDuration(time, "0:00:8.9")); [EOL]         assertEquals("0:00:00.10", DurationFormatUtils.formatDuration(time, "0:0:10.11")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:0:12.13")); [EOL]         assertEquals("0:0:0", DurationFormatUtils.formatDuration(time, "0:12.14")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.15")); [EOL]         assertEquals("0:0", DurationFormatUtils.formatDuration(time, "0:14.16")); [EOL]         assertEquals("0", DurationFormatUtils.formatDuration(time,
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 989); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testLexx() { [EOL]         // tests each constant [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.M, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.d, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); [EOL]  [EOL]         // tests the ISO8601-like [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.H, 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.m, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder(":"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.s, 2), [EOL]             new DurationFormatUtils.Token(new StringBuilder("."), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); [EOL]  [EOL]         // test the iso extended format [EOL]         assertArrayEquals(new DurationFormatUtils.Token[]{ [EOL]             new DurationFormatUtils.Token(new StringBuilder("P"), 1), [EOL]             new DurationFormatUtils.Token(DurationFormatUtils.y, 4), [EOL]             new DurationFormatUtils.Token(new StringBuilder("Y"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.Token(new StringBuilder("M"), 1), [EOL]             new DurationFormatUtils.
@Test [EOL]     public void testFormatPeriodISO() { [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final long millis = System.currentTimeMillis(); [EOL]  [EOL]         final Calendar cal2 = Calendar.getInstance(); [EOL]         cal2.set(2010, 0, 1, 12, 0, 0); [EOL]         cal2.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timeZone); [EOL]  [EOL]         assertEquals("2/3/04", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("Z"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(d)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03:00", fdf.format(cal2)); [EOL]  [EOL]         fdf = getInstance("-03:00"); [EOL]         assertEquals("-03
@Test [EOL]     public void testFormatDurationISO() { [EOL]         long time = 0; [EOL]         assertEquals("0:00:00.000", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1; [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.001", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.1", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.2", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.3", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.4", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         time = 1L; [EOL]         assertEquals("0:00:00.5", DurationFormatUtils.formatDurationISO(time)); [EOL]  [EOL]         try { [EOL]             DurationFormatUtils.formatDurationISO(time); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [EOL]         try { [EOL]             DurationFormatUtils.formatDurationISO(time); [EOL]             fail("Expected IllegalArgumentException"); [EOL]         } catch (final IllegalArgumentException e) { [EOL]             // expected [EOL]         } [
@Test [EOL]     public void testLexx() { [EOL]         assertArrayEquals(null, lexx(null)); [EOL]         assertEquals(0, lexx("").length); [EOL]         assertEquals(newToken("a"), lexx("a")); [EOL]         assertEquals(newToken("b"), lexx("b")); [EOL]         assertEquals(newToken("c"), lexx("c")); [EOL]         assertEquals(newToken("d"), lexx("d")); [EOL]         assertEquals(newToken("e"), lexx("e")); [EOL]         assertEquals(newToken("f"), lexx("f")); [EOL]         assertEquals(newToken("g"), lexx("g")); [EOL]         assertEquals(newToken("h"), lexx("h")); [EOL]         assertEquals(newToken("i"), lexx("i")); [EOL]         assertEquals(newToken("j"), lexx("j")); [EOL]         assertEquals(newToken("k"), lexx("k")); [EOL]         assertEquals(newToken("l"), lexx("l")); [EOL]         assertEquals(newToken("m"), lexx("m")); [EOL]         assertEquals(newToken("n"), lexx("n")); [EOL]         assertEquals(newToken("o"), lexx("o")); [EOL]         assertEquals(newToken("d"), lexx("d")); [EOL]         assertEquals(newToken("e"), lexx("e")); [EOL]         assertEquals(newToken("f", lexx("f")); [EOL]         assertEquals(newToken("g"), lexx("g")); [EOL]         assertEquals(newToken("h"), lexx("h")); [EOL]         assertEquals(newToken("i"), lexx("i")); [EOL]         assertEquals(newToken("j"), lexx("j")); [EOL]         assertEquals(newToken("k"), lexx("l")); [EOL]         assertEquals(newToken("m"), lexx("m"));
@Test [EOL]     public void testFormat() { [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.clear(); [EOL]         cal.set(2004, Calendar.JANUARY, 23, 18, 33, 05); [EOL]         cal.set(Calendar.MILLISECOND, 0); [EOL]  [EOL]         final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC")); [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime())); [EOL]  [EOL]         assertEquals("2004-02-23T09:00:00.000Z", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("Z"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]  [EOL]         format = getInstance("-0500"); [EOL]         assertEquals("-0500", format.format(cal.getTime().getTime())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray    = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray     = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray   = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testSubarrayInt() { [EOL]         final int[] nullArray = null; [EOL]         final int[] array = { 10, 11, 12, 13, 14, 15 }; [EOL]         final int[] leftSubarray  = { 10, 11, 12, 13 }; [EOL]         final int[] midSubarray   = { 11, 12, 13, 14 }; [EOL]         final int[] rightSubarray = { 12, 13, 14, 15 }; [EOL]  [EOL]  [EOL]         assertTrue("0 start, mid end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array, 0, 4))); [EOL]  [EOL]         assertTrue("0 start, length end", [EOL]             ArrayUtils.isEquals(array, [EOL]                 ArrayUtils.subarray(array, 0, array.length))); [EOL]  [EOL]         assertTrue("mid start, mid end", [EOL]             ArrayUtils.isEquals(midSubarray, [EOL]                 ArrayUtils.subarray(array, 1, 5))); [EOL]  [EOL]         assertTrue("mid start, length end", [EOL]             ArrayUtils.isEquals(rightSubarray, [EOL]                 ArrayUtils.subarray(array, 2, array.length))); [EOL]  [EOL]  [EOL]         assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); [EOL]  [EOL]         assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); [EOL]  [EOL]         assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 4, 2)); [EOL]  [EOL]         assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, [EOL]             ArrayUtils.subarray(array, 3, 3)); [EOL]  [EOL]         assertTrue("start undershoot, normal end", [EOL]             ArrayUtils.isEquals(leftSubarray, [EOL]                 ArrayUtils.subarray(array,
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 2)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringString() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "")); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b")); [EOL]         assertEquals(8, StringUtils.getLevenshteinDistance("aaapppp", "aa")); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a")); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b")); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa")); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa")); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb")); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb")); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b")); [EOL]  [EOL]         // distance less than distance [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b")); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb")); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb")); [EOL]  [EOL]         // distance equal to distance [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b")); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b")); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 2)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 2)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 2)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testGetLevenshteinDistance_StringStringInt() { [EOL]         // empty strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); [EOL]  [EOL]         // unequal strings, zero length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); [EOL]      [EOL]         // equal strings [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); [EOL]         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); [EOL]  [EOL]         // same length [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 0)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); [EOL]      [EOL]         // big stripe [EOL]         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); [EOL]  [EOL]         // distance less than threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); [EOL]      [EOL]         // distance equal to threshold [EOL]         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); [EOL]         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); [EOL]  [EOL]         // distance greater than threshold [EOL]         assertEquals(-1, StringUtils.getLevenshteinDistance("
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElement((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2, 1}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementByteArray() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElement((byte[]) null, 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1}, 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2}, 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, 1); [EOL]         assertTrue(Arrays.equals(new byte[] {1, 1}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementByte() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElement((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2, 1}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementByte() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElement((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2, 1}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementByte() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElement((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2, 1}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testRemoveElementByte() { [EOL]         byte[] array; [EOL]         array = ArrayUtils.removeElement((byte[]) null, (byte) 1); [EOL]         assertNull(array); [EOL]         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]         array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1); [EOL]         assertTrue(Arrays.equals(new byte[] {2, 1}, array)); [EOL]         assertEquals(Byte.TYPE, array.getClass().getComponentType()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testAppendln_StringBuilder() { [EOL]         final int[] count = new int[2]; [EOL]         final StrBuilder sb = new StrBuilder() { [EOL]             @Override [EOL]             public StrBuilder append(final StringBuilder str) { [EOL]                 count[0]++; [EOL]                 return super.append(str); [EOL]             } [EOL]             @Override [EOL]             public StrBuilder appendNewLine() { [EOL]                 count[1]++; [EOL]                 return super.appendNewLine(); [EOL]             } [EOL]         }; [EOL]         sb.appendln(new StringBuilder("foo")); [EOL]         assertEquals("foo" + SEP, sb.toString()); [EOL]         assertEquals(1, count[0]); [EOL]         assertEquals(1, count[1]); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12-03:00", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12-03
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDateTimeISO(){ [EOL]         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); [EOL]         final Calendar cal = Calendar.getInstance(timeZone); [EOL]         cal.set(2002,1,23,9,11,12); [EOL]         String text = DateFormatUtils.format(cal.getTime(),  [EOL]                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]          [EOL]         text = DateFormatUtils.format(cal.getTime().getTime(),  [EOL]                       DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); [EOL]         assertEquals("2002-02-23T09:11:12", text); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testLang645() { [EOL]         final Locale locale = new Locale("sv", "SE"); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); [EOL]  [EOL]         assertEquals("fredag, week 53", fdf.format(d)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testLang645() { [EOL]         final Locale locale = new Locale("sv", "SE"); [EOL]  [EOL]         final Calendar cal = Calendar.getInstance(); [EOL]         cal.set(2010, 0, 1, 12, 0, 0); [EOL]         final Date d = cal.getTime(); [EOL]  [EOL]         final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); [EOL]  [EOL]         assertEquals("fredag, week 53", fdf.format(d)); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("False
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("falseab")); [EOL]         assertTrue(BooleanUtils.toBoolean("falseab")); [EOL]         assertTrue(BooleanUtils.toBoolean("trueabc")); [EOL]         assertTrue(BooleanUtils.toBoolean("trueabc")); [EOL]         assertTrue(BooleanUtils.toBoolean("falseabc")); [EOL]         assertTrue(BooleanUtils.toBoolean("trueabc
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Trueab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabab")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertTrue(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False a")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falsef")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEe")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEe")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falsee")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.to
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("Falseabxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("abxyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL]         assertFalse(BooleanUtils.toBoolean("xyz")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("false")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEA")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEa")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSEab")); [EOL]         assertTrue(BooleanUtils.toBoolean("Falseab")); [EOL
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")
@Test [EOL]     public void test_toBoolean_String() { [EOL]         assertFalse(BooleanUtils.toBoolean((String) null)); [EOL]         assertFalse(BooleanUtils.toBoolean("")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertFalse(BooleanUtils.toBoolean("off")); [EOL]         assertFalse(BooleanUtils.toBoolean("oof")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertTrue(BooleanUtils.toBoolean("true")); [EOL]         assertFalse(BooleanUtils.toBoolean("false")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("TRUE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertTrue(BooleanUtils.toBoolean("TRUE")); [EOL]         assertTrue(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSEf")); [EOL]         assertFalse(BooleanUtils.toBoolean("FALSE")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("True")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")); [EOL]         assertFalse(BooleanUtils.toBoolean("False")
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetPrefix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariablePrefix('<'); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariablePrefix("<<"); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariablePrefix((String) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariablePrefixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]         try { [EOL]             sub.setVariablePrefixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetPrefix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariablePrefix('<'); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariablePrefix("<<"); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariablePrefix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariablePrefixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]         try { [EOL]             sub.setVariablePrefixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetPrefix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariablePrefix('<'); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariablePrefix("<<"); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariablePrefix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariablePrefixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]         try { [EOL]             sub.setVariablePrefixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) { [EOL]         final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]  [EOL]         // replace using String [EOL]         assertEquals(expectedResult, sub.replace(replaceTemplate)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using char[] [EOL]         final char[] chars = replaceTemplate.toCharArray(); [EOL]         assertEquals(expectedResult, sub.replace(chars)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuffer [EOL]         StringBuffer buf = new StringBuffer(replaceTemplate); [EOL]         assertEquals(expectedResult, sub.replace(buf)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuilder [EOL]         StringBuilder builder = new StringBuilder(replaceTemplate); [EOL]         assertEquals(
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) { [EOL]         final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]  [EOL]         // replace using String [EOL]         assertEquals(expectedResult, sub.replace(replaceTemplate)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using char[] [EOL]         final char[] chars = replaceTemplate.toCharArray(); [EOL]         assertEquals(expectedResult, sub.replace(chars)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuffer [EOL]         StringBuffer buf = new StringBuffer(replaceTemplate); [EOL]         assertEquals(expectedResult, sub.replace(buf)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuilder [EOL]         StringBuilder builder = new StringBuilder(replaceTemplate); [EOL]         assertEquals(
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) { [EOL]         final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]  [EOL]         // replace using String [EOL]         assertEquals(expectedResult, sub.replace(replaceTemplate)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using char[] [EOL]         final char[] chars = replaceTemplate.toCharArray(); [EOL]         assertEquals(expectedResult, sub.replace(chars)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuffer [EOL]         StringBuffer buf = new StringBuffer(replaceTemplate); [EOL]         assertEquals(expectedResult, sub.replace(buf)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuilder [EOL]         StringBuilder builder = new StringBuilder(replaceTemplate); [EOL]         assertEquals(
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) { [EOL]         final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]  [EOL]         // replace using String [EOL]         assertEquals(expectedResult, sub.replace(replaceTemplate)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using char[] [EOL]         final char[] chars = replaceTemplate.toCharArray(); [EOL]         assertEquals(expectedResult, sub.replace(chars)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuffer [EOL]         StringBuffer buf = new StringBuffer(replaceTemplate); [EOL]         assertEquals(expectedResult, sub.replace(buf)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuilder [EOL]         StringBuilder builder = new StringBuilder(replaceTemplate); [EOL]         assertEquals(
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSet() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableResolver() instanceof StrLookup<?>); [EOL]         sub.setVariableResolver(StrLookup.create("<null>")); [EOL]         assertTrue(sub.getVariableResolver() instanceof StrLookup<?>); [EOL]         sub.setVariableResolver(StrLookup.create((String) null)); [EOL]         assertTrue(sub.getVariableResolver() instanceof StrLookup<?>); [EOL]         try { [EOL]             sub.setVariableResolver(StrLookup.create((String) null)); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableResolver() instanceof StrLookup<?>); [EOL]  [EOL]         final StrLookup<String> var = StrLookup.create("<null>"); [EOL]         sub.setVariableResolver(var); [EOL]         assertSame(var, sub.getVariableResolver()); [EOL]         try { [EOL]             sub.setVariableResolver(null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(var, sub.getVariableResolver()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) { [EOL]         final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]  [EOL]         // replace using String [EOL]         assertEquals(expectedResult, sub.replace(replaceTemplate)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using char[] [EOL]         final char[] chars = replaceTemplate.toCharArray(); [EOL]         assertEquals(expectedResult, sub.replace(chars)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuffer [EOL]         StringBuffer buf = new StringBuffer(replaceTemplate); [EOL]         assertEquals(expectedResult, sub.replace(buf)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuilder [EOL]         StringBuilder builder = new StringBuilder(replaceTemplate); [EOL]         assertEquals(
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testCyclicReplacement() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("animal", "${critter}"); [EOL]         map.put("target", "${pet}"); [EOL]         map.put("pet", "${petCharacteristic} dog"); [EOL]         map.put("petCharacteristic", "lazy"); [EOL]         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); [EOL]         map.put("critterSpeed", "quick"); [EOL]         map.put("critterColor", "brown"); [EOL]         map.put("critterType", "${animal}"); [EOL]         final StrSubstitutor sub = new StrSubstitutor(map); [EOL]         try { [EOL]             sub.replace("The ${animal} jumps over the ${target}."); [EOL]             fail("Cyclic replacement was not detected!"); [EOL]         } catch (final IllegalStateException ex) { [EOL]             // expected [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests interpolation with weird boundary patterns. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testSamePrefixAndSuffix() { [EOL]         final Map<String, String> map = new HashMap<String, String>(); [EOL]         map.put("greeting", "Hello"); [EOL]         map.put(" there ", "XXX"); [EOL]         map.put("name", "commons"); [EOL]         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); [EOL]         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]     private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) { [EOL]         final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1); [EOL]         final StrSubstitutor sub = new StrSubstitutor(values); [EOL]  [EOL]         // replace using String [EOL]         assertEquals(expectedResult, sub.replace(replaceTemplate)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using char[] [EOL]         final char[] chars = replaceTemplate.toCharArray(); [EOL]         assertEquals(expectedResult, sub.replace(chars)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuffer [EOL]         StringBuffer buf = new StringBuffer(replaceTemplate); [EOL]         assertEquals(expectedResult, sub.replace(buf)); [EOL]         if (substring) { [EOL]             assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2)); [EOL]         } [EOL]  [EOL]         // replace using StringBuilder [EOL]         StringBuilder builder = new StringBuilder(replaceTemplate); [EOL]         assertEquals(
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceEmptyKeys() { [EOL]         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests replace creates output same as input. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetPrefix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariablePrefix('<'); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariablePrefix("<<"); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariablePrefix((String) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariablePrefixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]         try { [EOL]             sub.setVariablePrefixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final NullPointerException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetPrefix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariablePrefix('<'); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariablePrefix("<<"); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariablePrefix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariablePrefixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]         try { [EOL]             sub.setVariablePrefixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetPrefix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariablePrefix('<'); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariablePrefix("<<"); [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariablePrefix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariablePrefixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]         try { [EOL]             sub.setVariablePrefixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariablePrefixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetSuffix() { [EOL]         final StrSubstitutor sub = new StrSubstitutor(); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         sub.setVariableSuffix('<'); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); [EOL]  [EOL]         sub.setVariableSuffix("<<"); [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]         try { [EOL]             sub.setVariableSuffix((String) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); [EOL]  [EOL]         final StrMatcher matcher = StrMatcher.commaMatcher(); [EOL]         sub.setVariableSuffixMatcher(matcher); [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]         try { [EOL]             sub.setVariableSuffixMatcher((StrMatcher) null); [EOL]             fail(); [EOL]         } catch (final IllegalArgumentException ex) { [EOL]             // expected [EOL]         } [EOL]         assertSame(matcher, sub.getVariableSuffixMatcher()); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests get set. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testReplaceComplexEscaping() { [EOL]         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests when no prefix or suffix. [EOL]      */ [EOL]
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testDelete_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.delete(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.delete("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.delete("", new String[0])); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.delete("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.delete("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", "")); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.delete("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.delete("hello", new String[] { "l" })); [EOL]     } [EOL]      [EOL] } [EOL]
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testSqueeze_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.squeeze("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[0])); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.squeeze("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.squeeze("hello", "")); [EOL]         assertEquals("", CharSetUtils.squeeze("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.squeeze("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.squeeze("hello", new String[] { "l" }
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetImplicitUpperBounds() { [EOL]         final WildcardType wildcardType = EasyMock.createMock(WildcardType.class); [EOL]         final Type[] expected = new Type[] {String.class}; [EOL]         Assert.assertArrayEquals(expected, TypeUtils.getImplicitUpperBounds(wildcardType)); [EOL]         Assert.assertArrayEquals(expected, TypeUtils.getImplicitUpperBounds(new WildcardType())); [EOL]     } [EOL]  [EOL]     public Iterable<? extends Map<Integer, ? extends Collection<?>>> iterable; [EOL]  [EOL]     public static <G extends Comparable<G>> G stub() { [EOL]         return null; [EOL]     } [EOL]  [EOL]     public static <T extends Comparable<? extends T>> T stub2() { [EOL]         return null; [EOL]     } [EOL]  [EOL]     public static <T extends Comparable<? extends T>> T stub3() { [EOL]         return null; [EOL]     } [EOL]  [EOL]     public static <T extends Comparable<? extends T>> T stub4() { [EOL]         return null; [EOL]     } [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetImplicitUpperBounds() { [EOL]         final WildcardType wildcardType = EasyMock.createMock(WildcardType.class); [EOL]         final Type[] expectedArray = {String.class}; [EOL]         final Type[] actualArray = TypeUtils.getImplicitUpperBounds(wildcardType); [EOL]         assertEquals(expectedArray.length, actualArray.length); [EOL]         assertEquals(expectedArray[0], actualArray[0]); [EOL]         assertEquals(expectedArray[1], actualArray[1]); [EOL]         assertEquals(expectedArray[2], actualArray[2]); [EOL]         assertEquals(expectedArray[3], actualArray[3]); [EOL]         assertEquals(expectedArray[4], actualArray[4]); [EOL]         assertEquals(expectedArray[5], actualArray[5]); [EOL]         assertEquals(expectedArray[6], actualArray[6]); [EOL]         assertEquals(expectedArray[7], actualArray[7]); [EOL]         assertEquals(expectedArray[8], actualArray[8]); [EOL]         assertEquals(expectedArray[9], actualArray[9]); [EOL]         assertEquals(expectedArray[10], actualArray[10]); [EOL]         assertEquals(expectedArray[11], actualArray[11]); [EOL]         assertEquals(expectedArray[12], actualArray[12]); [EOL]         assertEquals(expectedArray[13], actualArray[13]); [EOL]         assertEquals(expectedArray[14], actualArray[14]); [EOL]         assertEquals(expectedArray[15], actualArray[15]); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetImplicitUpperBounds() { [EOL]         final WildcardType wildcardType = EasyMock.createMock(WildcardType.class); [EOL]         final Type[] expectedArray = {String.class}; [EOL]         Assert.assertArrayEquals(expectedArray, TypeUtils.getImplicitUpperBounds(wildcardType)); [EOL]         EasyMock.replay(wildcardType); [EOL]         final Type[] actualArray = TypeUtils.getImplicitUpperBounds(wildcardType); [EOL]         Assert.assertArrayEquals(expectedArray, actualArray); [EOL]         EasyMock.verify(wildcardType); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang820() throws Exception { [EOL]         final Type[] typeArray = {String.class, String.class}; [EOL]         final Type[] expectedArray = {String.class}; [EOL]         Assert.assertArrayEquals(expectedArray, TypeUtils.normalizeUpperBounds(typeArray)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetImplicitLowerBounds() throws SecurityException, NoSuchFieldException { [EOL]         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") [EOL]                 .getGenericType(); [EOL]         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") [EOL]                 .getGenericType(); [EOL]         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); [EOL]         final Type genericParentT = GenericParent.class.getTypeParameters()[0]; [EOL]         Assert.assertNull(TypeUtils.getImplicitLowerBounds(stringParentFieldType)); [EOL]         Assert.assertNull(TypeUtils.getImplicitLowerBounds(integerParentFieldType)); [EOL]         Assert.assertEquals(GenericParent.class, TypeUtils.getImplicitLowerBounds(foosFieldType)); [EOL]         Assert.assertEquals(String.class, TypeUtils.getImplicitLowerBounds(genericParentT)); [EOL]         Assert.assertEquals(Foo.class, TypeUtils.getImplicitLowerBounds(genericParentT)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang820() throws Exception { [EOL]         final Type[] typeArray = {String.class, String.class}; [EOL]         final Type[] expectedArray = {String.class}; [EOL]         Assert.assertArrayEquals(expectedArray, TypeUtils.normalizeUpperBounds(typeArray)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLang820() throws Exception { [EOL]         final Type[] typeArray = {String.class, String.class}; [EOL]         final Type[] expectedArray = {String.class}; [EOL]         Assert.assertArrayEquals(expectedArray, TypeUtils.normalizeUpperBounds(typeArray)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDetermineTypeVariableAssignments() throws SecurityException, [EOL]             NoSuchFieldException, NoSuchMethodException { [EOL]         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") [EOL]                 .getGenericType(); [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, [EOL]                 iterableType); [EOL]         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; [EOL]         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); [EOL]         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns [EOL]                 .get(treeSetTypeVar)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetImplicitLowerBounds() { [EOL]         final WildcardType wildcardType = (WildcardType) getClass().getField("hello").getGenericType(); [EOL]         final Type[] expected = new Type[] {String.class}; [EOL]         Assert.assertArrayEquals(expected, TypeUtils.getImplicitLowerBounds(wildcardType)); [EOL]         Assert.assertArrayEquals(expected, TypeUtils.getImplicitLowerBounds(null)); [EOL]     } [EOL]  [EOL]     public Iterable<? extends Map<Integer, ? extends Collection<?>>> iterable; [EOL]  [EOL]     public static <G extends Comparable<G>> G stub() { [EOL]         return null; [EOL]     } [EOL]  [EOL]     public static <T extends Comparable<? extends T>> T stub2() { [EOL]         return null; [EOL]     } [EOL]  [EOL]     public static <T extends Comparable<? extends T>> T stub3() { [EOL]         return null; [EOL]     } [EOL] } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isAssignable(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isAssignable(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsInstance() throws SecurityException, NoSuchFieldException { [EOL]         final Type intComparableType = getClass().getField("intComparable").getGenericType(); [EOL]         final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); [EOL]         intComparable = 1; [EOL]         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); [EOL]         // uriComparable = 1; [EOL]         Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final IDKey key1 = new IDKey(VALUE); [EOL]         final IDKey key2 = new IDKey(VALUE); [EOL]         assertEquals(key1, key2); [EOL]         assertEquals(key1.hashCode(), key2.hashCode()); [EOL]         assertFalse(key1.equals(null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final IDKey key1 = new IDKey(VALUE); [EOL]         final IDKey key2 = new IDKey(VALUE); [EOL]         assertTrue(key1.equals(key1)); [EOL]         assertTrue(key1.equals(new Object())); [EOL]         assertTrue(key2.equals(key2)); [EOL]         assertFalse(key1.equals(null)); [EOL]         assertFalse(key1.equals("Ni!")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]         final TestObject to14 = new TestObject(17); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to1.hashCode(), to5.hashCode()); [EOL]          [EOL]         assertEquals(to1, to1); [EOL]         assertEquals(to1, to2); [EOL]         assertEquals(to1, to3); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to1.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final IDKey key1 = new IDKey(VALUE); [EOL]         final IDKey key2 = new IDKey(VALUE); [EOL]         assertTrue(key1.equals(key1)); [EOL]         assertTrue(key1.equals(new Object())); [EOL]         assertTrue(key2.equals(key2)); [EOL]         assertFalse(key1.equals(null)); [EOL]         assertFalse(key1.equals("abc")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final IDKey key1 = new IDKey(VALUE); [EOL]         final IDKey key2 = new IDKey(VALUE); [EOL]         assertEquals(key1, key2); [EOL]         assertEquals(key1.hashCode(), key2.hashCode()); [EOL]         assertFalse(key1.equals(null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToHashCode() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]         final TestObject to14 = new TestObject(17); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to1.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsRegistered() { [EOL]         assertFalse(HashCodeBuilder.isRegistered(null)); [EOL]         assertTrue(HashCodeBuilder.isRegistered(new Object())); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new String(""))); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new int[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new long[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new short[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new char[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new char[] { 'f', 'o', 'o' })); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new float[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new double[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new double[] { 'f', 'O', 'O' })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final IDKey key1 = new IDKey(VALUE); [EOL]         final IDKey key2 = new IDKey(VALUE); [EOL]         assertEquals(key1, key2); [EOL]         assertEquals(key1.hashCode(), key2.hashCode()); [EOL]         assertFalse(key1.equals(null)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx2() { [EOL]         HashCodeBuilder.reflectionHashCode(2, 2, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         assertEquals(17 * 37, HashCodeBuilder.getRegistry().size()); [EOL]         final int[] obj = new int[2]; [EOL]         assertEquals(17 * 37, HashCodeBuilder.getRegistry().add(new IDKey(17, 37))); [EOL]         assertEquals(17 * 37, HashCodeBuilder.getRegistry().add(new IDKey(17, 37 + 1))); [EOL]         assertEquals(17 * 37 + 1, HashCodeBuilder.getRegistry().add(new IDKey(17, 37 + 2))); [EOL]         obj[0] = (byte) 5; [EOL]         assertEquals((byte) 5, HashCodeBuilder.getRegistry().add(new IDKey(17, 37 + 1))); [EOL]         assertEquals((byte) 6, HashCodeBuilder.getRegistry().add(new IDKey(17, 37 + 2))); [EOL]         obj[1] = (byte) 6; [EOL]         assertEquals((byte) 6, HashCodeBuilder.getRegistry().add(new IDKey(17, 37 + 3))); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(5); [EOL]         final TestObject to2 = new TestObject(6); [EOL]         final TestObject to3 = new TestObject(7); [EOL]         final TestObject to4 = new TestObject(8); [EOL]         final TestObject to5 = new TestObject(9); [EOL]         final TestObject to6 = new TestObject(10); [EOL]         final TestObject to7 = new TestObject(11); [EOL]         final TestObject to8 = new TestObject(12); [EOL]         final TestObject to9 = new TestObject(13); [EOL]         final TestObject to10 = new TestObject(14); [EOL]         final TestObject to11 = new TestObject(15); [EOL]         final TestObject to12 = new TestObject(16); [EOL]         final TestObject to13 = new TestObject(17); [EOL]         final TestObject to14 = new TestObject(15); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to1.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnregister() { [EOL]         final Object obj = new Object(); [EOL]         assertEquals(17 * 37, HashCodeBuilder.getRegistry().size()); [EOL]         HashCodeBuilder.unregister(obj); [EOL]         assertEquals(0, HashCodeBuilder.getRegistry().size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to4.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx2() { [EOL]         HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx2() { [EOL]         HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testSetRegistry() { [EOL]         final Set<IDKey> registry = HashCodeBuilder.getRegistry(); [EOL]         assertEquals(17 * 37, registry.size()); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 1))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 2))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 3))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 4))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 5))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 6))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 7))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 8))); [EOL]         assertTrue(registry.contains(new IDKey(17 * 37 + 9))); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx2() { [EOL]         HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx2() { [EOL]         HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(5); [EOL]         final TestObject to2 = new TestObject(6); [EOL]         final TestObject to3 = new TestObject(7); [EOL]         final TestObject to4 = new TestObject(8); [EOL]         final TestObject to5 = new TestObject(9); [EOL]         final TestObject to6 = new TestObject(10); [EOL]         final TestObject to7 = new TestObject(11); [EOL]         final TestObject to8 = new TestObject(12); [EOL]         final TestObject to9 = new TestObject(13); [EOL]         final TestObject to10 = new TestObject(14); [EOL]         final TestObject to11 = new TestObject(15); [EOL]         final TestObject to12 = new TestObject(16); [EOL]         final TestObject to13 = new TestObject(17); [EOL]         final TestObject to14 = new TestObject(15); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to1.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnregister() { [EOL]         final Object obj = new Object(); [EOL]         assertEquals(17 * 37, HashCodeBuilder.getRegistry().size()); [EOL]         HashCodeBuilder.unregister(obj); [EOL]         assertEquals(0, HashCodeBuilder.getRegistry().size()); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testUnregister() { [EOL]         final Object obj = new Object(); [EOL]         assertEquals(17 * 37, HashCodeBuilder.getRegistry().size()); [EOL]         HashCodeBuilder.unregister(obj); [EOL]         assertEquals(0, HashCodeBuilder.getRegistry().size()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final IDKey k1 = new IDKey(VALUE); [EOL]         final IDKey k2 = new IDKey(VALUE); [EOL]         assertTrue(k1.equals(k1)); [EOL]         assertTrue(k1.equals(k2)); [EOL]         assertTrue(k2.equals(k2)); [EOL]         assertFalse(k1.equals(null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to4.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final IDKey key1 = new IDKey(VALUE); [EOL]         final IDKey key2 = new IDKey(VALUE); [EOL]         assertEquals(key1, key2); [EOL]         assertEquals(key1.hashCode(), key2.hashCode()); [EOL]         assertFalse(key1.equals(null)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testCharArrayAsObject() { [EOL]         final char[] obj = new char[2]; [EOL]         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[0] = (char) 5; [EOL]         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]         obj[1] = (char) 6; [EOL]         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to4.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx2() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final IDKey key1 = new IDKey(VALUE); [EOL]         final IDKey key2 = new IDKey(VALUE); [EOL]         assertTrue(key1.equals(key1)); [EOL]         assertTrue(key1.equals(new Object())); [EOL]         assertTrue(key2.equals(key2)); [EOL]         assertFalse(key1.equals(null)); [EOL]         assertFalse(key1.equals("Ni!")); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx2() { [EOL]         HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to4.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsRegistered() { [EOL]         assertFalse(HashCodeBuilder.isRegistered(null)); [EOL]         assertTrue(HashCodeBuilder.isRegistered(new Object())); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new String(""))); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new int[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new long[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new short[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new char[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new char[] { 'f', 'o', 'o' })); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new float[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new double[0])); [EOL]         assertFalse(HashCodeBuilder.isRegistered(new float[] { 'f', 'O', 'O' })); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to4.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to4.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx2() { [EOL]         HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEqualsHashcode() { [EOL]         final IDKey key1 = new IDKey(new Object()); [EOL]         final IDKey key2 = new IDKey(new Object()); [EOL]         assertTrue(key1.equals(key1)); [EOL]         assertTrue(key1.equals(new Object())); [EOL]         assertTrue(key2.equals(key2)); [EOL]         assertEquals(key1.hashCode(), key2.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToHashCode() { [EOL]         assertEquals(17 * 37, new HashCodeBuilder(17, 37).toHashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to4.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final IDKey key1 = new IDKey(VALUE); [EOL]         final IDKey key2 = new IDKey(VALUE); [EOL]         assertTrue(key1.equals(key1)); [EOL]         assertTrue(key1.equals(new Object())); [EOL]         assertTrue(key2.equals(key2)); [EOL]         assertFalse(key1.equals(null)); [EOL]         assertFalse(key1.equals("Ni!")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReflectionAppend() { [EOL]         final TestObject to1 = new TestObject(4); [EOL]         final TestObject to2 = new TestObject(5); [EOL]         final TestObject to3 = new TestObject(6); [EOL]         final TestObject to4 = new TestObject(7); [EOL]         final TestObject to5 = new TestObject(8); [EOL]         final TestObject to6 = new TestObject(9); [EOL]         final TestObject to7 = new TestObject(10); [EOL]         final TestObject to8 = new TestObject(11); [EOL]         final TestObject to9 = new TestObject(12); [EOL]         final TestObject to10 = new TestObject(13); [EOL]         final TestObject to11 = new TestObject(14); [EOL]         final TestObject to12 = new TestObject(15); [EOL]         final TestObject to13 = new TestObject(16); [EOL]          [EOL]         assertEquals(to1.hashCode(), to1.hashCode()); [EOL]         assertEquals(to1.hashCode(), to2.hashCode()); [EOL]         assertEquals(to1.hashCode(), to3.hashCode()); [EOL]         assertEquals(to1.hashCode(), to4.hashCode()); [EOL]         assertEquals(to4.hashCode(), to5.hashCode()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIntegerWithTransients() { [EOL]         final int[][] array1 = new int[2][2]; [EOL]         final int[][] array2 = new int[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array1, true)); [EOL]         assertEquals(17 * 37 + 19, HashCodeBuilder.reflectionHashCode(17, 37, array2, true)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void testReflectionHashCodeEx1() { [EOL]         HashCodeBuilder.reflectionHashCode(17, 37, null, true); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testDelete_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.delete(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.delete("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.delete("", new String[0])); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.delete("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.delete("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", "")); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.delete("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.delete("hello", new String[] { "l" })); [EOL]     } [EOL]      [EOL] } [EOL]
@Test [EOL]     public void testDelete_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.delete(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.delete("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.delete("", new String[0])); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.delete("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.delete("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", "")); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.delete("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.delete("hello", new String[] { "l" })); [EOL]     } [EOL]      [EOL] } [EOL]
@Test [EOL]     public void testDelete_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.delete(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.delete("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.delete("", new String[0])); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.delete("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.delete("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", "")); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.delete("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.delete("hello", new String[] { "l" })); [EOL]     } [EOL]      [EOL] } [EOL]
@Test [EOL]     public void testDelete_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.delete(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.delete("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.delete("", new String[0])); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.delete("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.delete("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", "")); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.delete("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.delete("hello", new String[] { "l" })); [EOL]     } [EOL]      [EOL] } [EOL]
@Test [EOL]     public void testDelete_StringStringarray() { [EOL]         assertEquals(null, CharSetUtils.delete(null, (String[]) null)); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[0])); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {null})); [EOL]         assertEquals(null, CharSetUtils.delete(null, new String[] {"el"})); [EOL]          [EOL]         assertEquals("", CharSetUtils.delete("", (String[]) null)); [EOL]         assertEquals("", CharSetUtils.delete("", new String[0])); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {null})); [EOL]         assertEquals("", CharSetUtils.delete("", new String[] {"a-e"})); [EOL]          [EOL]         assertEquals("hello", CharSetUtils.delete("hello", (String[]) null)); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[0])); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {null})); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] {"xyz"})); [EOL]  [EOL]         assertEquals("ho", CharSetUtils.delete("hello", new String[] { "el" })); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "elho" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", new String[] { "" })); [EOL]         assertEquals("hello", CharSetUtils.delete("hello", "")); [EOL]         assertEquals("", CharSetUtils.delete("hello", new String[] { "a-z" })); [EOL]         assertEquals("", CharSetUtils.delete("----", new String[] { "-" })); [EOL]         assertEquals("heo", CharSetUtils.delete("hello", new String[] { "l" })); [EOL]     } [EOL]      [EOL] } [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testFormat() { [EOL]         final Locale realDefaultLocale = Locale.getDefault(); [EOL]         final TimeZone realDefaultZone = TimeZone.getDefault(); [EOL]         try { [EOL]             Locale.setDefault(Locale.US); [EOL]             TimeZone.setDefault(NEW_YORK); [EOL]  [EOL]             final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); [EOL]             final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); [EOL]             final Date date1 = cal1.getTime(); [EOL]             final Date date2 = cal2.getTime(); [EOL]             final long millis1 = date1.getTime(); [EOL]             final long millis2 = date2.getTime(); [EOL]  [EOL]             DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); [EOL]             assertEquals(sdf.format(date1), fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(date1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); [EOL]             assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(date2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); [EOL]             assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); [EOL]  [EOL]             fdf = getInstance("Z"); [EOL]             assertEquals("-0500", fdf.format(date1)); [EOL]             assertEquals("-0500", fdf.format(cal1)); [EOL]             assertEquals("-05
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testParseSync() throws InterruptedException { [EOL]         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; [EOL]         final FastDateFormat formatter= FastDateFormat.getInstance(pattern); [EOL]          [EOL]         final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { [EOL]                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable [EOL]  [EOL]                         @Override [EOL]                         public Object parseObject(final String formattedDate) throws ParseException { [EOL]                             synchronized(this) { [EOL]                                 return super.parse(formattedDate); [EOL]                             } [EOL]                         } [EOL]         }); [EOL]          [EOL]         final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); [EOL]          [EOL]         final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+"  SimpleDateFormat:"+sdfTime; [EOL]         System.out.println(times); [EOL]     } [EOL]  [EOL]     final static private int NTHREADS= 10; [EOL]      [EOL]     final static private int NROUNDS= 10000; [EOL]      [EOL]     private long measureTime(final Format formatter, final Format parser) throws InterruptedException { [EOL]         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); [EOL]         final AtomicInteger failures= new AtomicInteger(0); [EOL]         final AtomicLong totalElapsed= new AtomicLong(0); [EOL]          [EOL]         for(int i= 0; i<NTHREADS; ++i) { [EOL]             pool.submit(new Runnable() { [EOL]                 @Override [EOL]                 public void run() { [EOL]                     for(int i= 0; i<NROUNDS; ++i) { [EOL]                         try { [EOL]                             final Date date= new Date(); [EOL]                             final String formattedDate= formatter.format(date); [EOL]                             final long start= System.currentTimeMillis();         [EOL]                             final Object pd= parser.parseObject(formattedDate); [EOL]                             totalElapsed.
@Test [EOL]     public void testEquals() { [EOL]         final DateParser parser1= getInstance(YMD_SLASH); [EOL]         final DateParser parser2= getInstance(YMD_SLASH); [EOL]  [EOL]         assertEquals(parser1, parser2); [EOL]         assertEquals(parser1.hashCode(), parser2.hashCode()); [EOL]  [EOL]         assertFalse(parser1.equals(new Object())); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_charArray() { [EOL]         final char[] input = new char[] {'a', 'b'}; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.reset(input); [EOL]         assertEquals(input, tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         tok.reset(input); [EOL]         assertEquals(input, tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         tok.reset(input); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_charArray() { [EOL]         final char[] input = new char[]{'f', 'o', 'o'}; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.reset(input); [EOL]         assertEquals(input, tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         tok.reset(input); [EOL]         assertEquals(input, tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         tok.reset(input); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testReset_charArray() { [EOL]         final char[] input = new char[]{'f', 'o', 'o'}; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.reset(input); [EOL]         assertEquals(input, tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         tok.reset(input); [EOL]         assertEquals(input, tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         tok.reset(input); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetContent() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(input, tok.getContent()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         assertEquals(null, tok.getContent()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(null); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testReset_charArray() { [EOL]         final char[] input = new char[]{'f', 'o', 'o'}; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         tok.reset(input); [EOL]         assertEquals(input, tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         tok.reset(input); [EOL]         assertEquals(input, tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(); [EOL]         tok.reset(input); [EOL]         assertEquals(null, tok.getTokenArray()); [EOL]     } [EOL]  [EOL]     //----------------------------------------------------------------------- [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testGetTokenArray() { [EOL]         final String input = "a   b c \"d e\" f "; [EOL]         StrTokenizer tok = new StrTokenizer(input); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenList()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]          [EOL]         tok = new StrTokenizer(input.toCharArray()); [EOL]         assertEquals(Arrays.asList(tok.getTokenArray()), tok.getTokenArray()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAppend() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo
@Test [EOL]     public void testAppend() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo",
@Test [EOL]     public void testAppend() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("
@Test [EOL]     public void testAppend() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo
@Test [EOL]     public void testAppend() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new
@Test [EOL]     public void testAppend_StringInt() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", Formattable
@Test [EOL]     public void testAppend_StringInt() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", Formattable
@Test [EOL]     public void testAppend() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo",
@Test [EOL]     public void testAppend_StringInt() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("+foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", Formattable
@Test [EOL]     public void testAppend() { [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '-').toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, -1).toString()); [EOL]          [EOL]         assertEquals("f*", FormattableUtils.append("foo
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", -1).length); [EOL]          [EOL]         String str = "a b c"; [EOL]         String[] res = StringUtils.splitPreserveAllTokens(str); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str); [EOL]         assertEquals(6, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str =
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", -1).length); [EOL]  [EOL]         String str = "a b c"; [EOL]         String[] res = StringUtils.splitPreserveAllTokens(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str, ".", 0); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str, ".", 3); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str, ".", 4); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]          [EOL]         String str = "a b c"; [EOL]         String[] res = StringUtils.splitPreserveAllTokens(str, "."); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str, "."); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str, "."); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str, "."); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str, "."); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]);
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testSplitPreserveAllTokens_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); [EOL]         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); [EOL]          [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.splitPreserveAllTokens(str, "."); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]          [EOL]         str = ".a."; [EOL]         res = StringUtils.splitPreserveAllTokens(str, "."); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str,' '); [EOL]         assertEquals(4, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str,' '); [EOL]         assertEquals(5, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]          [EOL]         str = " a b c"; [EOL]         res = StringUtils.splitPreserveAllTokens(str,' '); [EOL
@Test [EOL]     public void testSplit_StringStringInt() { [EOL]         assertArrayEquals(null, StringUtils.split(null, ".", -1)); [EOL]         assertEquals(0, StringUtils.split("", ".", -1).length); [EOL]  [EOL]         String str = "a.b.. c"; [EOL]         String[] res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals(" c", res[2]); [EOL]              [EOL]         str = ".a."; [EOL]         res = StringUtils.split(str, ".", -1); [EOL]         assertEquals(1, res.length); [EOL]         assertEquals("a", res[0]); [EOL]          [EOL]         str = "a b c"; [EOL]         res = StringUtils.split(str,' '); [EOL]         assertEquals(3, res.length); [EOL]         assertEquals("a", res[0]); [EOL]         assertEquals("b", res[1]); [EOL]         assertEquals("c", res[2]); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIdentityToStringStringBuilder() { [EOL]         final Integer i = Integer.valueOf(45); [EOL]         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); [EOL]  [EOL]         final StringBuilder builder = new StringBuilder(); [EOL]         ObjectUtils.identityToString(builder, i); [EOL]         assertEquals(expected, builder.toString()); [EOL]  [EOL]         try { [EOL]             ObjectUtils.identityToString((StringBuilder)null, "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), null); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIdentityToStringStringBuilder() { [EOL]         final Integer i = Integer.valueOf(45); [EOL]         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); [EOL]  [EOL]         final StringBuilder builder = new StringBuilder(); [EOL]         ObjectUtils.identityToString(builder, i); [EOL]         assertEquals(expected, builder.toString()); [EOL]  [EOL]         try { [EOL]             ObjectUtils.identityToString((StringBuilder)null, "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), null); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIdentityToString_Object() { [EOL]         assertEquals(null, ObjectUtils.identityToString(null)); [EOL]         assertEquals("", ObjectUtils.identityToString("")); [EOL]         assertEquals("foo", ObjectUtils.identityToString("foo")); [EOL]         assertEquals("foo", ObjectUtils.identityToString("foo")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIdentityToString_Object() { [EOL]         assertEquals(null, ObjectUtils.identityToString(null)); [EOL]         assertEquals("", ObjectUtils.identityToString("")); [EOL]         assertEquals("abc", ObjectUtils.identityToString("abc")); [EOL]         assertEquals("xyz", ObjectUtils.identityToString("xyz")); [EOL]         assertEquals("i am a robot", ObjectUtils.identityToString("I Am a robot")); [EOL]         assertEquals("i am a machine", ObjectUtils.identityToString("i am a robot")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIdentityToString_Object() { [EOL]         assertEquals(null, ObjectUtils.identityToString(null)); [EOL]         assertEquals("", ObjectUtils.identityToString("")); [EOL]         assertEquals("abc", ObjectUtils.identityToString("abc")); [EOL]         assertEquals("xyz", ObjectUtils.identityToString("xyz")); [EOL]         assertEquals("i am a robot", ObjectUtils.identityToString("I Am a robot")); [EOL]         assertEquals("i am a machine", ObjectUtils.identityToString("i am a robot")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIdentityToString_Object() { [EOL]         assertEquals(null, ObjectUtils.identityToString(null)); [EOL]         assertEquals("", ObjectUtils.identityToString("")); [EOL]         assertEquals("abc", ObjectUtils.identityToString("abc")); [EOL]         assertEquals("xyz", ObjectUtils.identityToString("xyz")); [EOL]         assertEquals("i am a robot", ObjectUtils.identityToString("I Am a robot")); [EOL]         assertEquals("i am a machine", ObjectUtils.identityToString("i am a robot")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIdentityToStringStringBuilder() { [EOL]         final Integer i = Integer.valueOf(45); [EOL]         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); [EOL]  [EOL]         final StringBuilder builder = new StringBuilder(); [EOL]         ObjectUtils.identityToString(builder, i); [EOL]         assertEquals(expected, builder.toString()); [EOL]  [EOL]         try { [EOL]             ObjectUtils.identityToString((StringBuilder)null, "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), null); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]          [EOL]         try { [EOL]             ObjectUtils.identityToString(new StringBuilder(), "tmp"); [EOL]             fail("NullPointerException expected"); [EOL]         } catch(final NullPointerException npe) { [EOL]         } [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIdentityToString_Object() { [EOL]         assertEquals(null, ObjectUtils.identityToString(null)); [EOL]         assertEquals("", ObjectUtils.identityToString("")); [EOL]         assertEquals("abc", ObjectUtils.identityToString("abc")); [EOL]         assertEquals("xyz", ObjectUtils.identityToString("xyz")); [EOL]         assertEquals("i am a robot", ObjectUtils.identityToString("I Am a robot")); [EOL]         assertEquals("i am a machine", ObjectUtils.identityToString("i am a robot")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIdentityToString_Object() { [EOL]         assertEquals(null, ObjectUtils.identityToString(null)); [EOL]         assertEquals("", ObjectUtils.identityToString("")); [EOL]         assertEquals("abc", ObjectUtils.identityToString("abc")); [EOL]         assertEquals("xyz", ObjectUtils.identityToString("xyz")); [EOL]         assertEquals("i am a robot", ObjectUtils.identityToString("I Am a robot")); [EOL]         assertEquals("i am a machine", ObjectUtils.identityToString("i am a robot")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testEscapeSurrogatePairsLang858() throws Exception { [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858 [EOL]         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = null; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array0, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1s, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(null, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(array1, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAssignable_ClassArray_ClassArray_Autoboxing() { [EOL]         final Class<?>[] array2 = new Class[] {Object.class, Object.class}; [EOL]         final Class<?>[] array1 = new Class[] {String.class}; [EOL]         final Class<?>[] array1s = new Class[] {String.class}; [EOL]         final Class<?>[] array0 = new Class[] {}; [EOL]         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; [EOL]         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertFalse(ClassUtils.isAssignable(null, array2, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array0, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array0, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1, array1s, true)); [EOL]         assertTrue(ClassUtils.isAssignable(array1s, array2, true)); [EOL]  [EOL]         assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array1, true)); [EOL]         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); [EOL]  [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); [EOL]         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, true)); [EOL]     } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL]     public void test_setUpToClass_invalid() { [EOL]         final Integer val = Integer.valueOf(5); [EOL]         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); [EOL]         try { [EOL]             test.setUpToClass(String.class); [EOL]         } finally { [EOL]             test.toString(); [EOL]         } [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class ReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]         static final transient String staticTransientString = "staticTransientString"; [EOL]         static final transient int staticTransientInt = 54321; [EOL]         String instanceString = "instanceString"; [EOL]         int instanceInt = 67890; [EOL]         transient String transientString = "transientString"; [EOL]         transient int transientInt = 98765; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString = "staticString"; [EOL]         static final int staticInt = 12345; [EOL]     } [EOL]  [EOL]     /** [EOL]      * Test fixture for ReflectionToStringBuilder.toString() for statics. [EOL]      */ [EOL]     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { [EOL]         static final String staticString2 = "staticString2"; [EOL]         static final int staticInt2 = 67890; [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, false, false, true})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, true})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, true, false})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, true, true})); [EOL]         assertEquals( [EOL]             'd
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, false, false, true})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, false})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 false, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, false, true})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, true, false})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHexDigit(new boolean[]{ [EOL]                 true, true, true})); [EOL]         assertEquals( [EOL]             'd
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testBinaryToHexDigit() { [EOL]         assertEquals( [EOL]             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); [EOL]         assertEquals( [EOL]             '1', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); [EOL]         assertEquals( [EOL]             '2', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); [EOL]         assertEquals( [EOL]             '3', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); [EOL]         assertEquals( [EOL]             '4', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); [EOL]         assertEquals( [EOL]             '5', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); [EOL]         assertEquals( [EOL]             '6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); [EOL]         assertEquals( [EOL]             '7', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); [EOL]         assertEquals( [EOL]             '8', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             '9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); [EOL]         assertEquals( [EOL]             'a', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); [EOL]         assertEquals( [EOL]             'b', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); [EOL]         assertEquals( [EOL]             'c', Conversion.binaryToHex
@Test [EOL]     public void testIsAlphas() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertFalse(StringUtils.isAlpha("a")); [EOL]         assertFalse(StringUtils.isAlpha("A")); [EOL]         assertFalse(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertTrue(StringUtils.isAlpha("1")); [EOL]         assertTrue(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphas() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertFalse(StringUtils.isAlpha("a")); [EOL]         assertFalse(StringUtils.isAlpha("A")); [EOL]         assertFalse(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertTrue(StringUtils.isAlpha("1")); [EOL]         assertTrue(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphas() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertFalse(StringUtils.isAlpha("a")); [EOL]         assertFalse(StringUtils.isAlpha("A")); [EOL]         assertFalse(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertTrue(StringUtils.isAlpha("1")); [EOL]         assertTrue(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphas() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertFalse(StringUtils.isAlpha("a")); [EOL]         assertFalse(StringUtils.isAlpha("A")); [EOL]         assertFalse(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertTrue(StringUtils.isAlpha("1")); [EOL]         assertTrue(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphas() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertFalse(StringUtils.isAlpha("a")); [EOL]         assertFalse(StringUtils.isAlpha("A")); [EOL]         assertFalse(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertTrue(StringUtils.isAlpha("1")); [EOL]         assertTrue(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphas() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertFalse(StringUtils.isAlpha("a")); [EOL]         assertFalse(StringUtils.isAlpha("A")); [EOL]         assertFalse(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertTrue(StringUtils.isAlpha("1")); [EOL]         assertTrue(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testIsAlphas() { [EOL]         assertFalse(StringUtils.isAlpha(null)); [EOL]         assertFalse(StringUtils.isAlpha("")); [EOL]         assertFalse(StringUtils.isAlpha(" ")); [EOL]         assertFalse(StringUtils.isAlpha("a")); [EOL]         assertFalse(StringUtils.isAlpha("A")); [EOL]         assertFalse(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); [EOL]         assertFalse(StringUtils.isAlpha("ham kso")); [EOL]         assertTrue(StringUtils.isAlpha("1")); [EOL]         assertTrue(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); [EOL]         assertFalse(StringUtils.isAlpha("_")); [EOL]         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToString() { [EOL]         assertEquals("{}", ArrayUtils.toString(null)); [EOL]         assertEquals("{}", ArrayUtils.toString(new Object[0])); [EOL]         assertEquals("{}", ArrayUtils.toString(new String[0])); [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null})); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"})); [EOL]          [EOL]         assertEquals("<empty>", ArrayUtils.toString(null, "<empty>")); [EOL]         assertEquals("{}", ArrayUtils.toString(new Object[0], "<empty>")); [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]          [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToString() { [EOL]         assertEquals("{}", ArrayUtils.toString(null)); [EOL]         assertEquals("{}", ArrayUtils.toString(new Object[0])); [EOL]         assertEquals("{}", ArrayUtils.toString(new String[0])); [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null})); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"})); [EOL]          [EOL]         assertEquals("<empty>", ArrayUtils.toString(null, "<empty>")); [EOL]         assertEquals("{}", ArrayUtils.toString(new Object[0], "<empty>")); [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]          [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToString() { [EOL]         assertEquals("{}", ArrayUtils.toString(null)); [EOL]         assertEquals("{}", ArrayUtils.toString(new Object[0])); [EOL]         assertEquals("{}", ArrayUtils.toString(new String[0])); [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null})); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"})); [EOL]          [EOL]         assertEquals("<empty>", ArrayUtils.toString(null, "<empty>")); [EOL]         assertEquals("{}", ArrayUtils.toString(new Object[0], "<empty>")); [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]          [EOL]         assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); [EOL]         assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new CompareToBuilder()); [EOL]         final Constructor<?>[] cons = CompareToBuilder.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(CompareToBuilder.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(CompareToBuilder.class.getModifiers())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new CompareToBuilder()); [EOL]         final Constructor<?>[] cons = CompareToBuilder.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(CompareToBuilder.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(CompareToBuilder.class.getModifiers())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testConstructor() { [EOL]         assertNotNull(new CompareToBuilder()); [EOL]         final Constructor<?>[] cons = CompareToBuilder.class.getDeclaredConstructors(); [EOL]         assertEquals(1, cons.length); [EOL]         assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]         assertTrue(Modifier.isPublic(CompareToBuilder.class.getModifiers())); [EOL]         assertFalse(Modifier.isFinal(CompareToBuilder.class.getModifiers())); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToComparison() { [EOL]         final TestObject o1 = new TestObject(4); [EOL]         final TestObject o2 = new TestObject(5); [EOL]         assertTrue(new CompareToBuilder().toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, o2).toComparison() < 0); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] array1 = new TestObject[2]; [EOL]         array1[0] = new TestObject(4); [EOL]         array1[1] = new TestObject(5); [EOL]         final TestObject[] array2 = new TestObject[2]; [EOL]         array2[0] = new TestObject(4); [EOL]         array2[1] = new TestObject(5); [EOL]         final TestObject[] array3 = new TestObject[3]; [EOL]         array3[0] = new TestObject(4); [EOL]         array3[1] = new TestObject(5); [EOL]         array3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() > 0); [EOL]         array1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(array1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testToComparison() { [EOL]         final TestObject o1 = new TestObject(4); [EOL]         final TestObject o2 = new TestObject(5); [EOL]         assertTrue(new CompareToBuilder().toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, o2).toComparison() < 0); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testObjectArrayHiddenByObject() { [EOL]         final TestObject[] obj1 = new TestObject[2]; [EOL]         obj1[0] = new TestObject(4); [EOL]         obj1[1] = new TestObject(5); [EOL]         final TestObject[] obj2 = new TestObject[2]; [EOL]         obj2[0] = new TestObject(4); [EOL]         obj2[1] = new TestObject(5); [EOL]         final TestObject[] obj3 = new TestObject[3]; [EOL]         obj3[0] = new TestObject(4); [EOL]         obj3[1] = new TestObject(5); [EOL]         obj3[2] = new TestObject(6); [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() < 0); [EOL]  [EOL]         obj1[1] = new TestObject(7); [EOL]         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); [EOL]  [EOL]         assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         final long[][] array3 = new long[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiDoubleArray() { [EOL]         final double[][] array1 = new double[2][2]; [EOL]         final double[][] array2 = new double[2][2]; [EOL]         final double[][] array3 = new double[2][3]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]                 array3[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         array3[1][2] = 100; [EOL]         array3[1][2] = 100; [EOL]          [EOL]         assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); [EOL]         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); [EOL]         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); [EOL]         array1[1][1] = 127; [EOL]         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); [EOL]         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testMultiLongArray() { [EOL]         final long[][] array1 = new long[2][2]; [EOL]         final long[][] array2 = new long[2][2]; [EOL]         for (int i = 0; i < array1.length; ++i) { [EOL]             for (int j = 0; j < array1[0].length; j++) { [EOL]                 array1[i][j] = (i + 1) * (j + 1); [EOL]                 array2[i][j] = (i + 1) * (j + 1); [EOL]             } [EOL]         } [EOL]         assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); [EOL]         array1[1][1] = 0; [EOL]         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testBooleanArrayHiddenByObject() { [EOL]         final boolean[] array1 = new boolean[2]; [EOL]         array1[0] = true; [EOL]         array1[1] = false; [EOL]         final boolean[] array2 = new boolean[2]; [EOL]         array2[0] = true; [EOL]         array2[1] = false; [EOL]         final Object obj1 = array1; [EOL]         final Object obj2 = array2; [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); [EOL]         array1[1] = true; [EOL]         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); [EOL]     } [EOL]      [EOL]
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testObject() { [EOL]         final Integer i3 = Integer.valueOf(3); [EOL]         final Integer i4 = Integer.valueOf(4); [EOL]         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); [EOL]         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); [EOL]         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); [EOL]         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); [EOL]         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); [EOL]         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); [EOL]         assertEquals(baseStr + "[a={}]", new ToStringBuilder(
@Test [EOL]     public void testAddValueObject() { [EOL]         final MutableDouble mutNum = new MutableDouble(1); [EOL]         mutNum.add(Double.valueOf(1.1d)); [EOL]          [EOL]         assertEquals(2.1d, mutNum.doubleValue(), 0.01d); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, [EOL]                 LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetUnit() { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setUnit(TimeUnit.SECONDS); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, [EOL]                 LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.shutdown(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testGetSetUnit() { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setUnit(TimeUnit.SECONDS); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStartTimer() throws InterruptedException { [EOL]         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, [EOL]                 UNIT, LIMIT); [EOL]         final ScheduledFuture<?> future = semaphore.startTimer(); [EOL]         assertNotNull("No future returned", future); [EOL]         Thread.sleep(PERIOD); [EOL]         final int trials = 10; [EOL]         int count = 0; [EOL]         do { [EOL]             Thread.sleep(PERIOD); [EOL]             if (count++ > trials) { [EOL]                 fail("endOfPeriod() not called!"); [EOL]             } [EOL]         } while (semaphore.getPeriodEnds() <= 0); [EOL]         semaphore.shutdown(); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the shutdown() method if the executor belongs to the semaphore. In [EOL]      * this case it has to be shut down. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testAcquireLimit() throws InterruptedException { [EOL]         final ScheduledExecutorService service = EasyMock [EOL]                 .createMock(ScheduledExecutorService.class); [EOL]         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); [EOL]         prepareStartTimer(service, future); [EOL]         EasyMock.replay(service, future); [EOL]         final int count = 10; [EOL]         final CountDownLatch latch = new CountDownLatch(count - 1); [EOL]         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); [EOL]         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, [EOL]                 count - 1); [EOL]         semaphore.setLimit(count - 1); [EOL]  [EOL]         // start a thread that calls the semaphore count times [EOL]         t.start(); [EOL]         latch.await(); [EOL]         // now the semaphore's limit should be reached and the thread blocked [EOL]         assertEquals("Wrong semaphore count", count - 1, semaphore [EOL]                 .getAcquireCount()); [EOL]  [EOL]         // this wakes up the thread, it should call the semaphore once more [EOL]         semaphore.endOfPeriod(); [EOL]         t.join(); [EOL]         assertEquals("Wrong semaphore count (2)", 1, semaphore [EOL]                 .getAcquireCount()); [EOL]         assertEquals("Wrong acquire() count", count - 1, semaphore [EOL]                 .getLastAcquiresPerPeriod()); [EOL]         EasyMock.verify(service, future); [EOL]     } [EOL]  [EOL]     /** [EOL]      * Tests the acquire() method if more threads are involved than the limit. [EOL]      * This method starts a number of threads that all invoke the semaphore. The [EOL]      * semaphore's limit is set to 1, so in each period only a single thread can [EOL]      * acquire the semaphore. [EOL]      */ [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testStringCreateNumberEnsureNoPrecisionLoss(){ [EOL]         String shouldBeFloat = "1.23"; [EOL]         String shouldBeDouble = "3.40282354e+38"; [EOL]         String shouldBeBigDecimal = "1.797693134862315759e+308"; [EOL]          [EOL]         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); [EOL]         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); [EOL]     } [EOL]     /** [EOL]      * Test for {@link NumberUtils#toDouble(String)}. [EOL]      */ [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(0, new BitField(0).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(1, new BitField(1).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(2, new BitField(2).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(4, new BitField(4).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(8, new BitField(8).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(16, new BitField(16).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(32, new BitField(32).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(64, new BitField(64).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(-128, new BitField(128).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(1, new BitField(0).setByteBoolean((byte) 1, false)); [EOL]         assertEquals(0, new BitField(1).setByteBoolean((byte) 1, false)); [EOL]         assertEquals(0, new BitField(2).setByteBoolean((byte) 2, false)); [EOL]         assertEquals(0, new BitField(4).setByteBoolean((byte) 4, false)); [EOL]         assertEquals(0, new BitField(8).setByteBoolean((byte) 8, false)); [EOL]         assertEquals(0, new BitField(16).setByteBoolean((byte) 16, false)); [EOL]         assertEquals(0, new BitField(32).setByteBoolean((byte) 32, false)); [EOL]         assertEquals(0, new BitField(64).setByteBoolean((byte) 64, false)); [EOL]         assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false)); [EOL]         assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false)); [EOL]         final byte clearedBit = new Bit
@Test [EOL]     public void testSetShortValue() { [EOL]         assertEquals(bf_multi.setShortValue((short) 0), bf_multi.setShortValue((short) 0, (short) 0)); [EOL]         assertEquals(bf_single.setShortValue((short) 0), bf_single.setShortValue((short) 0, (short) 0)); [EOL]         assertEquals(bf_zero.setShortValue((short) 0), bf_zero.setShortValue((short) 0, (short) 0)); [EOL]         assertEquals(bf_multi.clearShortValue((short) 0), bf_multi.setShortValue((short) 0, (short) 0)); [EOL]         assertEquals(bf_single.clearShortValue((short) 1), bf_single.setShortValue((short) 1, (short) 0)); [EOL]         assertEquals(bf_zero.clearShortValue((short) 0), bf_zero.setShortValue((short) 0, (short) 0)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testByte() { [EOL]         assertEquals(0, new BitField(0).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(1, new BitField(1).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(2, new BitField(2).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(4, new BitField(4).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(8, new BitField(8).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(16, new BitField(16).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(32, new BitField(32).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(64, new BitField(64).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(-128, new BitField(128).setByteBoolean((byte) 0, true)); [EOL]         assertEquals(1, new BitField(0).setByteBoolean((byte) 1, false)); [EOL]         assertEquals(0, new BitField(1).setByteBoolean((byte) 1, false)); [EOL]         assertEquals(0, new BitField(2).setByteBoolean((byte) 2, false)); [EOL]         assertEquals(0, new BitField(4).setByteBoolean((byte) 4, false)); [EOL]         assertEquals(0, new BitField(8).setByteBoolean((byte) 8, false)); [EOL]         assertEquals(0, new BitField(16).setByteBoolean((byte) 16, false)); [EOL]         assertEquals(0, new BitField(32).setByteBoolean((byte) 32, false)); [EOL]         assertEquals(0, new BitField(64).setByteBoolean((byte) 64, false)); [EOL]         assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false)); [EOL]         assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false)); [EOL]         final byte clearedBit = new Bit
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[0]; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, true, -1)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[0]; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         array = new boolean[] { true, true, false }; [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[0]; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         array = new boolean[] { true, true, false }; [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[0]; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         array = new boolean[] { true, true, false }; [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 1)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, false, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 1)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 1)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 1)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(2, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 88)); [EOL]     } [EOL]  [EOL]
@Test [EOL]     public void testLastIndexOfBooleanWithStartIndex() { [EOL]         boolean[] array = null; [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 1)); [EOL]         array = new boolean[] { true, true, false, true }; [EOL]         assertEquals(4, ArrayUtils.lastIndexOf(array, true, 2)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, -1)); [EOL]         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 88)); [EOL]     } [EOL]  [EOL]
